## Exercise
Create a function that uses memoization to cache the results of expensive function calls

## Reference Solution
```python
from functools import wraps

def memoize(func):
    """Memoization decorator to cache the results of expensive function calls."""
    cache = dict()

    @wraps(func)
    def memoized_func(*args):
        if args in cache:
            return cache[args]
        else:
            result = func(*args)
            cache[args] = result
            return result

    return memoized_func

# Example usage:
@memoize
def expensive_function(x):
    """Simulating an expensive function call."""
    import time
    time.sleep(2)  # Simulating a 2-second delay
    return x * x

# Test the memoized function
print(expensive_function(5))  # Takes 2 seconds
print(expensive_function(5))  # Returns immediately from cache
print(expensive_function(10))  # Takes 2 seconds
print(expensive_function(10))  # Returns immediately from cache
```

## Generated Output
```
25
25
100
100
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
