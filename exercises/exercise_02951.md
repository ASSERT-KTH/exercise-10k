## Exercise
Write a program to check if a graph contains a cycle using depth-first search.

## Reference Solution
```python
from typing import Dict, List

class Graph:
    def __init__(self, num_vertices: int):
        """
        Initialize a graph with a specified number of vertices.

        Args:
        num_vertices (int): The number of vertices in the graph.
        """
        self.num_vertices = num_vertices
        self.adjacency_list = {i: [] for i in range(num_vertices)}

    def add_edge(self, vertex1: int, vertex2: int):
        """
        Add an edge between two vertices in the graph.

        Args:
        vertex1 (int): The first vertex.
        vertex2 (int): The second vertex.
        """
        self.adjacency_list[vertex1].append(vertex2)

    def has_cycle(self) -> bool:
        """
        Check if the graph contains a cycle using DFS.

        Returns:
        bool: True if the graph contains a cycle, False otherwise.
        """
        visited = [False] * self.num_vertices
        recursion_stack = [False] * self.num_vertices

        for vertex in range(self.num_vertices):
            if not visited[vertex]:
                if self._has_cycle_dfs(vertex, visited, recursion_stack):
                    return True

        return False

    def _has_cycle_dfs(self, vertex: int, visited: List[bool], recursion_stack: List[bool]) -> bool:
        """
        Recursive DFS function to check for cycles.

        Args:
        vertex (int): The current vertex.
        visited (List[bool]): A list of visited vertices.
        recursion_stack (List[bool]): A list of vertices in the current recursion stack.

        Returns:
        bool: True if a cycle is detected, False otherwise.
        """
        visited[vertex] = True
        recursion_stack[vertex] = True

        for neighbor in self.adjacency_list[vertex]:
            if not visited[neighbor]:
                if self._has_cycle_dfs(neighbor, visited, recursion_stack):
                    return True
            elif recursion_stack[neighbor]:
                return True

        recursion_stack[vertex] = False
        return False


# Example usage
if __name__ == "__main__":
    graph = Graph(4)
    graph.add_edge(0, 1)
    graph.add_edge(1, 2)
    graph.add_edge(2, 3)
    graph.add_edge(3, 0)  # This edge creates a cycle

    if graph.has_cycle():
        print("The graph contains a cycle.")
    else:
        print("The graph does not contain a cycle.")

    graph2 = Graph(4)
    graph2.add_edge(0, 1)
    graph2.add_edge(1, 2)
    graph2.add_edge(2, 3)

    if graph2.has_cycle():
        print("The graph contains a cycle.")
    else:
        print("The graph does not contain a cycle.")
```

## Generated Output
```
The graph contains a cycle.
The graph does not contain a cycle.
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
