## Exercise
Create a function that uses concurrent execution to compute the sum of a list of numbers in parallel

## Reference Solution
```python
import concurrent.futures
import numpy as np

def parallel_sum(numbers, num_workers=None):
    """
    Compute the sum of a list of numbers in parallel using concurrent execution.

    Parameters:
    numbers (list): The list of numbers to sum.
    num_workers (int): The number of worker threads or processes to use. If None, 
                       the number of available CPU cores is used.

    Returns:
    int: The sum of the list of numbers.
    """

    # Split the list into chunks
    chunk_size = max(len(numbers) // (num_workers or 1), 1)
    chunks = [numbers[i:i + chunk_size] for i in range(0, len(numbers), chunk_size)]

    # Use ThreadPoolExecutor for CPU-bound tasks or ProcessPoolExecutor for I/O-bound tasks
    # Here, we use ProcessPoolExecutor because it can handle CPU-bound tasks better
    with concurrent.futures.ProcessPoolExecutor(max_workers=num_workers) as executor:
        # Submit the tasks to the executor and collect the results
        results = list(executor.map(sum, chunks))

    # Combine the results
    total_sum = sum(results)

    return total_sum

# Example usage
numbers = np.random.randint(0, 100, size=1000000)
num_workers = 4  # You can adjust this based on your system's capabilities

result = parallel_sum(numbers, num_workers)
print("Sum:", result)
```

## Generated Output
```
Sum: 49496412
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
