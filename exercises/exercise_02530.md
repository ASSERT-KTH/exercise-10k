## Exercise
Implement a DFS algorithm to traverse a graph or tree

## Reference Solution
```python
class Graph:
    def __init__(self, num_vertices):
        """
        Initialize a graph with a specified number of vertices.

        Args:
            num_vertices (int): The number of vertices in the graph.
        """
        self.num_vertices = num_vertices
        self.adj_list = [[] for _ in range(num_vertices)]

    def add_edge(self, v, w):
        """
        Add an edge between two vertices in the graph.

        Args:
            v (int): The source vertex.
            w (int): The destination vertex.
        """
        self.adj_list[v].append(w)

    def dfs(self, start_vertex):
        """
        Perform a depth-first search traversal of the graph starting from a specified vertex.

        Args:
            start_vertex (int): The vertex to start the traversal from.

        Returns:
            list: A list of visited vertices.
        """
        visited = [False] * self.num_vertices
        traversal_order = []

        def dfs_helper(vertex):
            visited[vertex] = True
            traversal_order.append(vertex)
            for neighbor in self.adj_list[vertex]:
                if not visited[neighbor]:
                    dfs_helper(neighbor)

        dfs_helper(start_vertex)
        return traversal_order

# Example usage:
if __name__ == "__main__":
    # Create a sample graph
    graph = Graph(5)
    graph.add_edge(0, 1)
    graph.add_edge(0, 2)
    graph.add_edge(1, 3)
    graph.add_edge(1, 4)

    # Perform DFS traversal starting from vertex 0
    traversal_order = graph.dfs(0)
    print("DFS Traversal Order:", traversal_order)
```

## Generated Output
```
DFS Traversal Order: [0, 1, 3, 4, 2]
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
