## Exercise
Implement a function to find the minimum spanning tree of a weighted graph.

## Reference Solution
```python
class DisjointSet:
    """Disjoint set data structure to keep track of connected components."""
    def __init__(self, vertices):
        self.parent = {v: v for v in vertices}
        self.rank = {v: 0 for v in vertices}

    def find(self, vertex):
        """Find the root of the set containing the given vertex."""
        if self.parent[vertex] != vertex:
            self.parent[vertex] = self.find(self.parent[vertex])
        return self.parent[vertex]

    def union(self, vertex1, vertex2):
        """Merge the sets containing the given vertices."""
        root1 = self.find(vertex1)
        root2 = self.find(vertex2)
        if root1 != root2:
            if self.rank[root1] > self.rank[root2]:
                self.parent[root2] = root1
            else:
                self.parent[root1] = root2
                if self.rank[root1] == self.rank[root2]:
                    self.rank[root2] += 1


def kruskal(graph):
    """
    Find the minimum spanning tree of a weighted graph using Kruskal's algorithm.

    Args:
        graph: A dictionary representing the graph, where each key is a vertex and
            each value is a list of tuples containing the adjacent vertex and the edge weight.

    Returns:
        A list of tuples containing the edges in the minimum spanning tree, along with their weights.
    """
    vertices = list(graph.keys())
    disjoint_set = DisjointSet(vertices)
    edges = []
    for vertex in graph:
        for neighbor, weight in graph[vertex]:
            edges.append((weight, vertex, neighbor))
    edges.sort()
    mst_edges = []
    for edge in edges:
        weight, vertex1, vertex2 = edge
        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):
            mst_edges.append(edge)
            disjoint_set.union(vertex1, vertex2)
    return mst_edges


# Example usage:
if __name__ == "__main__":
    graph = {
        'A': [('B', 2), ('C', 3)],
        'B': [('A', 2), ('C', 1), ('D', 4)],
        'C': [('A', 3), ('B', 1), ('D', 5)],
        'D': [('B', 4), ('C', 5)]
    }
    mst_edges = kruskal(graph)
    print("Minimum Spanning Tree Edges:")
    for edge in mst_edges:
        print(f"Weight: {edge[0]}, Edge: {edge[1]}-{edge[2]}")
```

## Generated Output
```
Minimum Spanning Tree Edges:
Weight: 1, Edge: B-C
Weight: 2, Edge: A-B
Weight: 4, Edge: B-D
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
