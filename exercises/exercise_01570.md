## Exercise
Create a function that uses memoization to optimize the calculation of a recursive function.

## Reference Solution
```python
def fibonacci(n, memo={}):
    """
    Calculate the nth Fibonacci number using memoization.

    Args:
        n (int): The position of the Fibonacci number to calculate.
        memo (dict, optional): A dictionary to store previously calculated Fibonacci numbers. Defaults to {}.

    Returns:
        int: The nth Fibonacci number.
    """

    # Check if the input is a non-negative integer
    if not isinstance(n, int) or n < 0:
        raise ValueError("Input must be a non-negative integer")

    # Base case: If n is 0 or 1, return n
    if n <= 1:
        return n

    # Check if the Fibonacci number for n is already in the memo dictionary
    if n not in memo:
        # If not, calculate it recursively and store it in the memo dictionary
        # We use the formula F(n) = F(n-1) + F(n-2) to calculate the nth Fibonacci number
        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)

    # Return the nth Fibonacci number from the memo dictionary
    return memo[n]

# Test the function
print(fibonacci(10))  # Output: 55
```

## Generated Output
```
55
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
