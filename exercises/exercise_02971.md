## Exercise
Write a program that solves a maze by finding the shortest path from the start to the end. The maze should be represented as a 2D grid.

## Reference Solution
```python
from collections import deque

def solve_maze(maze):
    """
    Solves the maze by finding the shortest path from the start to the end.

    Args:
        maze (list): A 2D grid representing the maze.

    Returns:
        list: A list of coordinates representing the shortest path.
    """

    # Find the start and end points
    start = None
    end = None
    for i in range(len(maze)):
        for j in range(len(maze[i])):
            if maze[i][j] == 'S':
                start = (i, j)
            elif maze[i][j] == 'E':
                end = (i, j)

    # Check if start and end points are found
    if start is None or end is None:
        raise ValueError("Start or end point not found in the maze")

    # Define the possible movements (up, down, left, right)
    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    # Create a queue for BFS and add the start point
    queue = deque([(start, [start])])

    # Create a set to keep track of visited cells
    visited = set([start])

    while queue:
        # Dequeue the next cell
        (cell, path) = queue.popleft()

        # If this is the end point, return the path
        if cell == end:
            return path

        # Explore the neighbors
        for movement in movements:
            x, y = cell[0] + movement[0], cell[1] + movement[1]

            # Check if the neighbor is within the maze boundaries and is not a wall
            if (0 <= x < len(maze) and 0 <= y < len(maze[x]) and
                    maze[x][y] != '1' and (x, y) not in visited):
                # Mark the neighbor as visited and add it to the queue
                visited.add((x, y))
                queue.append(((x, y), path + [(x, y)]))

    # If no path is found, return None
    return None

# Example usage
maze = [
    ['S', '0', '0', '1', '0'],
    ['1', '1', '0', '1', '0'],
    ['0', '0', '0', '0', '0'],
    ['1', '1', '1', '0', '1'],
    ['0', '0', '0', '0', 'E']
]

path = solve_maze(maze)
if path:
    print("Shortest path found:", path)
else:
    print("No path found")
```

## Generated Output
```
Shortest path found: [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3), (3, 3), (4, 3), (4, 4)]
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
