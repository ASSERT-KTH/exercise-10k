## Exercise
Create a function that memoizes another function, caching its results to avoid redundant computation.

## Reference Solution
```python
def memoize(func):
    """
    A decorator function that memoizes another function, caching its results to avoid redundant computation.

    Args:
        func (function): The function to be memoized.

    Returns:
        function: A new function that caches the results of the original function.
    """

    # Create a dictionary to store the cached results
    cache = {}

    # Define a new function that will wrap the original function
    def memoized_func(*args, **kwargs):
        
        # Create a key based on the arguments passed to the function
        key = str(args) + str(kwargs)
        
        # Check if the result is already in the cache
        if key in cache:
            # If it is, return the cached result
            return cache[key]
        else:
            # If not, compute the result and store it in the cache
            result = func(*args, **kwargs)
            cache[key] = result
            return result

    # Return the new memoized function
    return memoized_func


# Example usage:

# Define a function to be memoized
@memoize
def add(a, b):
    # Simulate an expensive computation
    import time
    time.sleep(1)
    return a + b

# Test the memoized function
print(add(2, 3))  # This should take about 1 second
print(add(2, 3))  # This should be instant
```

## Generated Output
```
5
5
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
