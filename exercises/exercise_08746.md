## Exercise
Compress complex variables to reduce their size and improve storage efficiency.

## Reference Solution
```python
import numpy as np

# Original data
data = np.array([10, 12, 15, 18, 20])

# Delta encoded data
delta_encoded_data = np.diff(data)

print(delta_encoded_data)  # Output: [2, 3, 3, 2]
```

```python
import numpy as np

# Original data
data = np.array([1, 1, 1, 2, 2, 3, 3, 3, 3])

# RLE encoded data
rle_encoded_data = []
count = 1
for i in range(1, len(data)):
    if data[i] == data[i-1]:
        count += 1
    else:
        rle_encoded_data.append((data[i-1], count))
        count = 1
rle_encoded_data.append((data[-1], count))

print(rle_encoded_data)  # Output: [(1, 3), (2, 2), (3, 4)]
```

```python
import numpy as np
from heapq import heapify, heappop, heappush

# Original data
data = np.array([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])

# Huffman coding
class Node:
    def __init__(self, value, frequency):
        self.value = value
        self.frequency = frequency
        self.left = None
        self.right = None

    def __lt__(self, other):
        return self.frequency < other.frequency

# Build frequency table
frequency_table = {}
for value in data:
    if value not in frequency_table:
        frequency_table[value] = 0
    frequency_table[value] += 1

# Build Huffman tree
heap = []
for value, frequency in frequency_table.items():
    node = Node(value, frequency)
    heappush(heap, node)

while len(heap) > 1:
    node1 = heappop(heap)
    node2 = heappop(heap)
    merged_node = Node(None, node1.frequency + node2.frequency)
    merged_node.left = node1
    merged_node.right = node2
    heappush(heap, merged_node)

# Generate Huffman codes
huffman_codes = {}
def generate_codes(node, code):
    if node.value is not None:
        huffman_codes[node.value] = code
    if node.left is not None:
        generate_codes(node.left, code + '0')
    if node.right is not None:
        generate_codes(node.right, code + '1')

generate_codes(heap[0], '')

# Compress data using Huffman codes
compressed_data = ''
for value in data:
    compressed_data += huffman_codes[value]

print(compressed_data)
```

```python
import numpy as np

# Original data
data = np.array([1.2, 2.5, 3.7, 4.9, 6.1])

# Quantized data
quantized_data = np.round(data / 2) * 2

print(quantized_data)  # Output: [2., 2., 4., 4., 6.]
```

## Generated Output
```
[2 3 3 2]
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
