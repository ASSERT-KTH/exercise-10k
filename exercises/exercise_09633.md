## Exercise
Write a function that uses memoization to cache the results of expensive function calls.

## Reference Solution
```python
from functools import wraps

def memoize(func):
    """
    Memoization decorator to cache the results of expensive function calls.

    Args:
    func: The function to be memoized.

    Returns:
    A wrapper function that caches the results of the input function.
    """
    cache = dict()

    @wraps(func)
    def memoized_func(*args):
        if args in cache:
            return cache[args]
        else:
            result = func(*args)
            cache[args] = result
            return result

    return memoized_func

# Example usage:
@memoize
def expensive_function(x):
    """
    An example of an expensive function that calculates the factorial of a number.

    Args:
    x (int): The input number.

    Returns:
    int: The factorial of the input number.
    """
    if x == 0:
        return 1
    else:
        return x * expensive_function(x - 1)

# Test the memoized function:
print(expensive_function(5))  # Calculates and caches the result
print(expensive_function(5))  # Returns the cached result
```

## Generated Output
```
120
120
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
