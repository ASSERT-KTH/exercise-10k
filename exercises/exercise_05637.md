## Exercise
Write a program to check if a given graph is bipartite or not.

## Reference Solution
```python
from collections import deque

def is_bipartite(graph):
    """
    Checks if a given graph is bipartite.

    Args:
    graph (dict): An adjacency list representation of the graph.

    Returns:
    bool: True if the graph is bipartite, False otherwise.
    """
    color = {}

    for node in graph:
        if node not in color:
            if not bfs(graph, node, color):
                return False

    return True


def bfs(graph, node, color):
    """
    Performs a breadth-first search to assign colors to nodes.

    Args:
    graph (dict): An adjacency list representation of the graph.
    node (int): The current node.
    color (dict): A dictionary to store the color of each node.

    Returns:
    bool: True if the graph is bipartite, False otherwise.
    """
    queue = deque([node])
    color[node] = 0  # 0 represents one color, 1 represents the other color

    while queue:
        current_node = queue.popleft()

        for neighbor in graph[current_node]:
            if neighbor not in color:
                color[neighbor] = 1 - color[current_node]  # Assign the opposite color
                queue.append(neighbor)
            elif color[neighbor] == color[current_node]:
                return False  # If two adjacent nodes have the same color, the graph is not bipartite

    return True


# Example usage
if __name__ == "__main__":
    # Define a bipartite graph
    bipartite_graph = {
        0: [1, 3],
        1: [0, 2],
        2: [1, 3],
        3: [0, 2]
    }

    # Define a non-bipartite graph
    non_bipartite_graph = {
        0: [1, 2],
        1: [0, 2],
        2: [0, 1]
    }

    print(is_bipartite(bipartite_graph))  # Output: True
    print(is_bipartite(non_bipartite_graph))  # Output: False
```

## Generated Output
```
True
False
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
