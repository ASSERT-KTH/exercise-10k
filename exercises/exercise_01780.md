## Exercise
Write a function to find the strongly connected components of a given graph.

## Reference Solution
```python
from collections import defaultdict

def kosaraju(graph):
    """
    Find the strongly connected components of a given graph.

    Args:
    graph (dict): The input graph, represented as an adjacency list.

    Returns:
    list: A list of strongly connected components, where each component is a list of vertices.
    """
    # Step 1: Get the transpose of the graph
    transpose_graph = transpose(graph)

    # Step 2: Perform a DFS on the original graph to get the finishing times
    visited = set()
    finishing_times = []
    for vertex in graph:
        if vertex not in visited:
            dfs(graph, vertex, visited, finishing_times)

    # Step 3: Perform a DFS on the transpose graph in the order of the finishing times
    visited = set()
    sccs = []
    for vertex in reversed(finishing_times):
        if vertex not in visited:
            component = []
            dfs_util(transpose_graph, vertex, visited, component)
            sccs.append(component)

    return sccs


def transpose(graph):
    """
    Get the transpose of a given graph.

    Args:
    graph (dict): The input graph, represented as an adjacency list.

    Returns:
    dict: The transpose of the input graph.
    """
    transpose_graph = defaultdict(list)
    for vertex in graph:
        for neighbor in graph[vertex]:
            transpose_graph[neighbor].append(vertex)
    return transpose_graph


def dfs(graph, vertex, visited, finishing_times):
    """
    Perform a DFS on a given graph starting from a given vertex.

    Args:
    graph (dict): The input graph, represented as an adjacency list.
    vertex: The starting vertex.
    visited (set): A set of visited vertices.
    finishing_times (list): A list to store the finishing times of the vertices.
    """
    visited.add(vertex)
    for neighbor in graph[vertex]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited, finishing_times)
    finishing_times.append(vertex)


def dfs_util(graph, vertex, visited, component):
    """
    Perform a DFS on a given graph starting from a given vertex and add the visited vertices to a component.

    Args:
    graph (dict): The input graph, represented as an adjacency list.
    vertex: The starting vertex.
    visited (set): A set of visited vertices.
    component (list): A list to store the vertices of a strongly connected component.
    """
    visited.add(vertex)
    component.append(vertex)
    for neighbor in graph[vertex]:
        if neighbor not in visited:
            dfs_util(graph, neighbor, visited, component)


# Example usage
if __name__ == "__main__":
    graph = {
        'A': ['B'],
        'B': ['C', 'D'],
        'C': ['A', 'D'],
        'D': ['E'],
        'E': []
    }
    sccs = kosaraju(graph)
    print("Strongly connected components:")
    for i, component in enumerate(sccs):
        print(f"Component {i+1}: {component}")
```

## Generated Output
```
Strongly connected components:
Component 1: ['A', 'C', 'B']
Component 2: ['D']
Component 3: ['E']
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
