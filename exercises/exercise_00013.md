## Exercise
Write a program to catch and handle exceptions that occur during execution.

## Reference Solution
```python
# Define a custom exception class
class CustomException(Exception):
    """A custom exception class."""
    pass

def divide_numbers(num1, num2):
    """
    Divide two numbers.

    Args:
        num1 (float): The dividend.
        num2 (float): The divisor.

    Returns:
        float: The quotient.

    Raises:
        ZeroDivisionError: If the divisor is zero.
        TypeError: If the inputs are not numbers.
    """
    try:
        # Check if inputs are numbers
        if not isinstance(num1, (int, float)) or not isinstance(num2, (int, float)):
            raise TypeError("Inputs must be numbers")

        # Check for division by zero
        if num2 == 0:
            raise ZeroDivisionError("Cannot divide by zero")

        # Perform division
        result = num1 / num2
        return result

    except ZeroDivisionError as e:
        print(f"Error: {e}")
    except TypeError as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

def main():
    # Test the divide_numbers function
    print(divide_numbers(10, 2))  # Expected output: 5.0
    print(divide_numbers(10, 0))  # Expected output: Error: Cannot divide by zero
    print(divide_numbers("a", 2))  # Expected output: Error: Inputs must be numbers

    # Test custom exception
    try:
        raise CustomException("A custom exception occurred")
    except CustomException as e:
        print(f"Custom exception: {e}")

if __name__ == "__main__":
    main()
```

## Generated Output
```
5.0
Error: Cannot divide by zero
None
Error: Inputs must be numbers
None
Custom exception: A custom exception occurred
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
