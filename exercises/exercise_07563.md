## Exercise
Create a function that uses lazy evaluation to delay the computation of a value until it's actually needed.

## Reference Solution
```python
# We'll create a class to handle the lazy evaluation. This class will store a function and its arguments.
class LazyEvaluator:
    """
    A class that uses lazy evaluation to delay the computation of a value until it's actually needed.
    
    Attributes:
    func (function): The function to be evaluated.
    args (tuple): The arguments to be passed to the function.
    
    Methods:
    __init__: Initializes the LazyEvaluator object with a function and its arguments.
    __call__: Calls the stored function with the stored arguments when the LazyEvaluator object is invoked like a function.
    """

    # Initialize the LazyEvaluator object with a function and its arguments.
    def __init__(self, func, *args):
        # Store the function and its arguments.
        self.func = func
        self.args = args
    
    # When the LazyEvaluator object is invoked like a function, call the stored function with the stored arguments.
    def __call__(self):
        # Return the result of the function call.
        return self.func(*self.args)


# Create a function that will be used for lazy evaluation.
def add(a, b):
    # This function simply adds two numbers.
    return a + b

# Create a LazyEvaluator object with the add function and its arguments.
lazy_add = LazyEvaluator(add, 1, 2)

# The computation of add(1, 2) is delayed until lazy_add is actually called.
print(lazy_add())  # Output: 3
```

## Generated Output
```
3
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
