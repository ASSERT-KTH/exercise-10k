## Exercise
Develop a program that simulates the Game of Life. The program should generate a 2D grid, ask for user input, and determine the next generation based on the game's rules.

## Reference Solution
```python
import numpy as np
import random
import time
import os

def create_grid(rows, cols):
    """
    Create a 2D grid with random cell values (0 = dead, 1 = alive).
    
    Args:
        rows (int): Number of rows in the grid.
        cols (int): Number of columns in the grid.
    
    Returns:
        np.ndarray: A 2D grid with random cell values.
    """
    grid = np.zeros((rows, cols))
    for i in range(rows):
        for j in range(cols):
            grid[i][j] = random.choice([0, 1])
    return grid

def print_grid(grid):
    """
    Print the current state of the grid.
    
    Args:
        grid (np.ndarray): The 2D grid to print.
    """
    os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console
    for row in grid:
        print(' '.join(['*' if cell else ' ' for cell in row]))

def count_neighbours(grid, i, j):
    """
    Count the number of live neighbours for a cell.
    
    Args:
        grid (np.ndarray): The 2D grid.
        i (int): The row index of the cell.
        j (int): The column index of the cell.
    
    Returns:
        int: The number of live neighbours.
    """
    rows, cols = grid.shape
    count = 0
    for x in range(max(0, i-1), min(rows, i+2)):
        for y in range(max(0, j-1), min(cols, j+2)):
            if (x, y) != (i, j) and grid[x][y] == 1:
                count += 1
    return count

def next_generation(grid):
    """
    Determine the next generation based on the game's rules.
    
    Args:
        grid (np.ndarray): The current 2D grid.
    
    Returns:
        np.ndarray: The next generation grid.
    """
    rows, cols = grid.shape
    next_grid = np.copy(grid)
    for i in range(rows):
        for j in range(cols):
            live_neighbours = count_neighbours(grid, i, j)
            if grid[i][j] == 1 and (live_neighbours < 2 or live_neighbours > 3):
                next_grid[i][j] = 0  # Death by isolation or overcrowding
            elif grid[i][j] == 0 and live_neighbours == 3:
                next_grid[i][j] = 1  # Reproduction
    return next_grid

def main():
    rows = int(input("Enter the number of rows: "))
    cols = int(input("Enter the number of columns: "))
    grid = create_grid(rows, cols)
    
    while True:
        print_grid(grid)
        grid = next_generation(grid)
        time.sleep(0.5)  # Pause for 0.5 seconds

if __name__ == "__main__":
    main()
```

## Generated Output
```
Enter the number of rows: 
Traceback (most recent call last):
  File "/tmp/tmp0gtutgp4.py", line 86, in <module>
    main()
  File "/tmp/tmp0gtutgp4.py", line 76, in main
    rows = int(input("Enter the number of rows: "))
ValueError: invalid literal for int() with base 10: '1 1'
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
