## Exercise
Create a function that memoizes another function, caching its results to avoid redundant computation, and also handles cache invalidation.

## Reference Solution
```python
def memoize(func):
    """
    A decorator function that memoizes another function, caching its results to avoid redundant computation.
    
    Args:
        func (function): The input function to be memoized.
    
    Returns:
        function: A new function that wraps the input function with memoization.
    """

    # Create a dictionary to store the cached results
    cache = {}

    # Define a new function that will wrap the input function
    def memoized_func(*args, **kwargs):
        
        # Create a key for the cache dictionary based on the function arguments
        key = str(args) + str(kwargs)
        
        # Check if the result is already in the cache
        if key in cache:
            # If it is, return the cached result
            return cache[key]
        else:
            # If not, compute the result using the input function
            result = func(*args, **kwargs)
            
            # Store the result in the cache
            cache[key] = result
            
            # Return the result
            return result

    # Define a method to invalidate the cache
    def invalidate_cache():
        cache.clear()

    # Add the invalidate_cache method to the memoized function
    memoized_func.invalidate_cache = invalidate_cache

    # Return the memoized function
    return memoized_func


# Example usage:

@memoize
def add(a, b):
    # Simulate an expensive computation
    import time
    time.sleep(2)
    return a + b

print(add(2, 3))  # This will take 2 seconds
print(add(2, 3))  # This will return immediately from the cache
add.invalidate_cache()  # Invalidate the cache
print(add(2, 3))  # This will take 2 seconds again
```

## Generated Output
```
5
5
5
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
