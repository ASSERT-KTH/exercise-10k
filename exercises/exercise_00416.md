## Exercise
Given a grid with obstacles, find the shortest path from the start to the end.

## Reference Solution
```python
from collections import deque

def shortest_path(grid):
    """
    Find the shortest path from the start to the end in a grid with obstacles.

    Args:
    grid (list[list[int]]): A 2D array representing the grid.

    Returns:
    list[tuple[int, int]]: The shortest path from the start to the end.
    """
    # Find the start and end cells
    start = None
    end = None
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 'S':
                start = (i, j)
            elif grid[i][j] == 'E':
                end = (i, j)

    # Check if the start and end cells are valid
    if start is None or end is None:
        return []

    # Create a queue and a set to store the visited cells
    queue = deque([(start, [start])])
    visited = set([start])

    # Define the possible movements (up, down, left, right)
    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while queue:
        (cell, path) = queue.popleft()
        if cell == end:
            return path

        # Explore the neighboring cells
        for movement in movements:
            x, y = cell[0] + movement[0], cell[1] + movement[1]

            # Check if the neighboring cell is valid
            if (0 <= x < len(grid) and 0 <= y < len(grid[0]) and
                    grid[x][y] != 1 and (x, y) not in visited):
                queue.append(((x, y), path + [(x, y)]))
                visited.add((x, y))

    # If the end cell is not reachable, return an empty path
    return []

# Example usage
grid = [
    [0, 0, 1, 0],
    [0, 'S', 0, 0],
    [0, 1, 1, 0],
    [0, 0, 0, 'E']
]

path = shortest_path(grid)
print(path)
```

## Generated Output
```
[(1, 1), (1, 2), (1, 3), (2, 3), (3, 3)]
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
