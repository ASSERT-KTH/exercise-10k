## Exercise
Create a function that uses memoization to cache its results and avoid redundant computations

## Reference Solution
```python
from functools import wraps

def memoize(func):
    """Decorator to memoize function results."""
    cache = dict()

    @wraps(func)
    def memoized_func(*args):
        if args in cache:
            return cache[args]
        else:
            result = func(*args)
            cache[args] = result
            return result

    return memoized_func

@memoize
def fibonacci(n):
    """Calculate the nth Fibonacci number."""
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Example usage:
print(fibonacci(10))  # Calculate the 10th Fibonacci number
```

## Generated Output
```
55
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
