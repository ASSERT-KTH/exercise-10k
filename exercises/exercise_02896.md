## Exercise
Write a program to perform modular arithmetic operations (e.g., addition, subtraction, multiplication, division) with a given modulus.

## Reference Solution
```python
def mod_add(a, b, modulus):
    """
    Modular addition.
    
    Parameters:
    a (int): The first operand.
    b (int): The second operand.
    modulus (int): The modulus.
    
    Returns:
    int: The result of the modular addition.
    """
    return (a + b) % modulus


def mod_sub(a, b, modulus):
    """
    Modular subtraction.
    
    Parameters:
    a (int): The first operand.
    b (int): The second operand.
    modulus (int): The modulus.
    
    Returns:
    int: The result of the modular subtraction.
    """
    return (a - b) % modulus


def mod_mul(a, b, modulus):
    """
    Modular multiplication.
    
    Parameters:
    a (int): The first operand.
    b (int): The second operand.
    modulus (int): The modulus.
    
    Returns:
    int: The result of the modular multiplication.
    """
    return (a * b) % modulus


def mod_div(a, b, modulus):
    """
    Modular division.
    
    Parameters:
    a (int): The dividend.
    b (int): The divisor.
    modulus (int): The modulus.
    
    Returns:
    int: The result of the modular division.
    
    Raises:
    ValueError: If the divisor is zero or if the modulus is not coprime with the divisor.
    """
    if b == 0:
        raise ValueError("Divisor cannot be zero.")
    if gcd(b, modulus) != 1:
        raise ValueError("Modulus and divisor must be coprime.")
    
    # Calculate the modular multiplicative inverse using the extended Euclidean algorithm
    inverse = mod_inverse(b, modulus)
    return (a * inverse) % modulus


def gcd(a, b):
    """
    Calculate the greatest common divisor of two numbers using the Euclidean algorithm.
    
    Parameters:
    a (int): The first number.
    b (int): The second number.
    
    Returns:
    int: The greatest common divisor.
    """
    while b:
        a, b = b, a % b
    return a


def mod_inverse(a, modulus):
    """
    Calculate the modular multiplicative inverse using the extended Euclidean algorithm.
    
    Parameters:
    a (int): The number to find the inverse for.
    modulus (int): The modulus.
    
    Returns:
    int: The modular multiplicative inverse.
    """
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        else:
            gcd, x, y = extended_gcd(b % a, a)
            return gcd, y - (b // a) * x, x
    
    gcd, x, _ = extended_gcd(a, modulus)
    if gcd != 1:
        raise ValueError("Modulus and number must be coprime.")
    return x % modulus


def main():
    modulus = int(input("Enter the modulus: "))
    print("Modular Arithmetic Operations")
    print("-------------------------------")
    print("1. Addition")
    print("2. Subtraction")
    print("3. Multiplication")
    print("4. Division")
    choice = int(input("Enter your choice (1-4): "))
    
    if choice in [1, 2, 3]:
        a = int(input("Enter the first operand: "))
        b = int(input("Enter the second operand: "))
        
        if choice == 1:
            print(f"{a} + {b} (mod {modulus}) = {mod_add(a, b, modulus)}")
        elif choice == 2:
            print(f"{a} - {b} (mod {modulus}) = {mod_sub(a, b, modulus)}")
        elif choice == 3:
            print(f"{a} * {b} (mod {modulus}) = {mod_mul(a, b, modulus)}")
    
    elif choice == 4:
        a = int(input("Enter the dividend: "))
        b = int(input("Enter the divisor: "))
        print(f"{a} / {b} (mod {modulus}) = {mod_div(a, b, modulus)}")
    
    else:
        print("Invalid choice.")


if __name__ == "__main__":
    main()
```

## Generated Output
```
Enter the modulus: 
Traceback (most recent call last):
  File "/tmp/tmpdybbik7x.py", line 142, in <module>
    main()
  File "/tmp/tmpdybbik7x.py", line 112, in main
    modulus = int(input("Enter the modulus: "))
ValueError: invalid literal for int() with base 10: '17 5 10'
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
