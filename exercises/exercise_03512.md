## Exercise
Write a program that demonstrates implicit type conversion between different data types.

## Reference Solution
```python
# Implicit Type Conversion Demo

def implicit_type_conversion():
    # Integer to Float
    print("Integer to Float:")
    a = 10
    b = 3.5
    print(f"a = {a}, type(a) = {type(a)}")
    print(f"b = {b}, type(b) = {type(b)}")
    print(f"a + b = {a + b}, type(a + b) = {type(a + b)}")

    # Float to Complex
    print("\nFloat to Complex:")
    c = 5.2
    d = 3 + 4j
    print(f"c = {c}, type(c) = {type(c)}")
    print(f"d = {d}, type(d) = {type(d)}")
    print(f"c + d = {c + d}, type(c + d) = {type(c + d)}")

    # Boolean to Integer
    print("\nBoolean to Integer:")
    e = True
    f = False
    print(f"e = {e}, type(e) = {type(e)}")
    print(f"f = {f}, type(f) = {type(f)}")
    print(f"e + f = {e + f}, type(e + f) = {type(e + f)}")

    # String to Integer (Error)
    print("\nString to Integer (Error):")
    try:
        g = "10"
        h = 5
        print(f"g = {g}, type(g) = {type(g)}")
        print(f"h = {h}, type(h) = {type(h)}")
        print(f"g + h = {g + h}, type(g + h) = {type(g + h)}")
    except TypeError as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    implicit_type_conversion()
```

## Generated Output
```
Integer to Float:
a = 10, type(a) = <class 'int'>
b = 3.5, type(b) = <class 'float'>
a + b = 13.5, type(a + b) = <class 'float'>

Float to Complex:
c = 5.2, type(c) = <class 'float'>
d = (3+4j), type(d) = <class 'complex'>
c + d = (8.2+4j), type(c + d) = <class 'complex'>

Boolean to Integer:
e = True, type(e) = <class 'bool'>
f = False, type(f) = <class 'bool'>
e + f = 1, type(e + f) = <class 'int'>

String to Integer (Error):
g = 10, type(g) = <class 'str'>
h = 5, type(h) = <class 'int'>
Error: can only concatenate str (not "int") to str
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
