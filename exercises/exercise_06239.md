## Exercise
Write a program that finds the shortest path in a given grid from a starting point to an ending point.

## Reference Solution
```python
import heapq

# Define the possible movements in the grid (up, down, left, right)
movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]

def heuristic(node, end):
    """
    Calculate the Manhattan distance between two nodes.
    """
    return abs(node[0] - end[0]) + abs(node[1] - end[1])

def astar(grid, start, end):
    """
    Find the shortest path in the grid from the start to the end using A\*.
    """
    # Initialize the open and closed lists
    open_list = []
    closed_list = set()

    # Add the start node to the open list
    heapq.heappush(open_list, (0, start))

    # Initialize the cost and parent dictionaries
    cost = {start: 0}
    parent = {start: None}

    while open_list:
        # Get the node with the lowest f-score
        current_cost, current_node = heapq.heappop(open_list)

        # If we've reached the end, reconstruct the path
        if current_node == end:
            path = []
            while current_node:
                path.append(current_node)
                current_node = parent[current_node]
            return path[::-1]

        # Add the current node to the closed list
        closed_list.add(current_node)

        # Explore the neighbors of the current node
        for movement in movements:
            neighbor = (current_node[0] + movement[0], current_node[1] + movement[1])

            # Skip if the neighbor is out of bounds or is an obstacle
            if (neighbor[0] < 0 or neighbor[0] >= len(grid) or
                    neighbor[1] < 0 or neighbor[1] >= len(grid[0]) or
                    grid[neighbor[0]][neighbor[1]] == 1):
                continue

            # Calculate the new cost to reach the neighbor
            new_cost = cost[current_node] + 1

            # If the neighbor is not in the open list or has a lower cost, update it
            if neighbor not in cost or new_cost < cost[neighbor]:
                cost[neighbor] = new_cost
                priority = new_cost + heuristic(neighbor, end)
                heapq.heappush(open_list, (priority, neighbor))
                parent[neighbor] = current_node

    # If there is no path to the end, return None
    return None

# Example usage
grid = [
    [0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 1, 0, 0, 0],
    [0, 0, 0, 0, 0]
]
start = (0, 0)
end = (4, 4)

path = astar(grid, start, end)
if path:
    print("Shortest path:", path)
else:
    print("No path found")
```

## Generated Output
```
Shortest path: [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
