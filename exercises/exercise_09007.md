## Exercise
Create a function that uses caching to store the results of expensive function calls.

## Reference Solution
```python
import functools
import time

def expensive_function(x):
    """Simulate an expensive function call"""
    time.sleep(2)  # Simulate a 2-second delay
    return x * x

@functools.lru_cache(maxsize=None)
def cached_expensive_function(x):
    """Cache the results of expensive function calls"""
    return expensive_function(x)

# Example usage
if __name__ == "__main__":
    print("Calling cached_expensive_function(5)...")
    start_time = time.time()
    result1 = cached_expensive_function(5)
    end_time = time.time()
    print(f"Result: {result1}, Time taken: {end_time - start_time} seconds")

    print("\nCalling cached_expensive_function(5) again...")
    start_time = time.time()
    result2 = cached_expensive_function(5)
    end_time = time.time()
    print(f"Result: {result2}, Time taken: {end_time - start_time} seconds")

    print("\nCalling cached_expensive_function(10)...")
    start_time = time.time()
    result3 = cached_expensive_function(10)
    end_time = time.time()
    print(f"Result: {result3}, Time taken: {end_time - start_time} seconds")
```

## Generated Output
```
Calling cached_expensive_function(5)...
Result: 25, Time taken: 2.0020439624786377 seconds

Calling cached_expensive_function(5) again...
Result: 25, Time taken: 1.9073486328125e-06 seconds

Calling cached_expensive_function(10)...
Result: 100, Time taken: 2.0006144046783447 seconds
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
