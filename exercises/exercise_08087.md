## Exercise
Write a function that uses memoization to cache the results of expensive function calls

## Reference Solution
```python
from functools import wraps

def memoize(func):
    """
    Memoization decorator to cache the results of expensive function calls.
    
    Args:
        func: The function to be memoized.
    
    Returns:
        A memoized version of the function.
    """
    cache = dict()

    @wraps(func)
    def memoized_func(*args):
        if args in cache:
            return cache[args]
        else:
            result = func(*args)
            cache[args] = result
            return result

    return memoized_func

# Example usage:
@memoize
def expensive_function(x):
    """
    An example of an expensive function that takes a long time to compute.
    
    Args:
        x: The input to the function.
    
    Returns:
        The result of the function.
    """
    import time
    time.sleep(2)  # Simulate an expensive computation
    return x * x

# Test the memoized function
print(expensive_function(10))  # This will take 2 seconds to compute
print(expensive_function(10))  # This will return the cached result immediately
print(expensive_function(20))  # This will take 2 seconds to compute
print(expensive_function(20))  # This will return the cached result immediately
```

## Generated Output
```
100
100
400
400
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
