## Exercise
Given two strings s and t, find the minimum window in s that contains all characters of t. If no such window exists, return an empty string. The window must contain all characters of t in any order, and the characters in the window can be repeated.

## Reference Solution
```python
from collections import Counter

def min_window(s: str, t: str) -> str:
    """
    Find the minimum window in s that contains all characters of t.
    
    Args:
    s (str): The string to search for the minimum window.
    t (str): The string containing the characters to search for.
    
    Returns:
    str: The minimum window in s that contains all characters of t. If no such window exists, returns an empty string.
    """
    
    # Base case: If t is longer than s or if t is empty, return an empty string.
    if len(t) > len(s) or not t:
        return ""
    
    # Create a hash map to store the frequency of characters in t.
    t_count = Counter(t)
    
    # Initialize the required character count to the length of t.
    required = len(t_count)
    
    # Initialize the left and right pointers of the sliding window.
    left = 0
    
    # Initialize the minimum window size to infinity and the minimum window to an empty string.
    min_window_size = float('inf')
    min_window = ""
    
    # Initialize the formed character count to 0.
    formed = 0
    
    # Create a hash map to store the frequency of characters in the current window.
    window_counts = {}
    
    # Iterate over the string s.
    for right in range(len(s)):
        # Get the character at the right pointer.
        character = s[right]
        
        # If the character is in t, increment its count in the window.
        if character in t_count:
            window_counts[character] = window_counts.get(character, 0) + 1
            
            # If the count of the character in the window is equal to the count in t, increment the formed count.
            if window_counts[character] == t_count[character]:
                formed += 1
        
        # While the window contains all characters of t and the left pointer is less than the right pointer.
        while left <= right and formed == required:
            # Get the character at the left pointer.
            character = s[left]
            
            # If the size of the current window is less than the minimum window size, update the minimum window size and the minimum window.
            if right - left + 1 < min_window_size:
                min_window_size = right - left + 1
                min_window = s[left:right + 1]
            
            # If the character at the left pointer is in t, decrement its count in the window.
            if character in t_count:
                window_counts[character] -= 1
                
                # If the count of the character in the window is less than the count in t, decrement the formed count.
                if window_counts[character] < t_count[character]:
                    formed -= 1
            
            # Move the left pointer to the right.
            left += 1
    
    # Return the minimum window.
    return min_window

# Example usage:
s = "ADOBECODEBANC"
t = "ABC"
print(min_window(s, t))  # Output: "BANC"
```

## Generated Output
```
BANC
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
