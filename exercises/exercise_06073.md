## Exercise
Write a program that simulates the Game of Life using a while loop. The game should iterate over a grid of cells, applying the rules of the game to each cell.

## Reference Solution
```python
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import random

# Define the size of the grid
GRID_SIZE = 50

# Initialize the grid with random values
grid = np.zeros((GRID_SIZE, GRID_SIZE))
for i in range(GRID_SIZE):
    for j in range(GRID_SIZE):
        grid[i, j] = random.choice([0, 1])

# Define the rules of the game
def count_neighbors(grid, i, j):
    """Count the number of live neighbors for a given cell."""
    neighbors = 0
    for x in range(-1, 2):
        for y in range(-1, 2):
            col = (j + y + GRID_SIZE) % GRID_SIZE
            row = (i + x + GRID_SIZE) % GRID_SIZE
            neighbors += grid[row, col]
    neighbors -= grid[i, j]
    return neighbors

def update_grid(grid):
    """Update the grid according to the rules of the game."""
    new_grid = np.copy(grid)
    for i in range(GRID_SIZE):
        for j in range(GRID_SIZE):
            live_neighbors = count_neighbors(grid, i, j)
            if grid[i, j] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                new_grid[i, j] = 0
            elif grid[i, j] == 0 and live_neighbors == 3:
                new_grid[i, j] = 1
    return new_grid

# Simulate the game
def simulate_game():
    global grid
    while True:
        # Update the grid
        grid = update_grid(grid)
        
        # Plot the grid
        plt.cla()
        plt.imshow(grid, cmap='binary')
        plt.draw()
        plt.pause(0.1)

# Start the simulation
simulate_game()
```

## Generated Output
```
Execution timed out after 5 seconds.
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
