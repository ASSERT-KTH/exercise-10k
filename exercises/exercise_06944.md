## Exercise
Create a function that uses lazy evaluation to delay its execution

## Reference Solution
```python
def lazy_evaluate(func):
    """
    Decorator to delay the execution of a function until its result is actually needed.
    
    Args:
        func: The function to be delayed.
    
    Returns:
        A function that, when called, returns the result of the original function.
    """
    class Lazy:
        def __init__(self, func):
            self.func = func
            self.evaluated = False
            self.result = None

        def __call__(self):
            if not self.evaluated:
                self.result = self.func()
                self.evaluated = True
            return self.result

    return Lazy(func)


# Example usage:
@lazy_evaluate
def expensive_computation():
    """
    Simulates an expensive computation.
    
    Returns:
        The result of the computation.
    """
    import time
    time.sleep(2)  # Simulate an expensive operation
    return "Computation result"


# Create an instance of the lazy function
lazy_func = expensive_computation

# At this point, the computation has not been performed
print("Lazy function created")

# The computation is performed only when we call the lazy function
result = lazy_func()
print("Result:", result)

# Subsequent calls to the lazy function return the cached result without re-evaluating
result = lazy_func()
print("Result (cached):", result)
```

## Generated Output
```
Lazy function created
Result: Computation result
Result (cached): Computation result
```

generated by python 3.10.13

solution generated by RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic
