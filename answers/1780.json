{
  "prompt": "Write a function to find the strongly connected components of a given graph.",
  "answer": "**Strongly Connected Components**\n=====================================\n\nA strongly connected component (SCC) of a graph is a subgraph that is strongly connected, i.e., there is a path from every vertex to every other vertex in the subgraph.\n\n**Algorithm**\n-------------\n\nWe will use Kosaraju's algorithm to find the strongly connected components of a given graph. This algorithm works by performing a depth-first search (DFS) on the graph, and then reversing the graph and performing another DFS.\n\n**Implementation**\n-----------------\n\nHere is a Python implementation of Kosaraju's algorithm:\n```python\nfrom collections import defaultdict\n\ndef kosaraju(graph):\n    \"\"\"\n    Find the strongly connected components of a given graph.\n\n    Args:\n    graph (dict): The input graph, represented as an adjacency list.\n\n    Returns:\n    list: A list of strongly connected components, where each component is a list of vertices.\n    \"\"\"\n    # Step 1: Get the transpose of the graph\n    transpose_graph = transpose(graph)\n\n    # Step 2: Perform a DFS on the original graph to get the finishing times\n    visited = set()\n    finishing_times = []\n    for vertex in graph:\n        if vertex not in visited:\n            dfs(graph, vertex, visited, finishing_times)\n\n    # Step 3: Perform a DFS on the transpose graph in the order of the finishing times\n    visited = set()\n    sccs = []\n    for vertex in reversed(finishing_times):\n        if vertex not in visited:\n            component = []\n            dfs_util(transpose_graph, vertex, visited, component)\n            sccs.append(component)\n\n    return sccs\n\n\ndef transpose(graph):\n    \"\"\"\n    Get the transpose of a given graph.\n\n    Args:\n    graph (dict): The input graph, represented as an adjacency list.\n\n    Returns:\n    dict: The transpose of the input graph.\n    \"\"\"\n    transpose_graph = defaultdict(list)\n    for vertex in graph:\n        for neighbor in graph[vertex]:\n            transpose_graph[neighbor].append(vertex)\n    return transpose_graph\n\n\ndef dfs(graph, vertex, visited, finishing_times):\n    \"\"\"\n    Perform a DFS on a given graph starting from a given vertex.\n\n    Args:\n    graph (dict): The input graph, represented as an adjacency list.\n    vertex: The starting vertex.\n    visited (set): A set of visited vertices.\n    finishing_times (list): A list to store the finishing times of the vertices.\n    \"\"\"\n    visited.add(vertex)\n    for neighbor in graph[vertex]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited, finishing_times)\n    finishing_times.append(vertex)\n\n\ndef dfs_util(graph, vertex, visited, component):\n    \"\"\"\n    Perform a DFS on a given graph starting from a given vertex and add the visited vertices to a component.\n\n    Args:\n    graph (dict): The input graph, represented as an adjacency list.\n    vertex: The starting vertex.\n    visited (set): A set of visited vertices.\n    component (list): A list to store the vertices of a strongly connected component.\n    \"\"\"\n    visited.add(vertex)\n    component.append(vertex)\n    for neighbor in graph[vertex]:\n        if neighbor not in visited:\n            dfs_util(graph, neighbor, visited, component)\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = {\n        'A': ['B'],\n        'B': ['C', 'D'],\n        'C': ['A', 'D'],\n        'D': ['E'],\n        'E': []\n    }\n    sccs = kosaraju(graph)\n    print(\"Strongly connected components:\")\n    for i, component in enumerate(sccs):\n        print(f\"Component {i+1}: {component}\")\n```\n**Explanation**\n---------------\n\n1.  The `kosaraju` function takes a graph as input and returns a list of strongly connected components.\n2.  The `transpose` function computes the transpose of a given graph.\n3.  The `dfs` function performs a DFS on a given graph starting from a given vertex and stores the finishing times of the vertices.\n4.  The `dfs_util` function performs a DFS on a given graph starting from a given vertex and adds the visited vertices to a component.\n5.  The example usage demonstrates how to use the `kosaraju` function to find the strongly connected components of a given graph.\n\n**Time Complexity**\n------------------\n\nThe time complexity of Kosaraju's algorithm is O(V + E), where V is the number of vertices and E is the number of edges in the graph.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of Kosaraju's algorithm is O(V), where V is the number of vertices in the graph.",
  "timestamp": "2026-02-10T20:09:09.922100",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}