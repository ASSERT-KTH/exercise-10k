{
  "prompt": "Write a program to search for a pattern in a text using the Rabin-Karp algorithm.",
  "answer": "**Rabin-Karp Algorithm Implementation**\n=====================================\n\nThe Rabin-Karp algorithm is a string searching algorithm that uses hashing to find a pattern in a text. It is an efficient algorithm with an average time complexity of O(n + m), where n is the length of the text and m is the length of the pattern.\n\n### Code Implementation\n\n```python\ndef rabin_karp(text, pattern):\n    \"\"\"\n    Search for a pattern in a text using the Rabin-Karp algorithm.\n\n    Args:\n        text (str): The text to search in.\n        pattern (str): The pattern to search for.\n\n    Returns:\n        list: A list of indices where the pattern is found.\n    \"\"\"\n    # Calculate the length of the text and pattern\n    n = len(text)\n    m = len(pattern)\n\n    # Calculate the hash value of the pattern\n    pattern_hash = 0\n    for char in pattern:\n        pattern_hash += ord(char)\n\n    # Calculate the hash value of the first window of the text\n    text_hash = 0\n    for i in range(m):\n        text_hash += ord(text[i])\n\n    # Initialize a list to store the indices of the pattern\n    indices = []\n\n    # Slide the window over the text\n    for i in range(n - m + 1):\n        # Check if the hash values match\n        if text_hash == pattern_hash:\n            # Check if the strings match\n            match = True\n            for j in range(m):\n                if text[i + j] != pattern[j]:\n                    match = False\n                    break\n            if match:\n                indices.append(i)\n\n        # Update the hash value of the next window\n        if i < n - m:\n            text_hash -= ord(text[i])\n            text_hash += ord(text[i + m])\n\n    return indices\n\n# Example usage\ntext = \"abxabcabcaby\"\npattern = \"abc\"\nindices = rabin_karp(text, pattern)\nprint(f\"Pattern '{pattern}' found at indices: {indices}\")\n```\n\n### Explanation\n\n1.  **Hash Calculation**: The algorithm starts by calculating the hash value of the pattern and the first window of the text. The hash value is calculated by summing the ASCII values of the characters.\n2.  **Window Sliding**: The algorithm then slides a window of the same length as the pattern over the text, calculating the hash value of each window.\n3.  **Hash Comparison**: If the hash value of a window matches the hash value of the pattern, the algorithm checks if the strings match by comparing the characters.\n4.  **Index Storage**: If the strings match, the algorithm stores the index of the match in a list.\n5.  **Hash Update**: The algorithm updates the hash value of the next window by subtracting the ASCII value of the first character of the previous window and adding the ASCII value of the next character.\n\n### Time Complexity\n\n*   **Best Case**: O(n + m), where n is the length of the text and m is the length of the pattern.\n*   **Average Case**: O(n + m), assuming a good hash function.\n*   **Worst Case**: O(n \\* m), if the hash function is poor and all windows have the same hash value.\n\n### Space Complexity\n\n*   **O(n)**, where n is the length of the text, for storing the indices of the pattern.",
  "timestamp": "2026-02-11T01:07:19.335824",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}