{
  "prompt": "Create a function that returns another function with a closed-over variable",
  "answer": "### Closed-Over Variable Function Example\n#### Overview\nThe following code example demonstrates a function that returns another function with a closed-over variable. In this case, we'll create a simple counter function.\n\n#### Code\n```python\ndef create_counter(initial_value=0):\n    \"\"\"\n    Returns a counter function with a closed-over variable.\n\n    Args:\n        initial_value (int): The initial value of the counter. Defaults to 0.\n\n    Returns:\n        function: A counter function that increments and returns the current count.\n    \"\"\"\n    count = initial_value\n\n    def counter():\n        nonlocal count\n        count += 1\n        return count\n\n    return counter\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create two separate counters\n    counter1 = create_counter()\n    counter2 = create_counter(10)\n\n    # Use the counters\n    print(counter1())  # Output: 1\n    print(counter1())  # Output: 2\n    print(counter2())  # Output: 11\n    print(counter2())  # Output: 12\n```\n\n#### Explanation\nIn the above code:\n\n1. We define a function `create_counter` that takes an optional `initial_value` parameter.\n2. Inside `create_counter`, we define a nested function `counter`.\n3. The `counter` function has access to the `count` variable from the outer scope, which is an example of a closed-over variable.\n4. When `counter` is called, it increments the `count` variable and returns the new value.\n5. We use the `nonlocal` keyword to indicate that `count` is not local to the `counter` function, but is instead from the outer scope.\n6. In the example usage, we create two separate counters and demonstrate that each has its own closed-over variable.",
  "timestamp": "2026-02-11T19:46:41.185377",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}