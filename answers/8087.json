{
  "prompt": "Write a function that uses memoization to cache the results of expensive function calls",
  "answer": "**Memoization Function in Python**\n=====================================\n\nHere's an example of a memoization function in Python that caches the results of expensive function calls.\n\n### Code\n\n```python\nfrom functools import wraps\n\ndef memoize(func):\n    \"\"\"\n    Memoization decorator to cache the results of expensive function calls.\n    \n    Args:\n        func: The function to be memoized.\n    \n    Returns:\n        A memoized version of the function.\n    \"\"\"\n    cache = dict()\n\n    @wraps(func)\n    def memoized_func(*args):\n        if args in cache:\n            return cache[args]\n        else:\n            result = func(*args)\n            cache[args] = result\n            return result\n\n    return memoized_func\n\n# Example usage:\n@memoize\ndef expensive_function(x):\n    \"\"\"\n    An example of an expensive function that takes a long time to compute.\n    \n    Args:\n        x: The input to the function.\n    \n    Returns:\n        The result of the function.\n    \"\"\"\n    import time\n    time.sleep(2)  # Simulate an expensive computation\n    return x * x\n\n# Test the memoized function\nprint(expensive_function(10))  # This will take 2 seconds to compute\nprint(expensive_function(10))  # This will return the cached result immediately\nprint(expensive_function(20))  # This will take 2 seconds to compute\nprint(expensive_function(20))  # This will return the cached result immediately\n```\n\n### Explanation\n\n1. The `memoize` function is a decorator that takes a function `func` as an argument and returns a memoized version of the function.\n2. The `memoized_func` function checks if the input `args` are already in the cache. If they are, it returns the cached result.\n3. If the input `args` are not in the cache, it calls the original function `func` with the input `args`, stores the result in the cache, and returns the result.\n4. The `expensive_function` is an example of a function that takes a long time to compute. It is decorated with the `memoize` function to cache its results.\n5. When the `expensive_function` is called with the same input multiple times, the memoized version returns the cached result immediately, avoiding the expensive computation.\n\n### Advice\n\n* Use memoization when you have a function that takes a long time to compute and is called multiple times with the same input.\n* Memoization can significantly improve the performance of your code by avoiding redundant computations.\n* Be careful not to use memoization with functions that have side effects or depend on external state, as it can lead to unexpected behavior.",
  "timestamp": "2026-02-11T23:25:06.704944",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}