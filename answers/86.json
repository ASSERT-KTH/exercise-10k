{
  "prompt": "Implement the merge sort algorithm to sort a list of integers",
  "answer": "**Merge Sort Algorithm Implementation**\n=====================================\n\n### Overview\n\nMerge sort is a divide-and-conquer algorithm that splits a list of integers into two halves, recursively sorts each half, and then merges the sorted halves.\n\n### Code Implementation\n\n```python\ndef merge_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the merge sort algorithm.\n\n    Args:\n        arr (list): The list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers.\n    \"\"\"\n    # Base case: If the list has one or zero elements, it is already sorted.\n    if len(arr) <= 1:\n        return arr\n\n    # Split the list into two halves.\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Recursively sort each half.\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    # Merge the sorted halves.\n    return merge(left_half, right_half)\n\n\ndef merge(left, right):\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    Args:\n        left (list): The first sorted list.\n        right (list): The second sorted list.\n\n    Returns:\n        list: The merged sorted list.\n    \"\"\"\n    merged = []\n    left_index = 0\n    right_index = 0\n\n    # Merge smaller elements first.\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    # Append any remaining elements.\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    arr = [64, 34, 25, 12, 22, 11, 90]\n    print(\"Original array:\", arr)\n    sorted_arr = merge_sort(arr)\n    print(\"Sorted array:\", sorted_arr)\n```\n\n### Explanation\n\n1.  The `merge_sort` function takes a list of integers as input and returns the sorted list.\n2.  The base case for the recursion is when the list has one or zero elements, in which case it is already sorted.\n3.  The list is split into two halves using the `mid` index.\n4.  Each half is recursively sorted by calling the `merge_sort` function.\n5.  The sorted halves are merged using the `merge` function.\n6.  The `merge` function takes two sorted lists as input and returns a single sorted list.\n7.  The `merge` function uses indices to track the current position in each list and appends the smaller element to the `merged` list.\n8.  Any remaining elements are appended to the `merged` list.\n\n### Time Complexity\n\nThe time complexity of the merge sort algorithm is O(n log n), where n is the number of elements in the list. This is because the algorithm divides the list in half at each recursive step, resulting in a logarithmic number of steps. The merge operation takes linear time, resulting in a total time complexity of O(n log n).\n\n### Space Complexity\n\nThe space complexity of the merge sort algorithm is O(n), where n is the number of elements in the list. This is because the algorithm creates temporary lists to store the sorted halves, which requires additional memory.",
  "timestamp": "2026-02-10T13:16:37.407284",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}