{
  "prompt": "Write a program that takes a graph as input and returns the number of connected components.",
  "answer": "Here's a Python solution using Depth-First Search (DFS) to count connected components in an undirected graph.\n\n```python\nfrom typing import Dict, List\n\ndef count_connected_components(graph: Dict[int, List[int]]) -> int:\n    \"\"\"\n    Counts the number of connected components in an undirected graph.\n\n    Args:\n    graph: A dictionary representing the adjacency list of the graph.\n           Each key is a node, and its corresponding value is a list of its neighbors.\n\n    Returns:\n    The number of connected components in the graph.\n    \"\"\"\n\n    # Initialize a set to keep track of visited nodes\n    visited = set()\n\n    # Initialize a variable to count the number of connected components\n    count = 0\n\n    # Iterate over each node in the graph\n    for node in graph:\n        # If the node has not been visited yet, it's a new connected component\n        if node not in visited:\n            # Increment the count of connected components\n            count += 1\n\n            # Perform a DFS from the current node to mark all nodes in the same component as visited\n            dfs(graph, node, visited)\n\n    # Return the total count of connected components\n    return count\n\n\ndef dfs(graph: Dict[int, List[int]], node: int, visited: set) -> None:\n    \"\"\"\n    Performs a Depth-First Search (DFS) from a given node in the graph.\n\n    Args:\n    graph: A dictionary representing the adjacency list of the graph.\n           Each key is a node, and its corresponding value is a list of its neighbors.\n    node: The current node being visited.\n    visited: A set of nodes that have already been visited.\n    \"\"\"\n\n    # Mark the current node as visited\n    visited.add(node)\n\n    # Iterate over each neighbor of the current node\n    for neighbor in graph[node]:\n        # If the neighbor has not been visited yet, recursively visit it\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n\n\n# Example usage:\ngraph = {\n    0: [1, 2],\n    1: [0, 2],\n    2: [0, 1],\n    3: [4],\n    4: [3],\n    5: []\n}\n\nconnected_components = count_connected_components(graph)\nprint(f\"Number of connected components: {connected_components}\")\n```\n\n### Explanation:\n\n*   The provided Python code defines two functions: `count_connected_components` and `dfs`.\n*   The `count_connected_components` function takes an undirected graph represented as an adjacency list and returns the number of connected components in the graph.\n*   It uses a set `visited` to keep track of visited nodes and a variable `count` to count the number of connected components.\n*   The function iterates over each node in the graph. If a node has not been visited, it increments the count and performs a DFS from that node using the `dfs` function to mark all nodes in the same connected component as visited.\n*   The `dfs` function is a recursive helper function that performs a Depth-First Search from a given node, marking it as visited and recursively visiting its unvisited neighbors.\n*   The example usage demonstrates how to create a graph with multiple connected components and count them using the `count_connected_components` function.\n\n### Time Complexity:\n\n*   The time complexity of the `count_connected_components` function is O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. This is because each node and edge is visited once during the DFS traversal.\n*   The space complexity is also O(V + E) due to the storage of the graph and the visited set. However, in the worst case, the space complexity can be O(V) if the graph is very sparse (i.e., has very few edges).",
  "timestamp": "2026-02-10T21:34:02.981053",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}