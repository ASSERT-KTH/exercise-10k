{
  "prompt": "Write a program to find the longest increasing subsequence of a given list of numbers.",
  "answer": "**Longest Increasing Subsequence Program**\n===========================================\n\nThis program uses dynamic programming to find the longest increasing subsequence (LIS) of a given list of numbers.\n\n**Code**\n--------\n\n```python\ndef longest_increasing_subsequence(sequence):\n    \"\"\"\n    Find the longest increasing subsequence of a given list of numbers.\n\n    Args:\n        sequence (list): A list of integers.\n\n    Returns:\n        list: The longest increasing subsequence.\n    \"\"\"\n    if not sequence:\n        return []\n\n    # Initialize a list to store the length of the LIS ending at each position\n    lengths = [1] * len(sequence)\n\n    # Initialize a list to store the previous element in the LIS ending at each position\n    previous = [None] * len(sequence)\n\n    # Compute the length of the LIS ending at each position\n    for i in range(1, len(sequence)):\n        for j in range(i):\n            if sequence[i] > sequence[j] and lengths[i] < lengths[j] + 1:\n                lengths[i] = lengths[j] + 1\n                previous[i] = j\n\n    # Find the position of the end of the LIS\n    max_length_idx = max(range(len(lengths)), key=lambda x: lengths[x])\n\n    # Reconstruct the LIS\n    lis = []\n    while max_length_idx is not None:\n        lis.append(sequence[max_length_idx])\n        max_length_idx = previous[max_length_idx]\n\n    # Return the LIS in the correct order\n    return lis[::-1]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    sequence = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n    print(\"Longest increasing subsequence:\", longest_increasing_subsequence(sequence))\n```\n\n**Explanation**\n--------------\n\nThe program uses a dynamic programming approach to find the longest increasing subsequence.\n\n1.  Initialize two lists: `lengths` to store the length of the LIS ending at each position, and `previous` to store the previous element in the LIS ending at each position.\n2.  Iterate over the sequence to compute the length of the LIS ending at each position.\n3.  For each position, check all previous positions to see if the current element is greater than the previous element and if the length of the LIS ending at the current position is less than the length of the LIS ending at the previous position plus one. If both conditions are true, update the length and previous element.\n4.  Find the position of the end of the LIS by finding the maximum length in the `lengths` list.\n5.  Reconstruct the LIS by tracing back the previous elements from the end of the LIS to the beginning.\n6.  Return the LIS in the correct order by reversing the reconstructed list.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this program is O(n^2), where n is the length of the input sequence.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of this program is O(n), where n is the length of the input sequence.",
  "timestamp": "2026-02-12T02:09:50.172716",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}