{
  "prompt": "Write a function that uses memoization to cache the results of expensive function calls.",
  "answer": "**Memoization Function**\n========================\n\nBelow is an example implementation of a memoization function in Python:\n\n```python\nfrom functools import wraps\n\ndef memoize(func):\n    \"\"\"\n    Memoization decorator to cache the results of expensive function calls.\n\n    Args:\n    func: The function to be memoized.\n\n    Returns:\n    A wrapper function that caches the results of the input function.\n    \"\"\"\n    cache = dict()\n\n    @wraps(func)\n    def memoized_func(*args):\n        if args in cache:\n            return cache[args]\n        else:\n            result = func(*args)\n            cache[args] = result\n            return result\n\n    return memoized_func\n\n# Example usage:\n@memoize\ndef expensive_function(x):\n    \"\"\"\n    An example of an expensive function that calculates the factorial of a number.\n\n    Args:\n    x (int): The input number.\n\n    Returns:\n    int: The factorial of the input number.\n    \"\"\"\n    if x == 0:\n        return 1\n    else:\n        return x * expensive_function(x - 1)\n\n# Test the memoized function:\nprint(expensive_function(5))  # Calculates and caches the result\nprint(expensive_function(5))  # Returns the cached result\n```\n\n**How it Works**\n---------------\n\n1.  The `memoize` function is a decorator that takes a function `func` as an argument.\n2.  It creates a dictionary `cache` to store the results of the function calls.\n3.  The `memoized_func` is a wrapper function that checks if the result for the given arguments is already in the cache.\n4.  If the result is cached, it returns the cached value. Otherwise, it calculates the result using the original function, stores it in the cache, and returns the result.\n5.  The `@wraps(func)` decorator is used to preserve the metadata of the original function.\n\n**Benefits**\n------------\n\n*   **Improved Performance**: Memoization avoids redundant calculations by caching the results of expensive function calls, leading to significant performance improvements.\n*   **Reduced Computational Overhead**: By reusing cached results, memoization reduces the computational overhead associated with repeated function calls.\n\n**Use Cases**\n-------------\n\n*   **Recursive Functions**: Memoization is particularly useful for recursive functions, where the same sub-problems are solved multiple times. Caching the results of these sub-problems can greatly improve performance.\n*   **Expensive Database Queries**: Memoization can be applied to cache the results of expensive database queries, reducing the number of queries and improving overall system performance.",
  "timestamp": "2026-02-12T09:35:03.032636",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}