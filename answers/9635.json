{
  "prompt": "Write a function that uses a generator to produce a sequence of values on-the-fly.",
  "answer": "**Generator Function Example**\n================================\n\nHere's an example of a generator function in Python that produces a sequence of Fibonacci numbers on-the-fly:\n\n```python\ndef fibonacci(n):\n    \"\"\"\n    Generator function to produce the first n Fibonacci numbers.\n\n    Args:\n        n (int): The number of Fibonacci numbers to generate.\n\n    Yields:\n        int: The next Fibonacci number in the sequence.\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n\n# Example usage:\nif __name__ == \"__main__\":\n    n = 10  # number of Fibonacci numbers to generate\n    print(f\"First {n} Fibonacci numbers:\")\n    for i, fib_num in enumerate(fibonacci(n)):\n        print(f\"F({i}) = {fib_num}\")\n```\n\n**How it Works**\n----------------\n\n1. The `fibonacci` function takes an integer `n` as input, representing the number of Fibonacci numbers to generate.\n2. The function uses a generator to produce the Fibonacci sequence on-the-fly.\n3. Inside the function, we initialize two variables `a` and `b` to 0 and 1, respectively, which represent the first two Fibonacci numbers.\n4. The function uses a `for` loop to iterate `n` times.\n5. In each iteration, the `yield` statement produces the current value of `a` as the next Fibonacci number in the sequence.\n6. The values of `a` and `b` are updated to `b` and `a + b`, respectively, to calculate the next Fibonacci number.\n7. The example usage demonstrates how to call the `fibonacci` function with a desired value of `n` and print the resulting sequence of Fibonacci numbers.\n\n**Benefits of Generators**\n-------------------------\n\nUsing a generator to produce a sequence of values on-the-fly offers several benefits, including:\n\n*   **Memory efficiency**: Generators only store the current state of the sequence, rather than the entire sequence, which can be memory-intensive for large datasets.\n*   **Lazy evaluation**: Generators only compute the next value in the sequence when requested, which can improve performance by avoiding unnecessary computations.\n*   **Flexibility**: Generators can be used to create complex sequences and can be easily composed to create more complex sequences.",
  "timestamp": "2026-02-12T09:35:39.695267",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}