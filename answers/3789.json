{
  "prompt": "Create a function to find the maximum flow in a flow network from a source node to a sink node.",
  "answer": "**Maximum Flow in a Flow Network**\n\nThe maximum flow problem is a classic problem in graph theory and computer science. Here, we will implement the Ford-Fulkerson algorithm with the Edmonds-Karp implementation to find the maximum flow in a flow network.\n\n### Code\n\n```python\nfrom collections import deque\n\ndef bfs(graph, source, sink, parent):\n    \"\"\"\n    Breadth-first search to check if there is a path from source to sink.\n\n    Args:\n    graph (list): The residual graph.\n    source (int): The source node.\n    sink (int): The sink node.\n    parent (list): The parent array to store the augmenting path.\n\n    Returns:\n    bool: True if there is a path from source to sink, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    queue = deque()\n    queue.append(source)\n    visited[source] = True\n\n    while queue:\n        u = queue.popleft()\n        for ind, val in enumerate(graph[u]):\n            if visited[ind] == False and val > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parent[ind] = u\n\n                if ind == sink:\n                    return True\n\n    return False\n\n\ndef ford_fulkerson(graph, source, sink):\n    \"\"\"\n    Ford-Fulkerson algorithm to find the maximum flow in a flow network.\n\n    Args:\n    graph (list): The flow network.\n    source (int): The source node.\n    sink (int): The sink node.\n\n    Returns:\n    int: The maximum flow in the flow network.\n    \"\"\"\n    parent = [-1] * len(graph)\n    max_flow = 0\n\n    while bfs(graph, source, sink, parent):\n        path_flow = float(\"Inf\")\n        s = sink\n        while s != source:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n\n        max_flow += path_flow\n\n        v = sink\n        while v != source:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n\n    return max_flow\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = [[0, 16, 13, 0, 0, 0],\n             [0, 0, 10, 12, 0, 0],\n             [0, 4, 0, 0, 14, 0],\n             [0, 0, 9, 0, 0, 20],\n             [0, 0, 0, 7, 0, 4],\n             [0, 0, 0, 0, 0, 0]]\n\n    source = 0\n    sink = 5\n\n    max_flow = ford_fulkerson(graph, source, sink)\n    print(\"Maximum flow:\", max_flow)\n\n```\n\n### Explanation\n\n*   We start by defining a `bfs` function that performs a breadth-first search on the residual graph to check if there is a path from the source to the sink.\n*   The `ford_fulkerson` function implements the Ford-Fulkerson algorithm. It initializes the parent array and the maximum flow.\n*   The algorithm repeatedly finds augmenting paths from the source to the sink using the `bfs` function and augments the flow along these paths until no more augmenting paths can be found.\n*   The maximum flow is calculated by summing up the path flows along the augmenting paths.\n\n### Time Complexity\n\n*   The time complexity of the Ford-Fulkerson algorithm with the Edmonds-Karp implementation is O(VE^2), where V is the number of vertices and E is the number of edges.\n\n### Space Complexity\n\n*   The space complexity of the algorithm is O(V), where V is the number of vertices.",
  "timestamp": "2026-02-11T08:26:33.221076",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}