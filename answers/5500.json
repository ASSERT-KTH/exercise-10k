{
  "prompt": "Write a program to check the strongly connected components in a directed graph.",
  "answer": "**Strongly Connected Components in a Directed Graph**\n======================================================\n\nIn this program, we will use Kosaraju's algorithm to find the strongly connected components in a directed graph. This algorithm works by first performing a depth-first search on the graph to find the finish times of each vertex, then reversing the graph and performing another depth-first search in the order of the finish times.\n\n**Code**\n--------\n\n```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def dfs(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.dfs(i, visited, stack)\n        stack = stack.append(v)\n\n    def fill_order(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.fill_order(i, visited, stack)\n        stack.append(v)\n\n    def transpose(self):\n        g = Graph(self.V)\n        for i in self.graph:\n            for j in self.graph[i]:\n                g.add_edge(j, i)\n        return g\n\n    def dfs_util(self, v, visited, scc):\n        visited[v] = True\n        scc.append(v)\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.dfs_util(i, visited, scc)\n\n    def print_scc(self):\n        stack = []\n        visited = [False] * (self.V)\n        for i in range(self.V):\n            if visited[i] == False:\n                self.fill_order(i, visited, stack)\n\n        gr = self.transpose()\n\n        visited = [False] * (self.V)\n        while stack:\n            i = stack.pop()\n            if visited[i] == False:\n                scc = []\n                gr.dfs_util(i, visited, scc)\n                print(scc)\n\n# Example usage\ng1 = Graph(5)\ng1.add_edge(1, 0)\ng1.add_edge(0, 2)\ng1.add_edge(2, 1)\ng1.add_edge(0, 3)\ng1.add_edge(3, 4)\nprint(\"SSC of the given graph are:\")\ng1.print_scc()\n```\n\n**Explanation**\n---------------\n\n1.  We start by defining a `Graph` class to represent the directed graph.\n2.  The `add_edge` method is used to add edges to the graph.\n3.  The `dfs` method is used to perform a depth-first search on the graph.\n4.  The `fill_order` method is used to fill the stack with the vertices in the order of their finish times.\n5.  The `transpose` method is used to get the transpose of the graph.\n6.  The `dfs_util` method is used to perform a depth-first search on the transposed graph.\n7.  The `print_scc` method is used to print the strongly connected components of the graph.\n8.  In the `print_scc` method, we first fill the stack with the vertices in the order of their finish times, then we get the transpose of the graph and perform a depth-first search on the transposed graph in the order of the finish times.\n\n**Time Complexity**\n-------------------\n\nThe time complexity of this algorithm is O(V + E), where V is the number of vertices and E is the number of edges in the graph.\n\n**Space Complexity**\n--------------------\n\nThe space complexity of this algorithm is O(V), as we need to store the vertices in the stack.",
  "timestamp": "2026-02-11T15:20:48.673710",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}