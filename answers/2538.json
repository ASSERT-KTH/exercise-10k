{
  "prompt": "Write a program to select the maximum number of activities that can be performed by a single person",
  "answer": "**Activity Selection Problem**\n================================\n\nThe activity selection problem is a classic problem in computer science and operations research. It involves selecting the maximum number of activities that can be performed by a single person, given a set of activities with start and end times.\n\n**Solution**\n------------\n\nHere is a Python solution using a greedy algorithm:\n\n```python\ndef activity_selection(activities):\n    \"\"\"\n    Select the maximum number of activities that can be performed by a single person.\n\n    Args:\n    activities (list): A list of tuples, where each tuple contains the start and end time of an activity.\n\n    Returns:\n    list: A list of tuples, where each tuple contains the start and end time of a selected activity.\n    \"\"\"\n    # Sort the activities by their end times\n    activities.sort(key=lambda x: x[1])\n\n    # Initialize the result with the first activity\n    result = [activities[0]]\n\n    # Iterate over the remaining activities\n    for start, end in activities[1:]:\n        # If the current activity starts after the last selected activity ends, add it to the result\n        if start >= result[-1][1]:\n            result.append((start, end))\n\n    return result\n\n# Example usage\nactivities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11), (8, 12), (2, 13), (12, 14)]\nselected_activities = activity_selection(activities)\n\nprint(\"Selected Activities:\")\nfor start, end in selected_activities:\n    print(f\"Start: {start}, End: {end}\")\n```\n\n**Explanation**\n--------------\n\n1.  **Sort the activities**: Sort the activities by their end times. This is because we want to select the activities that end earliest, so that we can accommodate more activities.\n2.  **Initialize the result**: Initialize the result with the first activity. This is because the first activity is guaranteed to be selected, since it ends earliest.\n3.  **Iterate over the remaining activities**: Iterate over the remaining activities, and for each activity, check if it starts after the last selected activity ends. If it does, add it to the result.\n4.  **Return the result**: Return the list of selected activities.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this solution is O(n log n), where n is the number of activities. This is because we sort the activities by their end times, which takes O(n log n) time. The subsequent iteration over the activities takes O(n) time, but this is dominated by the sorting step.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of this solution is O(n), where n is the number of activities. This is because we store the selected activities in a list, which can contain up to n activities in the worst case.",
  "timestamp": "2026-02-10T23:22:48.109034",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}