{
  "prompt": "Write a program that finds the longest common subsequence of two input strings. The longest common subsequence is the longest sequence of characters that appears in the same order in both strings, but it may not be contiguous. For example, the longest common subsequence of 'abcdef' and 'zbcdfg' is 'bcdf'.",
  "answer": "**Longest Common Subsequence Program**\n======================================\n\n### Overview\n\nThis program uses dynamic programming to find the longest common subsequence (LCS) of two input strings.\n\n### Code\n\n```python\ndef longest_common_subsequence(str1, str2):\n    \"\"\"\n    Find the longest common subsequence of two input strings.\n\n    Args:\n        str1 (str): The first input string.\n        str2 (str): The second input string.\n\n    Returns:\n        str: The longest common subsequence of str1 and str2.\n    \"\"\"\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Build the dynamic programming table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Reconstruct the LCS from the dynamic programming table\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            lcs.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # Return the LCS in the correct order\n    return \"\".join(reversed(lcs))\n\n# Example usage:\nstr1 = \"abcdef\"\nstr2 = \"zbcdfg\"\nlcs = longest_common_subsequence(str1, str2)\nprint(f\"The longest common subsequence of '{str1}' and '{str2}' is '{lcs}'\")\n```\n\n### Explanation\n\n1.  Initialize a 2D array `dp` with dimensions `(m + 1) x (n + 1)`, where `m` and `n` are the lengths of the input strings `str1` and `str2`, respectively. The `dp` array is used to store the lengths of the LCS for subproblems.\n2.  Fill the `dp` array using dynamic programming. For each cell `dp[i][j]`, if the characters at positions `i - 1` and `j - 1` in `str1` and `str2` match, set `dp[i][j]` to `dp[i - 1][j - 1] + 1`. Otherwise, set `dp[i][j]` to the maximum of `dp[i - 1][j]` and `dp[i][j - 1]`.\n3.  Reconstruct the LCS from the `dp` array by starting at the bottom-right corner and moving diagonally up-left when the characters match, or moving up or left based on the maximum value in the adjacent cells.\n4.  Return the reconstructed LCS as a string.\n\n### Time Complexity\n\nThe time complexity of this program is O(m \\* n), where m and n are the lengths of the input strings. This is because we need to fill the `dp` array, which has m \\* n cells, and then reconstruct the LCS, which takes O(m + n) time in the worst case.\n\n### Space Complexity\n\nThe space complexity of this program is O(m \\* n), which is the size of the `dp` array. We also use a list to store the reconstructed LCS, which can have a maximum size of min(m, n) in the worst case. However, this is dominated by the space required for the `dp` array.",
  "timestamp": "2026-02-13T06:12:15.315233",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}