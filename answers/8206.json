{
  "prompt": "Write a program that implements ternary search using a while loop.",
  "answer": "Ternary Search Implementation\n==========================\n\nTernary search is a divide-and-conquer algorithm that can be used to find an element in an array. It works by dividing the array into three parts and recursively searching for the element in one of the parts.\n\n### Code\n\n```python\ndef ternary_search(arr, target):\n    \"\"\"\n    Ternary search function to find an element in a sorted array.\n\n    Args:\n    arr (list): A sorted list of integers.\n    target (int): The target element to search for.\n\n    Returns:\n    int: The index of the target element if found, -1 otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        # Calculate the two mid points\n        mid1 = left + (right - left) // 3\n        mid2 = right - (right - left) // 3\n\n        # Check if the target is at the first mid point\n        if arr[mid1] == target:\n            return mid1\n\n        # Check if the target is at the second mid point\n        if arr[mid2] == target:\n            return mid2\n\n        # If the target is less than the first mid point, update the right pointer\n        if target < arr[mid1]:\n            right = mid1 - 1\n\n        # If the target is greater than the second mid point, update the left pointer\n        elif target > arr[mid2]:\n            left = mid2 + 1\n\n        # If the target is between the two mid points, update the left and right pointers\n        else:\n            left = mid1 + 1\n            right = mid2 - 1\n\n    # If the target is not found, return -1\n    return -1\n\n\n# Example usage\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 5\n    index = ternary_search(arr, target)\n\n    if index != -1:\n        print(f\"Target {target} found at index {index}.\")\n    else:\n        print(f\"Target {target} not found in the array.\")\n```\n\n### Explanation\n\n1.  Initialize two pointers, `left` and `right`, to the start and end of the array, respectively.\n2.  Calculate two mid points, `mid1` and `mid2`, which divide the array into three parts.\n3.  Check if the target element is at either of the mid points. If it is, return the index.\n4.  If the target is less than the first mid point, update the `right` pointer to `mid1 - 1`.\n5.  If the target is greater than the second mid point, update the `left` pointer to `mid2 + 1`.\n6.  If the target is between the two mid points, update the `left` and `right` pointers to `mid1 + 1` and `mid2 - 1`, respectively.\n7.  Repeat steps 2-6 until the target is found or the `left` pointer exceeds the `right` pointer.\n8.  If the target is not found, return -1 to indicate that it is not in the array.\n\n### Time Complexity\n\nThe time complexity of ternary search is O(log3 n), where n is the number of elements in the array. This is because the algorithm divides the array into three parts at each step, reducing the search space by a factor of 3.\n\n### Space Complexity\n\nThe space complexity of ternary search is O(1), as it only uses a constant amount of space to store the pointers and mid points.",
  "timestamp": "2026-02-11T23:53:08.338423",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}