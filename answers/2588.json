{
  "prompt": "Write a program to find the longest substring without repeating characters in a given string.",
  "answer": "**Longest Substring Without Repeating Characters**\n======================================================\n\n### Problem Statement\n\nGiven a string, find the longest substring without repeating characters.\n\n### Solution\n\nWe can solve this problem using a sliding window approach with the help of a set data structure. The set will store unique characters in the current window.\n\n#### Code\n\n```python\ndef longest_substring_without_repeating_chars(s: str) -> str:\n    \"\"\"\n    Find the longest substring without repeating characters in a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The longest substring without repeating characters.\n    \"\"\"\n    if not s:\n        return \"\"\n\n    left = 0  # Left pointer of the window\n    max_length = 0  # Maximum length of substring without repeating characters\n    max_substring = \"\"  # Longest substring without repeating characters\n    char_set = set()  # Set to store unique characters in the current window\n\n    for right in range(len(s)):\n        # Move the right pointer to the right\n        while s[right] in char_set:\n            # If the character is already in the set, remove the leftmost character\n            char_set.remove(s[left])\n            left += 1\n\n        # Add the current character to the set\n        char_set.add(s[right])\n\n        # Update the maximum length and substring if necessary\n        if right - left + 1 > max_length:\n            max_length = right - left + 1\n            max_substring = s[left:right + 1]\n\n    return max_substring\n\n\ndef main():\n    # Example usage\n    s = \"abcabcbb\"\n    print(\"Input string:\", s)\n    print(\"Longest substring without repeating characters:\", longest_substring_without_repeating_chars(s))\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n### Explanation\n\n1.  Initialize two pointers, `left` and `right`, to represent the sliding window.\n2.  Use a set, `char_set`, to store unique characters in the current window.\n3.  Iterate over the string using the `right` pointer.\n4.  If the character at the `right` pointer is already in `char_set`, remove the leftmost character from the set and move the `left` pointer to the right.\n5.  Add the character at the `right` pointer to `char_set`.\n6.  Update the maximum length and substring if the current window size is greater than the maximum length found so far.\n7.  Return the longest substring without repeating characters.\n\n### Time Complexity\n\n*   The time complexity of this solution is O(n), where n is the length of the input string, because each character is visited at most twice (once by the `right` pointer and once by the `left` pointer).\n\n### Space Complexity\n\n*   The space complexity is O(min(n, m)), where m is the size of the character set, because in the worst case, the set will store all unique characters in the string. However, since the size of the character set is usually much smaller than the length of the string, the space complexity can be considered as O(1) in practice.",
  "timestamp": "2026-02-10T23:34:58.732479",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}