{
  "prompt": "Implement a stack that keeps track of the minimum element at all times",
  "answer": "**Min Stack Implementation**\n=====================================\n\nHere is an implementation of a stack that keeps track of the minimum element at all times. This implementation uses two stacks: one for the main elements and another for keeping track of the minimum elements.\n\n```python\nclass MinStack:\n    def __init__(self):\n        \"\"\"\n        Initialize the MinStack.\n        \"\"\"\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        \"\"\"\n        Push a value onto the stack.\n\n        :param val: The value to push.\n        \"\"\"\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        \"\"\"\n        Remove the top element from the stack.\n        \"\"\"\n        if self.stack:\n            if self.stack[-1] == self.min_stack[-1]:\n                self.min_stack.pop()\n            self.stack.pop()\n\n    def top(self) -> int:\n        \"\"\"\n        Get the top element of the stack.\n\n        :return: The top element.\n        \"\"\"\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -> int:\n        \"\"\"\n        Get the minimum element in the stack.\n\n        :return: The minimum element.\n        \"\"\"\n        return self.min_stack[-1] if self.min_stack else None\n\n\n# Example usage\nif __name__ == \"__main__\":\n    min_stack = MinStack()\n    min_stack.push(5)\n    min_stack.push(3)\n    min_stack.push(7)\n    min_stack.push(2)\n    print(min_stack.getMin())  # Output: 2\n    min_stack.pop()\n    print(min_stack.getMin())  # Output: 3\n    min_stack.pop()\n    print(min_stack.getMin())  # Output: 3\n    min_stack.pop()\n    print(min_stack.getMin())  # Output: 5\n    min_stack.pop()\n    print(min_stack.getMin())  # Output: None\n```\n\n**How It Works**\n----------------\n\n1.  We maintain two stacks: `stack` for the main elements and `min_stack` for keeping track of the minimum elements.\n2.  When pushing a value onto the stack, we check if the `min_stack` is empty or if the new value is less than or equal to the current minimum. If either condition is true, we push the new value onto the `min_stack`.\n3.  When popping an element from the stack, we check if the popped element is equal to the current minimum. If it is, we pop the minimum from the `min_stack` as well.\n4.  The `getMin` method simply returns the top element of the `min_stack`, which represents the current minimum value in the stack.\n\n**Time Complexity**\n------------------\n\n*   `push`: O(1)\n*   `pop`: O(1)\n*   `top`: O(1)\n*   `getMin`: O(1)\n\n**Space Complexity**\n--------------------\n\n*   O(n), where n is the number of elements in the stack. We use two stacks to keep track of the elements and the minimum values.",
  "timestamp": "2026-02-10T13:17:13.534558",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}