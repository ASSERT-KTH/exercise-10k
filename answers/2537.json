{
  "prompt": "Write a program to solve the 0/1 knapsack problem",
  "answer": "**0/1 Knapsack Problem Solution**\n=====================================\n\nThe 0/1 knapsack problem is a classic problem in computer science and operations research. Given a set of items, each with a weight and a value, determine the subset of items to include in a knapsack of limited capacity that maximizes the total value.\n\n**Code Solution (Python)**\n---------------------------\n\n```python\ndef knapsack(capacity, weights, values):\n    \"\"\"\n    Solves the 0/1 knapsack problem using dynamic programming.\n\n    Args:\n    - capacity (int): The maximum capacity of the knapsack.\n    - weights (list): A list of weights for each item.\n    - values (list): A list of values for each item.\n\n    Returns:\n    - max_value (int): The maximum value that can be achieved.\n    - items (list): A list of indices of the items to include in the knapsack.\n    \"\"\"\n    n = len(values)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i - 1] <= w:\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w])\n            else:\n                dp[i][w] = dp[i - 1][w]\n\n    max_value = dp[n][capacity]\n    items = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i - 1][w]:\n            items.append(i - 1)\n            w -= weights[i - 1]\n\n    return max_value, items[::-1]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    capacity = 50\n    weights = [10, 20, 30]\n    values = [60, 100, 120]\n\n    max_value, items = knapsack(capacity, weights, values)\n    print(f\"Maximum value: {max_value}\")\n    print(f\"Items to include: {items}\")\n```\n\n**Explanation**\n---------------\n\nThe provided code uses dynamic programming to solve the 0/1 knapsack problem. The `knapsack` function takes three arguments:\n\n*   `capacity`: The maximum capacity of the knapsack.\n*   `weights`: A list of weights for each item.\n*   `values`: A list of values for each item.\n\nThe function returns two values:\n\n*   `max_value`: The maximum value that can be achieved.\n*   `items`: A list of indices of the items to include in the knapsack.\n\nThe code first initializes a 2D table `dp` with dimensions `(n + 1) x (capacity + 1)`, where `n` is the number of items. The table is used to store the maximum value that can be achieved for each subproblem.\n\nThe code then fills the table using two nested loops. For each item `i` and each capacity `w`, it checks if the weight of the current item is less than or equal to the current capacity. If it is, it calculates the maximum value by considering two options:\n\n*   Include the current item: `values[i - 1] + dp[i - 1][w - weights[i - 1]]`\n*   Exclude the current item: `dp[i - 1][w]`\n\nIf the weight of the current item is greater than the current capacity, it simply copies the value from the previous row: `dp[i - 1][w]`.\n\nAfter filling the table, the code retrieves the maximum value that can be achieved and the items to include in the knapsack by tracing back the table.\n\n**Time Complexity**\n-------------------\n\nThe time complexity of the provided code is O(n \\* capacity), where n is the number of items and capacity is the maximum capacity of the knapsack.\n\n**Space Complexity**\n--------------------\n\nThe space complexity of the provided code is O(n \\* capacity), as it uses a 2D table of dimensions (n + 1) x (capacity + 1) to store the maximum values for each subproblem.",
  "timestamp": "2026-02-10T23:22:28.076329",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}