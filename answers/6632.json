{
  "prompt": "Create a function that uses memoization to cache its results",
  "answer": "**Memoization Function**\n========================\n\nMemoization is an optimization technique that stores the results of expensive function calls and returns the cached result when the same inputs occur again.\n\n### Python Implementation\n\n```python\nfrom functools import wraps\n\ndef memoize(func):\n    \"\"\"Memoization decorator to cache function results\"\"\"\n    cache = dict()\n    \n    @wraps(func)\n    def memoized_func(*args):\n        if args in cache:\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n    \n    return memoized_func\n\n@memoize\ndef fibonacci(n):\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Example usage:\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(f\"Fibonacci({i}) = {fibonacci(i)}\")\n```\n\n### Explanation\n\n*   We define a `memoize` decorator function that takes another function `func` as its argument.\n*   Inside the `memoize` function, we create a cache dictionary to store the results of `func` for different input arguments.\n*   We define a nested function `memoized_func` that checks if the input arguments are already in the cache. If they are, it returns the cached result. Otherwise, it calls the original function `func`, stores the result in the cache, and returns it.\n*   We use the `@wraps` decorator from the `functools` module to preserve the original function's metadata (name, docstring, etc.).\n*   We apply the `@memoize` decorator to the `fibonacci` function to enable memoization.\n*   In the example usage, we calculate and print the first 10 Fibonacci numbers using the memoized `fibonacci` function.\n\n### Benefits\n\n*   Memoization significantly improves the performance of the `fibonacci` function by avoiding redundant calculations.\n*   The cached results are stored in memory, allowing for fast lookup and retrieval.\n\n### Advice\n\n*   Use memoization for functions with expensive calculations and frequent repeated calls with the same inputs.\n*   Consider using a library like `joblib` or `cachetools` for more advanced caching and memoization features.",
  "timestamp": "2026-02-11T19:47:41.067091",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}