{
  "prompt": "Create a program to solve the 0/1 knapsack problem using dynamic programming.",
  "answer": "**0/1 Knapsack Problem Solution using Dynamic Programming**\n===========================================================\n\nThe 0/1 knapsack problem is a classic problem in combinatorial optimization. Given a set of items, each with a weight and a value, determine the subset of items to include in a knapsack of limited capacity to maximize the total value.\n\n**Code Solution (Python)**\n------------------------\n\n```python\ndef knapsack(weights, values, capacity):\n    \"\"\"\n    Solves the 0/1 knapsack problem using dynamic programming.\n\n    Args:\n        weights (list): List of item weights.\n        values (list): List of item values.\n        capacity (int): Knapsack capacity.\n\n    Returns:\n        int: Maximum value achievable within the capacity.\n        list: List of items to include in the knapsack.\n    \"\"\"\n    n = len(weights)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    # Fill the dp table\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i - 1] <= w:\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w])\n            else:\n                dp[i][w] = dp[i - 1][w]\n\n    # Reconstruct the solution\n    max_value = dp[n][capacity]\n    included_items = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i - 1][w]:\n            included_items.append(i - 1)\n            w -= weights[i - 1]\n\n    return max_value, included_items[::-1]\n\n\n# Example usage\nweights = [2, 3, 1, 4]\nvalues = [10, 5, 8, 15]\ncapacity = 7\n\nmax_value, included_items = knapsack(weights, values, capacity)\nprint(f\"Maximum value: {max_value}\")\nprint(f\"Included items: {included_items}\")\n```\n\n**Explanation**\n---------------\n\nThe provided code solves the 0/1 knapsack problem using dynamic programming. It initializes a 2D table `dp` to store the maximum value achievable for each subproblem. The table is filled iteratively, considering each item and each possible capacity from 1 to the maximum capacity.\n\nThe `dp` table is filled using the following recurrence relation:\n\n*   If the current item's weight is less than or equal to the current capacity, consider including the item: `dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w])`.\n*   Otherwise, do not include the item: `dp[i][w] = dp[i - 1][w]`.\n\nAfter filling the `dp` table, the maximum value achievable within the capacity is stored in `dp[n][capacity]`. To reconstruct the solution, the code iterates backwards through the `dp` table, identifying the items that should be included in the knapsack.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this solution is O(n \\* capacity), where n is the number of items and capacity is the maximum capacity of the knapsack.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of this solution is O(n \\* capacity), which is the size of the `dp` table.",
  "timestamp": "2026-02-11T15:58:22.731005",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}