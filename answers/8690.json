{
  "prompt": "Write a program that solves a simple maze and finds the shortest path to the exit.",
  "answer": "**Maze Solver Program**\n=========================\n\n### Overview\n\nThis program uses a breadth-first search (BFS) algorithm to find the shortest path to the exit in a simple maze. The maze is represented as a 2D grid, where `#` represents walls and ` ` (space) represents empty spaces. The entrance is marked with `E` and the exit is marked with `X`.\n\n### Code\n\n```python\nfrom collections import deque\n\ndef solve_maze(maze):\n    \"\"\"\n    Solves the maze using BFS and returns the shortest path to the exit.\n    \"\"\"\n    # Find the entrance\n    entrance = None\n    for i in range(len(maze)):\n        for j in range(len(maze[i])):\n            if maze[i][j] == 'E':\n                entrance = (i, j)\n                break\n        if entrance:\n            break\n\n    # Directions to move in the maze\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Queue for BFS\n    queue = deque([(entrance, [])])\n\n    # Set to keep track of visited cells\n    visited = set([entrance])\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        # If we've reached the exit, return the path\n        if maze[x][y] == 'X':\n            return path + [(x, y)]\n\n        # Explore neighbors\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            # If the neighbor is within bounds and not a wall\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[nx])) and maze[nx][ny] != '#':\n                # If the neighbor has not been visited\n                if (nx, ny) not in visited:\n                    queue.append(((nx, ny), path + [(x, y)]))\n                    visited.add((nx, ny))\n\n    # If there's no path to the exit\n    return None\n\ndef print_maze(maze, path=None):\n    \"\"\"\n    Prints the maze with the path highlighted.\n    \"\"\"\n    for i in range(len(maze)):\n        for j in range(len(maze[i])):\n            if path and (i, j) in path:\n                print('*', end=' ')\n            else:\n                print(maze[i][j], end=' ')\n        print()\n\n# Example usage\nmaze = [\n    ['#', '#', '#', '#', '#', '#', '#'],\n    ['#', 'E', ' ', ' ', ' ', ' ', '#'],\n    ['#', '#', '#', ' ', '#', ' ', '#'],\n    ['#', ' ', ' ', ' ', '#', ' ', '#'],\n    ['#', ' ', '#', ' ', '#', ' ', '#'],\n    ['#', ' ', ' ', ' ', ' ', 'X', '#'],\n    ['#', '#', '#', '#', '#', '#', '#']\n]\n\npath = solve_maze(maze)\nprint(\"Path to the exit:\")\nprint_maze(maze, path)\n```\n\n### Explanation\n\n1. The `solve_maze` function takes a 2D grid representing the maze as input and returns the shortest path to the exit.\n2. It uses a BFS algorithm to explore the maze, starting from the entrance.\n3. The `print_maze` function prints the maze with the path highlighted.\n4. In the example usage, we define a sample maze and call the `solve_maze` function to find the shortest path to the exit. The resulting path is then printed using the `print_maze` function.",
  "timestamp": "2026-02-12T01:23:45.210789",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}