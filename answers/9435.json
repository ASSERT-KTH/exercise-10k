{
  "prompt": "Create a function that uses memoization to cache its results and avoid redundant computations",
  "answer": "**Memoization Function in Python**\n=====================================\n\nBelow is an example of a function that uses memoization to cache its results and avoid redundant computations. This function calculates the Fibonacci sequence, which is a classic example of a problem that benefits from memoization.\n\n```python\nfrom functools import wraps\n\ndef memoize(func):\n    \"\"\"Decorator to memoize function results.\"\"\"\n    cache = dict()\n\n    @wraps(func)\n    def memoized_func(*args):\n        if args in cache:\n            return cache[args]\n        else:\n            result = func(*args)\n            cache[args] = result\n            return result\n\n    return memoized_func\n\n@memoize\ndef fibonacci(n):\n    \"\"\"Calculate the nth Fibonacci number.\"\"\"\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Example usage:\nprint(fibonacci(10))  # Calculate the 10th Fibonacci number\n```\n\n**How Memoization Works**\n---------------------------\n\n1.  The `memoize` decorator is used to cache the results of the `fibonacci` function.\n2.  When the `fibonacci` function is called with a given argument `n`, it first checks if the result is already cached in the `cache` dictionary.\n3.  If the result is cached, it returns the cached value instead of recalculating it.\n4.  If the result is not cached, it calculates the result, stores it in the cache, and returns it.\n\n**Benefits of Memoization**\n---------------------------\n\n*   **Improved Performance**: Memoization avoids redundant computations by storing and reusing previously computed results.\n*   **Reduced Computational Complexity**: By avoiding redundant computations, memoization can significantly reduce the computational complexity of a function.\n\n**When to Use Memoization**\n---------------------------\n\n*   **Expensive Function Calls**: Use memoization when a function is expensive to compute and is called multiple times with the same arguments.\n*   **Recursive Functions**: Memoization is particularly useful for recursive functions, where the same sub-problems are solved multiple times.\n*   **Dynamic Programming**: Memoization is a key technique in dynamic programming, where it is used to store and reuse the solutions to sub-problems.",
  "timestamp": "2026-02-12T09:11:40.246871",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}