{
  "prompt": "Write a program to implement Huffman coding for a given text",
  "answer": "**Huffman Coding Implementation**\n=====================================\n\n### Overview\n\nHuffman coding is a lossless data compression algorithm. The program below implements Huffman coding for a given text.\n\n### Code\n```python\nimport heapq\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n\n    def __lt__(self, other):\n        return self.freq < other.freq\n\ndef calculate_frequency(text):\n    \"\"\"\n    Calculate the frequency of each character in the text.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        dict: A dictionary where the keys are characters and the values are their frequencies.\n    \"\"\"\n    frequency = defaultdict(int)\n    for char in text:\n        frequency[char] += 1\n    return frequency\n\ndef build_huffman_tree(frequency):\n    \"\"\"\n    Build the Huffman tree based on the character frequencies.\n\n    Args:\n        frequency (dict): A dictionary where the keys are characters and the values are their frequencies.\n\n    Returns:\n        Node: The root node of the Huffman tree.\n    \"\"\"\n    heap = [Node(char, freq) for char, freq in frequency.items()]\n    heapq.heapify(heap)\n\n    while len(heap) > 1:\n        node1 = heapq.heappop(heap)\n        node2 = heapq.heappop(heap)\n\n        merged = Node(None, node1.freq + node2.freq)\n        merged.left = node1\n        merged.right = node2\n\n        heapq.heappush(heap, merged)\n\n    return heap[0]\n\ndef build_codes_helper(root, current_code, codes):\n    \"\"\"\n    Helper function to build the Huffman codes.\n\n    Args:\n        root (Node): The current node in the Huffman tree.\n        current_code (str): The current code for the node.\n        codes (dict): A dictionary where the keys are characters and the values are their Huffman codes.\n    \"\"\"\n    if root.char is not None:\n        codes[root.char] = current_code\n\n    if root.left is not None:\n        build_codes_helper(root.left, current_code + \"0\", codes)\n\n    if root.right is not None:\n        build_codes_helper(root.right, current_code + \"1\", codes)\n\ndef build_codes(root):\n    \"\"\"\n    Build the Huffman codes for each character.\n\n    Args:\n        root (Node): The root node of the Huffman tree.\n\n    Returns:\n        dict: A dictionary where the keys are characters and the values are their Huffman codes.\n    \"\"\"\n    codes = {}\n    build_codes_helper(root, \"\", codes)\n    return codes\n\ndef huffman_encoding(text):\n    \"\"\"\n    Perform Huffman encoding on the given text.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        str: The encoded text.\n        dict: A dictionary where the keys are characters and the values are their Huffman codes.\n    \"\"\"\n    frequency = calculate_frequency(text)\n    root = build_huffman_tree(frequency)\n    codes = build_codes(root)\n\n    encoded_text = \"\".join(codes[char] for char in text)\n    return encoded_text, codes\n\ndef huffman_decoding(encoded_text, codes):\n    \"\"\"\n    Perform Huffman decoding on the given encoded text.\n\n    Args:\n        encoded_text (str): The encoded text.\n        codes (dict): A dictionary where the keys are characters and the values are their Huffman codes.\n\n    Returns:\n        str: The decoded text.\n    \"\"\"\n    reverse_codes = {v: k for k, v in codes.items()}\n    decoded_text = \"\"\n    temp = \"\"\n\n    for bit in encoded_text:\n        temp += bit\n        if temp in reverse_codes:\n            decoded_text += reverse_codes[temp]\n            temp = \"\"\n\n    return decoded_text\n\n# Example usage\ntext = \"this is an example for huffman encoding\"\nencoded_text, codes = huffman_encoding(text)\nprint(\"Encoded text:\", encoded_text)\nprint(\"Huffman codes:\", codes)\n\ndecoded_text = huffman_decoding(encoded_text, codes)\nprint(\"Decoded text:\", decoded_text)\n```\n\n### Explanation\n\n1.  The program starts by calculating the frequency of each character in the input text.\n2.  It then builds a Huffman tree based on these frequencies.\n3.  The Huffman codes for each character are generated by traversing the Huffman tree.\n4.  The `huffman_encoding` function performs the encoding by replacing each character in the text with its corresponding Huffman code.\n5.  The `huffman_decoding` function performs the decoding by reversing the process and replacing each Huffman code with its corresponding character.\n\n### Time Complexity\n\n*   Calculating frequency: O(n)\n*   Building Huffman tree: O(n log n)\n*   Building codes: O(n)\n*   Encoding: O(n)\n*   Decoding: O(n)\n\nwhere n is the length of the input text.\n\n### Space Complexity\n\n*   Frequency dictionary: O(k)\n*   Huffman tree: O(n)\n*",
  "timestamp": "2026-02-10T23:23:47.964656",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}