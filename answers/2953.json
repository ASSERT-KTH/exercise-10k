{
  "prompt": "Write a program to perform a breadth-first search traversal of a graph.",
  "answer": "Here's an implementation of a breadth-first search (BFS) traversal of a graph in Python:\n\n```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_vertex(self, vertex):\n        if vertex not in self.adjacency_list:\n            self.adjacency_list[vertex] = []\n\n    def add_edge(self, vertex1, vertex2):\n        if vertex1 in self.adjacency_list and vertex2 in self.adjacency_list:\n            self.adjacency_list[vertex1].append(vertex2)\n            self.adjacency_list[vertex2].append(vertex1)\n\n    def bfs_traversal(self, start_vertex):\n        visited = set()\n        traversal_order = []\n        queue = deque([start_vertex])\n\n        while queue:\n            current_vertex = queue.popleft()\n            if current_vertex not in visited:\n                visited.add(current_vertex)\n                traversal_order.append(current_vertex)\n                for neighbor in self.adjacency_list[current_vertex]:\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n\n        return traversal_order\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    graph = Graph()\n    graph.add_vertex(0)\n    graph.add_vertex(1)\n    graph.add_vertex(2)\n    graph.add_vertex(3)\n    graph.add_vertex(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(0, 2)\n    graph.add_edge(1, 3)\n    graph.add_edge(1, 4)\n    graph.add_edge(2, 4)\n\n    start_vertex = 0\n    traversal_order = graph.bfs_traversal(start_vertex)\n    print(\"BFS Traversal Order:\", traversal_order)\n\n```\n\n### How the Code Works:\n\n1.  **Graph Representation:** We use an adjacency list representation for the graph, where each key in the dictionary represents a vertex, and its corresponding value is a list of its neighboring vertices.\n2.  **Adding Vertices and Edges:** We provide methods to add vertices and edges to the graph. When adding an edge, we ensure that both vertices are already present in the graph.\n3.  **BFS Traversal:** The `bfs_traversal` method performs the BFS traversal of the graph. It uses a queue to keep track of vertices to visit next and a set to keep track of visited vertices. The traversal order is stored in a list.\n\n### Time Complexity:\n\n*   The time complexity of adding a vertex is O(1) since we simply add it to the adjacency list.\n*   The time complexity of adding an edge is O(1) since we append the neighboring vertex to the list of the current vertex.\n*   The time complexity of the BFS traversal is O(V + E), where V is the number of vertices and E is the number of edges, since we visit each vertex and edge once.\n\n### Space Complexity:\n\n*   The space complexity of the graph representation is O(V + E), where V is the number of vertices and E is the number of edges, since we store each vertex and edge in the adjacency list.\n*   The space complexity of the BFS traversal is O(V) since we store the visited vertices in a set and the traversal order in a list.",
  "timestamp": "2026-02-11T01:05:51.141259",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}