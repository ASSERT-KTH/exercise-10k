{
  "prompt": "Implement a function to find the minimum spanning tree of a weighted graph.",
  "answer": "**Minimum Spanning Tree Implementation**\n\n### Overview\n\nThe minimum spanning tree of a weighted graph is a subset of the edges that connects all the vertices together while minimizing the total edge weight. We will use Kruskal's algorithm to find the minimum spanning tree.\n\n### Code\n\n```python\nclass DisjointSet:\n    \"\"\"Disjoint set data structure to keep track of connected components.\"\"\"\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Merge the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\n\ndef kruskal(graph):\n    \"\"\"\n    Find the minimum spanning tree of a weighted graph using Kruskal's algorithm.\n\n    Args:\n        graph: A dictionary representing the graph, where each key is a vertex and\n            each value is a list of tuples containing the adjacent vertex and the edge weight.\n\n    Returns:\n        A list of tuples containing the edges in the minimum spanning tree, along with their weights.\n    \"\"\"\n    vertices = list(graph.keys())\n    disjoint_set = DisjointSet(vertices)\n    edges = []\n    for vertex in graph:\n        for neighbor, weight in graph[vertex]:\n            edges.append((weight, vertex, neighbor))\n    edges.sort()\n    mst_edges = []\n    for edge in edges:\n        weight, vertex1, vertex2 = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst_edges.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n    return mst_edges\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    graph = {\n        'A': [('B', 2), ('C', 3)],\n        'B': [('A', 2), ('C', 1), ('D', 4)],\n        'C': [('A', 3), ('B', 1), ('D', 5)],\n        'D': [('B', 4), ('C', 5)]\n    }\n    mst_edges = kruskal(graph)\n    print(\"Minimum Spanning Tree Edges:\")\n    for edge in mst_edges:\n        print(f\"Weight: {edge[0]}, Edge: {edge[1]}-{edge[2]}\")\n```\n\n### Explanation\n\n1.  We define a `DisjointSet` class to keep track of connected components in the graph.\n2.  The `kruskal` function takes a weighted graph as input and returns the minimum spanning tree edges.\n3.  We create a disjoint set for the vertices and initialize an empty list to store the edges in the minimum spanning tree.\n4.  We collect all edges from the graph, sort them by weight, and iterate through the sorted edges.\n5.  For each edge, we check if the two vertices are in different connected components. If they are, we add the edge to the minimum spanning tree and merge the two components.\n6.  Finally, we return the list of edges in the minimum spanning tree.\n\n### Time Complexity\n\nThe time complexity of Kruskal's algorithm is O(E log E) or O(E log V), where E is the number of edges and V is the number of vertices. The sorting step dominates the time complexity. The disjoint set operations (find and union) take almost constant time.",
  "timestamp": "2026-02-10T15:04:32.009781",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}