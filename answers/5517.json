{
  "prompt": "Write a program to find the minimum cut of a flow network using the Ford-Fulkerson algorithm.",
  "answer": "Here is a Python implementation of the Ford-Fulkerson algorithm to find the minimum cut of a flow network.\n\n```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n        while self.bfs(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n            max_flow += path_flow\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n        return max_flow\n\n\n# Example usage:\ngraph = [[0, 16, 13, 0, 0, 0],\n         [0, 0, 10, 12, 0, 0],\n         [0, 4, 0, 0, 14, 0],\n         [0, 0, 9, 0, 0, 20],\n         [0, 0, 0, 7, 0, 4],\n         [0, 0, 0, 0, 0, 0]]\n\ng = Graph(graph)\nsource = 0\nsink = 5\nprint(\"Maximum flow: \", g.ford_fulkerson(source, sink))\n\n```\n\n### Code Explanation:\n*   We start by defining a `Graph` class to represent the flow network. The graph is represented as an adjacency matrix, where `graph[i][j]` represents the capacity of the edge from node `i` to node `j`.\n*   The `bfs` method is used to find an augmenting path in the residual graph. It uses a breadth-first search (BFS) traversal to find a path from the source to the sink.\n*   The `ford_fulkerson` method implements the Ford-Fulkerson algorithm. It repeatedly finds augmenting paths in the residual graph and augments the flow along these paths until no more augmenting paths can be found.\n*   In the example usage, we create a `Graph` object with a sample flow network and find the maximum flow using the `ford_fulkerson` method.\n\n### Time Complexity:\n*   The time complexity of the `bfs` method is O(V + E), where V is the number of vertices and E is the number of edges.\n*   The time complexity of the `ford_fulkerson` method is O(max_flow \\* (V + E)), where max_flow is the maximum flow in the network.\n\n### Space Complexity:\n*   The space complexity of the `Graph` class is O(V^2), where V is the number of vertices.\n*   The space complexity of the `bfs` and `ford_fulkerson` methods is O(V), where V is the number of vertices.",
  "timestamp": "2026-02-11T15:26:31.536717",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}