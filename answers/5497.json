{
  "prompt": "Write a program to find the shortest path between two nodes in a weighted graph.",
  "answer": "**Shortest Path in a Weighted Graph**\n=====================================\n\nThis program uses Dijkstra's algorithm to find the shortest path between two nodes in a weighted graph.\n\n**Code**\n--------\n\n```python\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = {}\n\n    def add_edge(self, node1, node2, weight):\n        if node1 in self.nodes and node2 in self.nodes:\n            self.nodes[node1][node2] = weight\n            self.nodes[node2][node1] = weight  # for undirected graph\n\n    def dijkstra(self, start_node):\n        distances = {node: sys.maxsize for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.nodes[current_node].items():\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances\n\n    def shortest_path(self, start_node, end_node):\n        distances = self.dijkstra(start_node)\n        return distances[end_node]\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = Graph()\n\n    # Add nodes\n    graph.add_node('A')\n    graph.add_node('B')\n    graph.add_node('C')\n    graph.add_node('D')\n\n    # Add edges\n    graph.add_edge('A', 'B', 2)\n    graph.add_edge('A', 'C', 4)\n    graph.add_edge('B', 'C', 1)\n    graph.add_edge('B', 'D', 7)\n    graph.add_edge('C', 'D', 3)\n\n    # Find shortest path\n    start_node = 'A'\n    end_node = 'D'\n    shortest_distance = graph.shortest_path(start_node, end_node)\n\n    print(f\"Shortest distance from {start_node} to {end_node}: {shortest_distance}\")\n```\n\n**Explanation**\n---------------\n\n1.  **Graph Class**: The program defines a `Graph` class to represent the weighted graph.\n2.  **Adding Nodes and Edges**: The `add_node` and `add_edge` methods allow you to add nodes and edges to the graph, respectively.\n3.  **Dijkstra's Algorithm**: The `dijkstra` method implements Dijkstra's algorithm to find the shortest distances from a given start node to all other nodes in the graph.\n4.  **Shortest Path**: The `shortest_path` method uses the `dijkstra` method to find the shortest distance between two nodes.\n5.  **Example Usage**: The example usage demonstrates how to create a graph, add nodes and edges, and find the shortest path between two nodes.\n\n**Time Complexity**\n--------------------\n\nThe time complexity of Dijkstra's algorithm is O(|E|log|V|) in the worst case, where |E| is the number of edges and |V| is the number of vertices.\n\n**Space Complexity**\n---------------------\n\nThe space complexity is O(|V| + |E|), as we need to store the distances and edges for each node.",
  "timestamp": "2026-02-11T15:19:36.180998",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}