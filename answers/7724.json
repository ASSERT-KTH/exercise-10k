{
  "prompt": "Find the minimum window substring that contains all characters of a given string.",
  "answer": "**Minimum Window Substring**\n================================\n\nThe minimum window substring problem is a classic problem in computer science and coding interviews. Given two strings, `s` and `t`, find the minimum window substring of `s` that contains all characters of `t`.\n\n**Solution**\n------------\n\nWe can solve this problem using the sliding window technique. The idea is to maintain a window of characters in `s` that contains all characters of `t`. We expand the window to the right until we find all characters of `t`, and then we try to shrink the window from the left while keeping all characters of `t` in the window.\n\n**Code**\n------\n\n```python\nfrom collections import Counter\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring of `s` that contains all characters of `t`.\n\n    Args:\n    s (str): The string to search in.\n    t (str): The string to search for.\n\n    Returns:\n    str: The minimum window substring of `s` that contains all characters of `t`.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    t_count = Counter(t)\n    required = len(t_count)\n\n    left = 0\n    min_len = float('inf')\n    min_str = \"\"\n\n    formed = 0\n    window_counts = {}\n\n    for right in range(len(s)):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed += 1\n\n        while left <= right and formed == required:\n            character = s[left]\n\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_str = s[left:right + 1]\n\n            window_counts[character] -= 1\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed -= 1\n\n            left += 1\n\n    return min_str\n\n# Example usage\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window(s, t))  # Output: \"BANC\"\n```\n\n**Explanation**\n--------------\n\n1.  We first count the frequency of characters in `t` using the `Counter` class from the `collections` module.\n2.  We initialize two pointers, `left` and `right`, to represent the sliding window. We also initialize `min_len` to store the minimum length of the window and `min_str` to store the minimum window substring.\n3.  We iterate over `s` using the `right` pointer. For each character, we increment its count in the `window_counts` dictionary.\n4.  If the character is in `t` and its count in the window is equal to its count in `t`, we increment the `formed` variable, which keeps track of the number of characters in `t` that are formed in the window.\n5.  If all characters in `t` are formed in the window (`formed == required`), we try to shrink the window from the left. We decrement the count of the character at the `left` pointer and update `formed` if necessary.\n6.  If the length of the current window is less than `min_len`, we update `min_len` and `min_str`.\n7.  Finally, we return the minimum window substring `min_str`.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this solution is O(|s| + |t|), where |s| and |t| are the lengths of the strings `s` and `t`, respectively.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of this solution is O(|s| + |t|), where |s| and |t| are the lengths of the strings `s` and `t`, respectively. We need to store the counts of characters in `t` and the window, which requires O(|t|) space. We also need to store the minimum window substring, which requires O(|s|) space in the worst case.",
  "timestamp": "2026-02-11T22:28:14.863675",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}