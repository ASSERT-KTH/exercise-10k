{
  "prompt": "Write a function to calculate the factorial of a given number.",
  "answer": "**Factorial Function**\n=======================\n\n### Description\n\nCalculates the factorial of a given number.\n\n### Code\n\n```python\ndef calculate_factorial(n: int) -> int:\n    \"\"\"\n    Calculates the factorial of a given number.\n\n    Args:\n    n (int): The input number.\n\n    Returns:\n    int: The factorial of the input number.\n\n    Raises:\n    ValueError: If the input number is negative.\n    \"\"\"\n\n    # Check if the input number is negative\n    if n < 0:\n        raise ValueError(\"Input number cannot be negative\")\n\n    # Base case: factorial of 0 or 1 is 1\n    if n == 0 or n == 1:\n        return 1\n\n    # Recursive case: n * factorial of (n-1)\n    else:\n        return n * calculate_factorial(n-1)\n\n\ndef main():\n    # Example usage:\n    num = 5\n    result = calculate_factorial(num)\n    print(f\"The factorial of {num} is: {result}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n*   The `calculate_factorial` function takes an integer `n` as input and returns its factorial.\n*   It checks if the input number is negative, raising a `ValueError` if true.\n*   The function uses recursion to calculate the factorial, with base cases for `n = 0` and `n = 1`.\n*   The `main` function demonstrates example usage, calculating the factorial of the number 5.\n\n### Advice\n\n*   Be cautious when using recursive functions with large input values to avoid potential stack overflow errors.\n*   Consider using an iterative approach for larger input values.\n*   Always include input validation to ensure the function behaves correctly for edge cases.",
  "timestamp": "2026-02-10T17:53:46.176367",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}