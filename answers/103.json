{
  "prompt": "Write a program to implement binary search in an array.",
  "answer": "**Binary Search in an Array**\n================================\n\nBelow is an implementation of binary search in Python. This program takes a sorted array and a target value as input and returns the index of the target value if found.\n\n```python\ndef binary_search(arr, target):\n    \"\"\"\n    Searches for the target value in the given sorted array using binary search.\n\n    Args:\n        arr (list): A sorted list of integers.\n        target (int): The value to be searched.\n\n    Returns:\n        int: The index of the target value if found, -1 otherwise.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# Example usage:\nif __name__ == \"__main__\":\n    arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target = 23\n    result = binary_search(arr, target)\n    if result != -1:\n        print(f\"Element {target} found at index {result}\")\n    else:\n        print(f\"Element {target} not found in the array\")\n```\n\n**Explanation**\n---------------\n\n1.  Initialize two pointers, `left` and `right`, to the start and end of the array, respectively.\n2.  Calculate the middle index `mid` using the formula `(left + right) // 2`.\n3.  Compare the middle element `arr[mid]` with the `target` value.\n    *   If `arr[mid]` is equal to the `target`, return the `mid` index.\n    *   If `arr[mid]` is less than the `target`, update `left` to `mid + 1` to search in the right half.\n    *   If `arr[mid]` is greater than the `target`, update `right` to `mid - 1` to search in the left half.\n4.  Repeat steps 2-3 until `left` is greater than `right`.\n5.  If the `target` is not found, return -1.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this binary search implementation is O(log n), where n is the number of elements in the array. This is because with each iteration, the search space is reduced by half.\n\n**Space Complexity**\n-------------------\n\nThe space complexity is O(1), which means the algorithm requires constant space, making it efficient for large datasets.",
  "timestamp": "2026-02-10T13:21:36.497983",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}