{
  "prompt": "Create a function that finds the minimum window substring that contains all characters of a given string.",
  "answer": "**Minimum Window Substring Function**\n=====================================\n\n### Problem Statement\n\nGiven two strings `s` and `t`, find the minimum window substring of `s` that contains all characters of `t`.\n\n### Solution\n\nWe can solve this problem using a sliding window approach with the help of two pointers, `left` and `right`. We will also use a dictionary to store the frequency of characters in string `t`.\n\n```python\nfrom collections import defaultdict\n\ndef min_window(s, t):\n    \"\"\"\n    Find the minimum window substring of `s` that contains all characters of `t`.\n\n    Args:\n    s (str): The string to search for the minimum window substring.\n    t (str): The string containing the characters to search for.\n\n    Returns:\n    str: The minimum window substring of `s` that contains all characters of `t`. If no such substring exists, returns an empty string.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    # Create a dictionary to store the frequency of characters in string t\n    t_count = defaultdict(int)\n    for char in t:\n        t_count[char] += 1\n\n    # Initialize the required character count to the length of string t\n    required_chars = len(t_count)\n\n    # Initialize the left and right pointers\n    left = 0\n\n    # Initialize the minimum window substring and its length\n    min_window = \"\"\n    min_window_len = float('inf')\n\n    # Initialize the formed character count to 0\n    formed_chars = 0\n\n    # Create a dictionary to store the frequency of characters in the current window\n    window_counts = defaultdict(int)\n\n    # Iterate over the string s\n    for right in range(len(s)):\n        # Add the character at the right pointer to the window counts\n        character = s[right]\n        window_counts[character] += 1\n\n        # If the character is in t_count and its frequency in the window is equal to its frequency in t_count, increment the formed_chars count\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed_chars += 1\n\n        # While the window contains all characters of t and the left pointer is less than the right pointer\n        while left <= right and formed_chars == required_chars:\n            # Update the minimum window substring if the current window is smaller\n            if right - left + 1 < min_window_len:\n                min_window = s[left:right + 1]\n                min_window_len = right - left + 1\n\n            # Remove the character at the left pointer from the window counts\n            character = s[left]\n            window_counts[character] -= 1\n\n            # If the character is in t_count and its frequency in the window is less than its frequency in t_count, decrement the formed_chars count\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed_chars -= 1\n\n            # Move the left pointer to the right\n            left += 1\n\n    # Return the minimum window substring\n    return min_window\n\n# Example usage\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window(s, t))  # Output: \"BANC\"\n```\n\n### Explanation\n\n1.  Create a dictionary `t_count` to store the frequency of characters in string `t`.\n2.  Initialize the required character count to the length of `t_count`.\n3.  Initialize the left and right pointers, `left` and `right`, to 0.\n4.  Initialize the minimum window substring `min_window` to an empty string and its length `min_window_len` to infinity.\n5.  Initialize the formed character count `formed_chars` to 0.\n6.  Create a dictionary `window_counts` to store the frequency of characters in the current window.\n7.  Iterate over the string `s` using the right pointer.\n8.  Add the character at the right pointer to `window_counts`.\n9.  If the character is in `t_count` and its frequency in the window is equal to its frequency in `t_count`, increment `formed_chars`.\n10. While the window contains all characters of `t` and the left pointer is less than the right pointer, update the minimum window substring if the current window is smaller.\n11. Remove the character at the left pointer from `window_counts`.\n12. If the character is in `t_count` and its frequency in the window is less than its frequency in `t_count`, decrement `formed_chars`.\n13. Move the left pointer to the right.\n14. Return the minimum window substring.\n\n### Time Complexity\n\nThe time complexity of this solution is O(|s| + |t|), where |s| and |t| are the lengths of strings `s` and `t`, respectively.\n\n### Space Complexity\n\nThe space complexity of this solution is O(|t|), as we need to store the frequency",
  "timestamp": "2026-02-11T08:25:46.463454",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}