{
  "prompt": "Given two strings, find the minimum window substring that contains all characters of the second string.",
  "answer": "**Minimum Window Substring Problem**\n=====================================\n\n### Problem Statement\n\nGiven two strings `s` and `t`, find the minimum window substring of `s` that contains all characters of `t`.\n\n### Solution\n\nWe can solve this problem using the sliding window technique. The idea is to maintain a window of characters in `s` that contains all characters of `t`. We use two pointers, `left` and `right`, to represent the start and end of the window.\n\n#### Algorithm\n\n1. Create a dictionary to store the frequency of characters in `t`.\n2. Initialize the `left` and `right` pointers to 0.\n3. Initialize the minimum window substring and its length.\n4. Iterate over `s` using the `right` pointer.\n5. For each character in `s`, decrement its frequency in the dictionary.\n6. If the frequency of a character becomes 0, it means we have found a character in `t`.\n7. If we have found all characters in `t`, update the minimum window substring.\n8. Move the `left` pointer to the right until we no longer have all characters in `t`.\n9. Repeat steps 4-8 until we have iterated over the entire string `s`.\n\n#### Code\n\n```python\nfrom collections import defaultdict\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring of `s` that contains all characters of `t`.\n\n    Args:\n    s (str): The string to search in.\n    t (str): The string to search for.\n\n    Returns:\n    str: The minimum window substring of `s` that contains all characters of `t`.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    # Create a dictionary to store the frequency of characters in `t`.\n    t_freq = defaultdict(int)\n    for char in t:\n        t_freq[char] += 1\n\n    # Initialize the `left` and `right` pointers.\n    left = 0\n    min_len = float('inf')\n    min_window = \"\"\n\n    # Initialize the count of characters in `t` that we have found.\n    count = 0\n\n    # Iterate over `s` using the `right` pointer.\n    for right in range(len(s)):\n        # Decrement the frequency of the current character in `t`.\n        if s[right] in t_freq:\n            t_freq[s[right]] -= 1\n            # If the frequency becomes 0, it means we have found a character in `t`.\n            if t_freq[s[right]] == 0:\n                count += 1\n\n        # If we have found all characters in `t`, update the minimum window substring.\n        while count == len(t_freq):\n            # Update the minimum window substring.\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_window = s[left:right + 1]\n\n            # Move the `left` pointer to the right until we no longer have all characters in `t`.\n            if s[left] in t_freq:\n                t_freq[s[left]] += 1\n                # If the frequency becomes 1, it means we no longer have a character in `t`.\n                if t_freq[s[left]] > 0:\n                    count -= 1\n            left += 1\n\n    return min_window\n\n# Example usage:\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window(s, t))  # Output: \"BANC\"\n```\n\n### Time Complexity\n\nThe time complexity of this solution is O(n), where n is the length of the string `s`. This is because we iterate over `s` once using the `right` pointer.\n\n### Space Complexity\n\nThe space complexity of this solution is O(m), where m is the length of the string `t`. This is because we store the frequency of characters in `t` in a dictionary.",
  "timestamp": "2026-02-10T14:33:56.822786",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}