{
  "prompt": "Find the longest substring with at most k distinct characters in a given string.",
  "answer": "**Longest Substring with At Most K Distinct Characters**\n\n### Problem Statement\n\nGiven a string `s` and an integer `k`, find the longest substring with at most `k` distinct characters.\n\n### Solution\n\nWe can solve this problem using a sliding window approach along with a frequency map to keep track of the characters in the current window.\n\n#### Algorithm\n\n1. Initialize variables:\n   - `left` to 0, representing the left boundary of the window.\n   - `max_length` to 0, representing the length of the longest substring with at most `k` distinct characters.\n   - `max_substring` to an empty string, representing the longest substring with at most `k` distinct characters.\n   - `freq_map` to an empty dictionary, representing the frequency of characters in the current window.\n\n2. Iterate over the string `s` using a pointer `right`:\n   - For each character, increment its frequency in `freq_map`.\n   - While the number of distinct characters in `freq_map` exceeds `k`, shrink the window by moving `left` to the right and decrementing the frequency of the character at `left` in `freq_map`.\n   - Update `max_length` and `max_substring` if the length of the current window is greater than `max_length`.\n\n3. Return `max_substring` as the longest substring with at most `k` distinct characters.\n\n### Code\n\n```python\ndef longest_substring_with_at_most_k_distinct(s: str, k: int) -> str:\n    \"\"\"\n    Find the longest substring with at most k distinct characters in a given string.\n\n    Args:\n    s (str): The input string.\n    k (int): The maximum number of distinct characters allowed.\n\n    Returns:\n    str: The longest substring with at most k distinct characters.\n    \"\"\"\n    if k == 0 or not s:\n        return \"\"\n\n    left = 0\n    max_length = 0\n    max_substring = \"\"\n    freq_map = {}\n\n    for right in range(len(s)):\n        # Increment the frequency of the character at right in freq_map\n        freq_map[s[right]] = freq_map.get(s[right], 0) + 1\n\n        # Shrink the window if the number of distinct characters exceeds k\n        while len(freq_map) > k:\n            freq_map[s[left]] -= 1\n            if freq_map[s[left]] == 0:\n                del freq_map[s[left]]\n            left += 1\n\n        # Update max_length and max_substring if the length of the current window is greater than max_length\n        if right - left + 1 > max_length:\n            max_length = right - left + 1\n            max_substring = s[left:right + 1]\n\n    return max_substring\n\n# Example usage\ns = \"abcba\"\nk = 2\nprint(longest_substring_with_at_most_k_distinct(s, k))  # Output: \"bcb\"\n```\n\n### Time Complexity\n\nThe time complexity of this solution is O(n), where n is the length of the input string `s`. This is because we are iterating over the string `s` once.\n\n### Space Complexity\n\nThe space complexity of this solution is O(min(n, k)), where n is the length of the input string `s` and k is the maximum number of distinct characters allowed. This is because we are using a frequency map `freq_map` to keep track of the characters in the current window, and the size of `freq_map` is at most min(n, k).",
  "timestamp": "2026-02-11T22:30:07.355355",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}