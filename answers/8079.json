{
  "prompt": "Write a function that uses a decorator to modify its behavior",
  "answer": "**Using a Decorator to Modify Function Behavior**\n====================================================\n\nIn this example, we'll create a decorator that logs the execution time of a function and applies it to a simple `add` function.\n\n### Code\n\n```python\nimport time\nfrom functools import wraps\n\ndef timer_decorator(func):\n    \"\"\"Logs the execution time of a function.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        execution_time = (end_time - start_time) * 1000  # Convert to milliseconds\n        print(f\"Function '{func.__name__}' executed in {execution_time:.2f} ms\")\n        return result\n    return wrapper\n\n@timer_decorator\ndef add(a, b):\n    \"\"\"Returns the sum of two numbers.\"\"\"\n    time.sleep(0.5)  # Simulate some work\n    return a + b\n\n# Example usage\nif __name__ == \"__main__\":\n    result = add(2, 3)\n    print(f\"Result: {result}\")\n```\n\n### Explanation\n\n1. The `timer_decorator` function takes another function `func` as an argument and returns a new function `wrapper`.\n2. The `wrapper` function measures the execution time of the original function `func` and logs it.\n3. The `@timer_decorator` syntax before the `add` function definition applies the decorator to the `add` function.\n4. When the `add` function is called, it's actually the `wrapper` function that's executed, which logs the execution time and then calls the original `add` function.\n\n### Advice\n\n* Use the `@wraps` decorator from the `functools` module to preserve the original function's metadata (e.g., name, docstring).\n* Keep your decorators simple and focused on a specific task to avoid complexity.\n* Use decorators to modify function behavior in a reusable and non-intrusive way.",
  "timestamp": "2026-02-11T23:23:09.663161",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}