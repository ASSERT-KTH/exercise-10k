{
  "prompt": "Create a function that takes a graph as an argument and returns the maximum flow between two nodes.",
  "answer": "**Maximum Flow Function**\n==========================\n\nHere's an implementation of the Ford-Fulkerson algorithm with the Edmonds-Karp implementation to find the maximum flow between two nodes in a flow network.\n\n### Code\n\n```python\nfrom collections import deque\n\ndef bfs(graph, source, sink, parent):\n    \"\"\"\n    Breadth-first search to find an augmenting path.\n\n    Args:\n    graph (list): Residual graph.\n    source (int): Source node.\n    sink (int): Sink node.\n    parent (list): Parent nodes for the augmenting path.\n\n    Returns:\n    bool: Whether an augmenting path is found.\n    \"\"\"\n    visited = [False] * len(graph)\n    queue = deque()\n\n    queue.append(source)\n    visited[source] = True\n\n    while queue:\n        u = queue.popleft()\n\n        for ind, val in enumerate(graph[u]):\n            if not visited[ind] and val > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parent[ind] = u\n\n                if ind == sink:\n                    return True\n\n    return False\n\n\ndef ford_fulkerson(graph, source, sink):\n    \"\"\"\n    Ford-Fulkerson algorithm with Edmonds-Karp implementation.\n\n    Args:\n    graph (list): Flow network.\n    source (int): Source node.\n    sink (int): Sink node.\n\n    Returns:\n    int: Maximum flow.\n    \"\"\"\n    parent = [-1] * len(graph)\n    max_flow = 0\n\n    while bfs(graph, source, sink, parent):\n        path_flow = float(\"inf\")\n        s = sink\n\n        while s != source:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n\n        max_flow += path_flow\n\n        v = sink\n        while v != source:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n\n    return max_flow\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = [[0, 16, 13, 0, 0, 0],\n             [0, 0, 10, 12, 0, 0],\n             [0, 4, 0, 0, 14, 0],\n             [0, 0, 9, 0, 0, 20],\n             [0, 0, 0, 7, 0, 4],\n             [0, 0, 0, 0, 0, 0]]\n\n    source = 0\n    sink = 5\n\n    max_flow = ford_fulkerson(graph, source, sink)\n    print(\"Maximum flow:\", max_flow)\n\n```\n\n### Explanation\n\nThe provided code implements the Ford-Fulkerson algorithm with the Edmonds-Karp implementation to find the maximum flow between two nodes in a flow network.\n\n*   The `bfs` function performs a breadth-first search to find an augmenting path in the residual graph.\n*   The `ford_fulkerson` function implements the Ford-Fulkerson algorithm, which repeatedly finds augmenting paths and updates the residual graph until no more augmenting paths can be found.\n*   In the example usage, a sample flow network is defined as a graph, and the maximum flow between the source node (0) and the sink node (5) is calculated and printed.\n\n### Time Complexity\n\nThe time complexity of the Ford-Fulkerson algorithm with the Edmonds-Karp implementation is O(VE^2), where V is the number of vertices (nodes) and E is the number of edges in the graph.\n\n### Advice\n\n*   Ensure that the input graph is a valid flow network, where each edge has a non-negative capacity.\n*   The source and sink nodes should be specified correctly.\n*   The algorithm assumes that the graph is represented as an adjacency matrix, where `graph[i][j]` represents the capacity of the edge from node i to node j. If the graph is represented differently, you may need to modify the algorithm accordingly.",
  "timestamp": "2026-02-11T20:37:53.486746",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}