{
  "prompt": "Develop a program that simulates the Game of Life. The program should generate a 2D grid, ask for user input, and determine the next generation based on the game's rules.",
  "answer": "**Game of Life Simulation Program**\n=====================================\n\nThis program simulates the Game of Life, a cellular automaton devised by the British mathematician John Horton Conway. The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input.\n\n**Game Rules**\n-------------\n\n1.  **Survival**: Every cell that has two or three live neighbours survives in the next generation.\n2.  **Death by isolation**: Each cell with one or zero live neighbours dies in the next generation, as if caused by underpopulation.\n3.  **Death by overcrowding**: Each cell with four or more live neighbours dies in the next generation, as if by overpopulation.\n4.  **Reproduction**: Any dead cell with exactly three live neighbours becomes a live cell in the next generation, as if by reproduction.\n\n**Program Implementation**\n-------------------------\n\nBelow is a Python implementation of the Game of Life simulation program:\n\n```python\nimport numpy as np\nimport random\nimport time\nimport os\n\ndef create_grid(rows, cols):\n    \"\"\"\n    Create a 2D grid with random cell values (0 = dead, 1 = alive).\n    \n    Args:\n        rows (int): Number of rows in the grid.\n        cols (int): Number of columns in the grid.\n    \n    Returns:\n        np.ndarray: A 2D grid with random cell values.\n    \"\"\"\n    grid = np.zeros((rows, cols))\n    for i in range(rows):\n        for j in range(cols):\n            grid[i][j] = random.choice([0, 1])\n    return grid\n\ndef print_grid(grid):\n    \"\"\"\n    Print the current state of the grid.\n    \n    Args:\n        grid (np.ndarray): The 2D grid to print.\n    \"\"\"\n    os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n    for row in grid:\n        print(' '.join(['*' if cell else ' ' for cell in row]))\n\ndef count_neighbours(grid, i, j):\n    \"\"\"\n    Count the number of live neighbours for a cell.\n    \n    Args:\n        grid (np.ndarray): The 2D grid.\n        i (int): The row index of the cell.\n        j (int): The column index of the cell.\n    \n    Returns:\n        int: The number of live neighbours.\n    \"\"\"\n    rows, cols = grid.shape\n    count = 0\n    for x in range(max(0, i-1), min(rows, i+2)):\n        for y in range(max(0, j-1), min(cols, j+2)):\n            if (x, y) != (i, j) and grid[x][y] == 1:\n                count += 1\n    return count\n\ndef next_generation(grid):\n    \"\"\"\n    Determine the next generation based on the game's rules.\n    \n    Args:\n        grid (np.ndarray): The current 2D grid.\n    \n    Returns:\n        np.ndarray: The next generation grid.\n    \"\"\"\n    rows, cols = grid.shape\n    next_grid = np.copy(grid)\n    for i in range(rows):\n        for j in range(cols):\n            live_neighbours = count_neighbours(grid, i, j)\n            if grid[i][j] == 1 and (live_neighbours < 2 or live_neighbours > 3):\n                next_grid[i][j] = 0  # Death by isolation or overcrowding\n            elif grid[i][j] == 0 and live_neighbours == 3:\n                next_grid[i][j] = 1  # Reproduction\n    return next_grid\n\ndef main():\n    rows = int(input(\"Enter the number of rows: \"))\n    cols = int(input(\"Enter the number of columns: \"))\n    grid = create_grid(rows, cols)\n    \n    while True:\n        print_grid(grid)\n        grid = next_generation(grid)\n        time.sleep(0.5)  # Pause for 0.5 seconds\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Example Usage**\n-----------------\n\n1.  Run the program and enter the desired number of rows and columns when prompted.\n2.  The program will display the initial grid and start simulating the Game of Life.\n3.  The grid will update every 0.5 seconds, showing the next generation based on the game's rules.\n\nNote: You can adjust the `time.sleep(0.5)` line to change the simulation speed. A smaller value will make the simulation faster, while a larger value will make it slower.",
  "timestamp": "2026-02-11T17:12:43.838720",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}