{
  "prompt": "Write a program that finds the minimum window of a given string that contains all characters of another given string.",
  "answer": "**Minimum Window Substring**\n=====================================\n\nThis program finds the minimum window of a given string that contains all characters of another given string.\n\n### Code\n\n```python\nfrom collections import Counter\n\ndef min_window(s, t):\n    \"\"\"\n    Find the minimum window of string `s` that contains all characters of string `t`.\n\n    Args:\n    s (str): The string to search in.\n    t (str): The string containing the characters to search for.\n\n    Returns:\n    str: The minimum window of `s` that contains all characters of `t`. If no such window exists, returns an empty string.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    t_count = Counter(t)\n    required_chars = len(t_count)\n    left = 0\n    min_len = float('inf')\n    min_window = \"\"\n\n    for right in range(len(s)):\n        if s[right] in t_count:\n            t_count[s[right]] -= 1\n            if t_count[s[right]] == 0:\n                required_chars -= 1\n\n        while required_chars == 0:\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_window = s[left:right + 1]\n\n            if s[left] in t_count:\n                t_count[s[left]] += 1\n                if t_count[s[left]] > 0:\n                    required_chars += 1\n            left += 1\n\n    return min_window\n\n# Example usage:\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window(s, t))  # Output: \"BANC\"\n```\n\n### Explanation\n\n1.  **Initialization**: We start by initializing the `t_count` dictionary with the characters of string `t` and their counts. We also initialize `required_chars` to the number of unique characters in `t`.\n2.  **Sliding Window**: We use a sliding window approach with two pointers, `left` and `right`, to traverse string `s`. We expand the window to the right by incrementing `right` and update `t_count` accordingly.\n3.  **Shrinking the Window**: When we have found all required characters (i.e., `required_chars` becomes 0), we try to shrink the window from the left by incrementing `left`. We update `t_count` and `required_chars` accordingly.\n4.  **Updating the Minimum Window**: If the current window is smaller than the minimum window found so far, we update `min_len` and `min_window`.\n5.  **Returning the Minimum Window**: Finally, we return the minimum window of `s` that contains all characters of `t`. If no such window exists, we return an empty string.\n\n### Time Complexity\n\nThe time complexity of this solution is O(n), where n is the length of string `s`, since we traverse `s` once.\n\n### Space Complexity\n\nThe space complexity is O(k), where k is the number of unique characters in string `t`, since we use a dictionary to store the characters of `t` and their counts.",
  "timestamp": "2026-02-11T01:18:44.809873",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}