{
  "prompt": "Create a function that implements a queue using a list.",
  "answer": "**Queue Implementation using a List**\n=====================================\n\n### Overview\n\nA queue is a First-In-First-Out (FIFO) data structure, meaning that the first element added to the queue will be the first one to be removed. This implementation uses a list to store the elements of the queue.\n\n### Code\n\n```python\nclass Queue:\n    def __init__(self):\n        \"\"\"\n        Initializes an empty queue.\n        \"\"\"\n        self.queue = []\n\n    def enqueue(self, item):\n        \"\"\"\n        Adds an item to the end of the queue.\n\n        Args:\n            item: The item to be added to the queue.\n        \"\"\"\n        self.queue.append(item)\n\n    def dequeue(self):\n        \"\"\"\n        Removes and returns the item at the front of the queue.\n\n        Returns:\n            The item at the front of the queue.\n\n        Raises:\n            IndexError: If the queue is empty.\n        \"\"\"\n        if self.is_empty():\n            raise IndexError(\"Cannot dequeue from an empty queue\")\n        return self.queue.pop(0)\n\n    def is_empty(self):\n        \"\"\"\n        Checks if the queue is empty.\n\n        Returns:\n            True if the queue is empty, False otherwise.\n        \"\"\"\n        return len(self.queue) == 0\n\n    def peek(self):\n        \"\"\"\n        Returns the item at the front of the queue without removing it.\n\n        Returns:\n            The item at the front of the queue.\n\n        Raises:\n            IndexError: If the queue is empty.\n        \"\"\"\n        if self.is_empty():\n            raise IndexError(\"Cannot peek into an empty queue\")\n        return self.queue[0]\n\n    def size(self):\n        \"\"\"\n        Returns the number of items in the queue.\n\n        Returns:\n            The number of items in the queue.\n        \"\"\"\n        return len(self.queue)\n\n# Example usage\nif __name__ == \"__main__\":\n    queue = Queue()\n    print(queue.is_empty())  # Output: True\n    queue.enqueue(1)\n    queue.enqueue(2)\n    queue.enqueue(3)\n    print(queue.size())  # Output: 3\n    print(queue.peek())  # Output: 1\n    print(queue.dequeue())  # Output: 1\n    print(queue.size())  # Output: 2\n    print(queue.is_empty())  # Output: False\n```\n\n### Explanation\n\n*   The `Queue` class has an `__init__` method that initializes an empty list to store the queue elements.\n*   The `enqueue` method adds an item to the end of the queue using the `append` method.\n*   The `dequeue` method removes and returns the item at the front of the queue using the `pop(0)` method. If the queue is empty, it raises an `IndexError`.\n*   The `is_empty` method checks if the queue is empty by checking the length of the list.\n*   The `peek` method returns the item at the front of the queue without removing it. If the queue is empty, it raises an `IndexError`.\n*   The `size` method returns the number of items in the queue by returning the length of the list.\n\n### Time Complexity\n\n*   `enqueue`: O(1) amortized\n*   `dequeue`: O(n) where n is the number of items in the queue\n*   `is_empty`: O(1)\n*   `peek`: O(1)\n*   `size`: O(1)\n\nNote that the time complexity of the `dequeue` operation is O(n) because the `pop(0)` method has to shift all the elements in the list to fill the gap created by removing the first element. This can be improved by using a collections.deque instead of a list, which has O(1) time complexity for both `enqueue` and `dequeue` operations.",
  "timestamp": "2026-02-12T02:29:05.934455",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}