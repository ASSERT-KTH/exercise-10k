{
  "prompt": "Write a program that uses recursive function calls and a for loop to sort a list using the merge sort algorithm.",
  "answer": "Here's a Python implementation of the merge sort algorithm using recursive function calls and a for loop:\n\n```python\ndef merge_sort(arr):\n    # Base case: If the array has one or zero elements, it is already sorted\n    if len(arr) <= 1:\n        return arr\n\n    # Find the middle point of the array\n    mid = len(arr) // 2\n\n    # Divide the array into two halves\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Recursively sort the two halves\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    # Merge the sorted halves\n    return merge(left_half, right_half)\n\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n\n    # Merge smaller elements first\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    # Append any remaining elements\n    for i in range(left_index, len(left)):\n        merged.append(left[i])\n\n    for i in range(right_index, len(right)):\n        merged.append(right[i])\n\n    return merged\n\n\n# Example usage\narr = [64, 34, 25, 12, 22, 11, 90]\nsorted_arr = merge_sort(arr)\nprint(\"Sorted array:\", sorted_arr)\n\n```\n\n**Explanation:**\n\n1.  The `merge_sort` function takes an array as input and recursively divides it into two halves until each half has one or zero elements (the base case).\n2.  The `merge` function merges two sorted arrays into a single sorted array. It uses a for loop to append the smaller elements from the two arrays.\n3.  In the `merge` function, we use two indices (`left_index` and `right_index`) to keep track of the current position in the left and right arrays.\n4.  We compare elements from the left and right arrays and append the smaller element to the `merged` array.\n5.  Finally, we append any remaining elements from the left and right arrays to the `merged` array.\n\n**Time Complexity:**\n\n*   The time complexity of the merge sort algorithm is O(n log n), where n is the number of elements in the array. This is because the algorithm divides the array into two halves at each recursive step, resulting in log n levels of recursion. At each level, the algorithm merges the sorted halves, which takes O(n) time.\n*   The space complexity is O(n), as the algorithm creates temporary arrays to store the sorted halves.\n\n**Example Use Cases:**\n\n*   Sorting large datasets: Merge sort is suitable for sorting large datasets, as its time complexity is O(n log n), making it more efficient than other sorting algorithms like bubble sort or insertion sort.\n*   Real-time data processing: Merge sort can be used in real-time data processing applications where data needs to be sorted quickly and efficiently.\n*   Database query optimization: Merge sort can be used to optimize database queries by sorting large datasets quickly and efficiently.",
  "timestamp": "2026-02-11T17:47:39.292917",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}