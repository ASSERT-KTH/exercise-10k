{
  "prompt": "Write a program that evaluates a given boolean expression",
  "answer": "**Evaluating Boolean Expressions**\n=====================================\n\nBelow is a Python program that evaluates a given boolean expression. The program uses a simple recursive descent parser to parse the boolean expression and evaluate it.\n\n**Code**\n--------\n\n```python\n# Define a class to represent a boolean expression\nclass BooleanExpression:\n    def __init__(self, expression):\n        self.expression = expression\n\n    def evaluate(self):\n        # Remove any whitespace from the expression\n        expression = self.expression.replace(\" \", \"\")\n\n        # Evaluate the expression\n        return self._evaluate_expression(expression)\n\n    def _evaluate_expression(self, expression):\n        # Base case: if the expression is a single character, return its boolean value\n        if len(expression) == 1:\n            return expression == \"T\" or expression == \"True\"\n\n        # Find the operator with the lowest precedence\n        operator_index = self._find_operator(expression)\n\n        # If no operator is found, return the boolean value of the expression\n        if operator_index == -1:\n            return self._evaluate_term(expression)\n\n        # Evaluate the left and right operands\n        left_operand = expression[:operator_index]\n        right_operand = expression[operator_index + 1:]\n\n        # Evaluate the operator\n        operator = expression[operator_index]\n\n        # Recursively evaluate the left and right operands\n        left_value = self._evaluate_expression(left_operand) if len(left_operand) > 1 else self._evaluate_term(left_operand)\n        right_value = self._evaluate_expression(right_operand) if len(right_operand) > 1 else self._evaluate_term(right_operand)\n\n        # Apply the operator\n        if operator == \"&\":\n            return left_value and right_value\n        elif operator == \"|\":\n            return left_value or right_value\n\n    def _find_operator(self, expression):\n        # Find the operator with the lowest precedence\n        for i, char in enumerate(expression):\n            if char in [\"&\", \"|\"]:\n                return i\n        return -1\n\n    def _evaluate_term(self, term):\n        # Evaluate a term (a single boolean value or a parenthesized expression)\n        if term[0] == \"(\" and term[-1] == \")\":\n            return self._evaluate_expression(term[1:-1])\n        else:\n            return term == \"T\" or term == \"True\"\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    expression = \"T&T|F\"\n    boolean_expression = BooleanExpression(expression)\n    result = boolean_expression.evaluate()\n    print(f\"The result of '{expression}' is {result}\")\n```\n\n**Explanation**\n---------------\n\n1. The program defines a `BooleanExpression` class to represent a boolean expression.\n2. The `evaluate` method removes any whitespace from the expression and calls the `_evaluate_expression` method to evaluate it.\n3. The `_evaluate_expression` method uses a recursive descent parser to parse the boolean expression and evaluate it.\n4. The method finds the operator with the lowest precedence and recursively evaluates the left and right operands.\n5. The method applies the operator to the left and right values and returns the result.\n6. The `_find_operator` method finds the operator with the lowest precedence in the expression.\n7. The `_evaluate_term` method evaluates a term (a single boolean value or a parenthesized expression).\n\n**Example Use Cases**\n--------------------\n\n* Evaluating a simple boolean expression: `T&T|F`\n* Evaluating a boolean expression with parentheses: `(T&T)|F`\n* Evaluating a boolean expression with multiple operators: `T&T|F&F`",
  "timestamp": "2026-02-11T21:35:01.307913",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}