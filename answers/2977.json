{
  "prompt": "Write a program that implements a graph algorithm to solve a given problem. The problem should be: find the shortest path between two nodes in a weighted graph.",
  "answer": "**Dijkstra's Algorithm Implementation in Python**\n=====================================================\n\n### Problem Statement\n\nGiven a weighted graph, find the shortest path between two nodes.\n\n### Solution Overview\n\nWe will use Dijkstra's algorithm to solve this problem. Dijkstra's algorithm is a well-known graph algorithm that finds the shortest path between two nodes in a weighted graph.\n\n### Code Implementation\n\n```python\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_nodes):\n        self.num_nodes = num_nodes\n        self.adj_list = [[] for _ in range(num_nodes)]\n\n    def add_edge(self, node1, node2, weight):\n        self.adj_list[node1].append((node2, weight))\n        self.adj_list[node2].append((node1, weight))  # Comment this line for directed graph\n\n    def dijkstra(self, start_node):\n        distances = [sys.maxsize] * self.num_nodes\n        distances[start_node] = 0\n        pq = [(0, start_node)]\n\n        while pq:\n            current_distance, current_node = heapq.heappop(pq)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.adj_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n\n        return distances\n\n    def shortest_path(self, start_node, end_node):\n        distances = self.dijkstra(start_node)\n        return distances[end_node]\n\n# Example usage\nif __name__ == \"__main__\":\n    num_nodes = 6\n    edges = [\n        (0, 1, 4),\n        (0, 2, 2),\n        (1, 3, 5),\n        (2, 1, 1),\n        (2, 3, 8),\n        (2, 4, 10),\n        (3, 4, 2),\n        (3, 5, 6),\n        (4, 5, 3)\n    ]\n\n    graph = Graph(num_nodes)\n    for node1, node2, weight in edges:\n        graph.add_edge(node1, node2, weight)\n\n    start_node = 0\n    end_node = 5\n    shortest_distance = graph.shortest_path(start_node, end_node)\n    print(f\"Shortest distance from node {start_node} to node {end_node}: {shortest_distance}\")\n```\n\n### Explanation\n\n1.  We define a `Graph` class with methods to add edges and find the shortest path using Dijkstra's algorithm.\n2.  The `add_edge` method adds an edge between two nodes with a given weight.\n3.  The `dijkstra` method implements Dijkstra's algorithm to find the shortest distances from a given start node to all other nodes.\n4.  The `shortest_path` method uses the `dijkstra` method to find the shortest distance between a start node and an end node.\n5.  In the example usage, we create a sample graph, add edges, and find the shortest distance between nodes 0 and 5.\n\n### Time Complexity\n\n*   The time complexity of Dijkstra's algorithm is O((V + E) \\* logV) in the worst case, where V is the number of vertices (nodes) and E is the number of edges.\n*   The space complexity is O(V + E) for storing the graph and O(V) for the priority queue.\n\n### Advice\n\n*   Use a priority queue (like `heapq` in Python) to efficiently select the node with the minimum distance in each iteration.\n*   Use an adjacency list representation for the graph to efficiently iterate over neighbors of a node.\n*   Consider using a more efficient data structure like a Fibonacci heap for very large graphs.",
  "timestamp": "2026-02-11T01:13:55.749560",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}