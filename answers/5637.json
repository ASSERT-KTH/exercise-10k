{
  "prompt": "Write a program to check if a given graph is bipartite or not.",
  "answer": "**Bipartite Graph Checker**\n==========================\n\nA bipartite graph is a graph whose vertices can be divided into two disjoint sets U and V such that every edge connects a vertex in U to one in V.\n\n### Code\n\n```python\nfrom collections import deque\n\ndef is_bipartite(graph):\n    \"\"\"\n    Checks if a given graph is bipartite.\n\n    Args:\n    graph (dict): An adjacency list representation of the graph.\n\n    Returns:\n    bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    color = {}\n\n    for node in graph:\n        if node not in color:\n            if not bfs(graph, node, color):\n                return False\n\n    return True\n\n\ndef bfs(graph, node, color):\n    \"\"\"\n    Performs a breadth-first search to assign colors to nodes.\n\n    Args:\n    graph (dict): An adjacency list representation of the graph.\n    node (int): The current node.\n    color (dict): A dictionary to store the color of each node.\n\n    Returns:\n    bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    queue = deque([node])\n    color[node] = 0  # 0 represents one color, 1 represents the other color\n\n    while queue:\n        current_node = queue.popleft()\n\n        for neighbor in graph[current_node]:\n            if neighbor not in color:\n                color[neighbor] = 1 - color[current_node]  # Assign the opposite color\n                queue.append(neighbor)\n            elif color[neighbor] == color[current_node]:\n                return False  # If two adjacent nodes have the same color, the graph is not bipartite\n\n    return True\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Define a bipartite graph\n    bipartite_graph = {\n        0: [1, 3],\n        1: [0, 2],\n        2: [1, 3],\n        3: [0, 2]\n    }\n\n    # Define a non-bipartite graph\n    non_bipartite_graph = {\n        0: [1, 2],\n        1: [0, 2],\n        2: [0, 1]\n    }\n\n    print(is_bipartite(bipartite_graph))  # Output: True\n    print(is_bipartite(non_bipartite_graph))  # Output: False\n```\n\n### Explanation\n\n1.  The `is_bipartite` function iterates over all nodes in the graph and checks if they have been assigned a color.\n2.  If a node has not been assigned a color, the `bfs` function is called to perform a breadth-first search and assign colors to the node and its neighbors.\n3.  In the `bfs` function, a queue is used to keep track of nodes to visit. Each node is assigned a color (0 or 1), and its neighbors are assigned the opposite color.\n4.  If two adjacent nodes have the same color, the graph is not bipartite, and the function returns False.\n5.  If all nodes have been assigned colors without finding any adjacent nodes with the same color, the graph is bipartite, and the function returns True.\n\n### Time Complexity\n\nThe time complexity of this algorithm is O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. This is because each node and edge is visited once during the breadth-first search.\n\n### Space Complexity\n\nThe space complexity of this algorithm is O(V), where V is the number of vertices (nodes) in the graph. This is because a dictionary is used to store the color of each node.",
  "timestamp": "2026-02-11T15:57:57.853290",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}