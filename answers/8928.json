{
  "prompt": "Write a program to check if a given linked list has a cycle.",
  "answer": "**Detecting Cycles in Linked Lists**\n=====================================\n\nHere is a Python solution using Floyd's Tortoise and Hare algorithm, also known as the \"slow and fast pointers\" technique.\n\n```python\nclass Node:\n    \"\"\"Represents a node in the linked list.\"\"\"\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef has_cycle(head):\n    \"\"\"\n    Detects whether a cycle exists in the linked list.\n\n    Args:\n        head (Node): The head of the linked list.\n\n    Returns:\n        bool: True if a cycle exists, False otherwise.\n    \"\"\"\n    if head is None or head.next is None:\n        return False\n\n    # Initialize slow and fast pointers\n    slow = head\n    fast = head.next\n\n    while slow != fast:\n        if fast is None or fast.next is None:\n            return False\n\n        # Move slow pointer one step at a time\n        slow = slow.next\n        # Move fast pointer two steps at a time\n        fast = fast.next.next\n\n    return True\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a linked list with a cycle\n    node1 = Node(1)\n    node2 = Node(2)\n    node3 = Node(3)\n    node4 = Node(4)\n\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node2  # Create a cycle\n\n    print(has_cycle(node1))  # Output: True\n\n    # Create a linked list without a cycle\n    node5 = Node(5)\n    node6 = Node(6)\n    node7 = Node(7)\n\n    node5.next = node6\n    node6.next = node7\n\n    print(has_cycle(node5))  # Output: False\n```\n\n**How it Works**\n---------------\n\n1.  We initialize two pointers, `slow` and `fast`, to the head of the linked list.\n2.  We move the `slow` pointer one step at a time and the `fast` pointer two steps at a time.\n3.  If there is a cycle, the `fast` pointer will eventually catch up to the `slow` pointer.\n4.  If there is no cycle, the `fast` pointer will reach the end of the linked list.\n\nThis algorithm has a time complexity of O(n), where n is the number of nodes in the linked list, and a space complexity of O(1), as it only uses a constant amount of space to store the slow and fast pointers.",
  "timestamp": "2026-02-12T02:13:09.091281",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}