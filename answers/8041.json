{
  "prompt": "Write a program that uses an if/else statement to simulate the Game of Life based on the initial cell configuration.",
  "answer": "**Game of Life Simulation**\n==========================\n\nThe Game of Life is a cellular automaton devised by the British mathematician John Horton Conway. The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input.\n\n**Rules**\n--------\n\nThe universe of the Game of Life is a two-dimensional grid of square cells, each of which is in one of two possible states: alive or dead. Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent.\n\nAt each step in time, the following transitions occur:\n\n1.  Any live cell with fewer than two live neighbours dies (underpopulation).\n2.  Any live cell with two or three live neighbours lives (normal life).\n3.  Any live cell with more than three live neighbours dies (overpopulation).\n4.  Any dead cell with exactly three live neighbours becomes a live cell (reproduction).\n\n**Implementation**\n----------------\n\nHere is a Python implementation of the Game of Life using an if/else statement:\n\n```python\nimport numpy as np\nimport time\nimport os\n\ndef game_of_life(grid):\n    \"\"\"\n    Simulates the Game of Life based on the initial cell configuration.\n\n    Args:\n        grid (numpy array): A 2D numpy array representing the initial cell configuration.\n                             0 represents a dead cell and 1 represents a live cell.\n\n    Returns:\n        numpy array: A 2D numpy array representing the next generation of cells.\n    \"\"\"\n    rows, cols = grid.shape\n    next_grid = np.copy(grid)\n\n    for i in range(rows):\n        for j in range(cols):\n            # Count the number of live neighbours\n            live_neighbours = 0\n            for x in range(max(0, i-1), min(rows, i+2)):\n                for y in range(max(0, j-1), min(cols, j+2)):\n                    if (x, y) != (i, j) and grid[x, y] == 1:\n                        live_neighbours += 1\n\n            # Apply the rules of the Game of Life\n            if grid[i, j] == 1 and (live_neighbours < 2 or live_neighbours > 3):\n                next_grid[i, j] = 0  # Underpopulation or overpopulation\n            elif grid[i, j] == 0 and live_neighbours == 3:\n                next_grid[i, j] = 1  # Reproduction\n            # Else, the cell remains in its current state\n\n    return next_grid\n\ndef print_grid(grid):\n    \"\"\"\n    Prints the current state of the grid.\n\n    Args:\n        grid (numpy array): A 2D numpy array representing the current cell configuration.\n    \"\"\"\n    os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n    for row in grid:\n        print(' '.join(['*' if cell else ' ' for cell in row]))\n\ndef main():\n    # Initialize the grid with a random configuration\n    np.random.seed(0)\n    grid = np.random.choice([0, 1], size=(20, 20), p=[0.5, 0.5])\n\n    while True:\n        print_grid(grid)\n        grid = game_of_life(grid)\n        time.sleep(0.5)  # Pause for 0.5 seconds between generations\n\nif __name__ == '__main__':\n    main()\n```\n\n**Example Use Case**\n--------------------\n\nTo run the Game of Life simulation, simply execute the `main` function. The program will initialize a random grid configuration and simulate the Game of Life, printing the current state of the grid at each generation.\n\nNote: The grid size and initial configuration can be modified by changing the `size` parameter in the `np.random.choice` function and the `p` parameter to adjust the probability of a cell being alive.",
  "timestamp": "2026-02-11T23:13:27.300067",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}