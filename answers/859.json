{
  "prompt": "Create a function that memoizes another function, caching its results to avoid redundant computation, and also handles cache invalidation.",
  "answer": "Of course! I'll guide you through creating a function that memoizes another function, caching its results to avoid redundant computation, and also handles cache invalidation. This solution will help optimize performance by minimizing unnecessary computations. Here is the code:\n\n```python\ndef memoize(func):\n    \"\"\"\n    A decorator function that memoizes another function, caching its results to avoid redundant computation.\n    \n    Args:\n        func (function): The input function to be memoized.\n    \n    Returns:\n        function: A new function that wraps the input function with memoization.\n    \"\"\"\n\n    # Create a dictionary to store the cached results\n    cache = {}\n\n    # Define a new function that will wrap the input function\n    def memoized_func(*args, **kwargs):\n        \n        # Create a key for the cache dictionary based on the function arguments\n        key = str(args) + str(kwargs)\n        \n        # Check if the result is already in the cache\n        if key in cache:\n            # If it is, return the cached result\n            return cache[key]\n        else:\n            # If not, compute the result using the input function\n            result = func(*args, **kwargs)\n            \n            # Store the result in the cache\n            cache[key] = result\n            \n            # Return the result\n            return result\n\n    # Define a method to invalidate the cache\n    def invalidate_cache():\n        cache.clear()\n\n    # Add the invalidate_cache method to the memoized function\n    memoized_func.invalidate_cache = invalidate_cache\n\n    # Return the memoized function\n    return memoized_func\n\n\n# Example usage:\n\n@memoize\ndef add(a, b):\n    # Simulate an expensive computation\n    import time\n    time.sleep(2)\n    return a + b\n\nprint(add(2, 3))  # This will take 2 seconds\nprint(add(2, 3))  # This will return immediately from the cache\nadd.invalidate_cache()  # Invalidate the cache\nprint(add(2, 3))  # This will take 2 seconds again\n```\n\n### Explanation\n\n*   The `memoize` function is a decorator that takes another function `func` as an argument and returns a new function `memoized_func` that wraps the input function with memoization. It uses a dictionary `cache` to store the cached results.\n*   Inside `memoized_func`, a key is created based on the function arguments `args` and `kwargs`. It checks if the result is already in the cache. If it is, the cached result is returned; otherwise, the result is computed using the input function, stored in the cache, and then returned.\n*   The `invalidate_cache` method is defined to clear the cache, allowing for cache invalidation. This method is added to the `memoized_func` and can be called to invalidate the cache when needed.\n*   The example usage demonstrates how to use the `@memoize` decorator with a sample function `add`. It shows how the memoized function returns results from the cache when called with the same arguments multiple times and how to invalidate the cache using the `invalidate_cache` method.",
  "timestamp": "2026-02-10T16:23:39.505691",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}