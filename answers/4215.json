{
  "prompt": "Find the kth largest element in an array.",
  "answer": "**Kth Largest Element in an Array**\n=====================================\n\nHere's a solution to find the kth largest element in an array. We'll use the QuickSelect algorithm, which is an efficient method for finding the kth smallest (or largest) element in an unsorted array.\n\n**Algorithm Steps**\n------------------\n\n1. **Check if k is within bounds**: Ensure that `k` is within the range of the array indices (1 to n, where n is the array length).\n2. **Call QuickSelect function**: Call the QuickSelect function, passing the array, `k`, and the array bounds (0 and n-1).\n3. **Partition the array**: Partition the array around a pivot element.\n4. **Recursively search**: Recursively search for the kth largest element in the appropriate partition.\n\n**Code Implementation**\n----------------------\n\n```python\nimport random\n\ndef kth_largest_element(arr, k):\n    \"\"\"\n    Find the kth largest element in an array.\n\n    Args:\n        arr (list): Input array.\n        k (int): Index of the desired largest element (1-indexed).\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k is out of bounds\")\n\n    return quickselect(arr, 0, len(arr) - 1, len(arr) - k)\n\ndef quickselect(arr, low, high, k):\n    \"\"\"\n    QuickSelect algorithm to find the kth smallest element.\n\n    Args:\n        arr (list): Input array.\n        low (int): Lower bound of the array.\n        high (int): Upper bound of the array.\n        k (int): Index of the desired smallest element (0-indexed).\n\n    Returns:\n        int: The kth smallest element in the array.\n    \"\"\"\n    if low == high:\n        return arr[low]\n\n    # Select a random pivot index\n    pivot_index = random.randint(low, high)\n\n    # Swap the pivot element with the last element\n    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n\n    # Partition the array\n    i = low\n    for j in range(low, high):\n        if arr[j] <= arr[high]:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n\n    # Swap the pivot element with the element at the pivot index\n    arr[i], arr[high] = arr[high], arr[i]\n\n    # Recursively search for the kth smallest element\n    if k == i:\n        return arr[k]\n    elif k < i:\n        return quickselect(arr, low, i - 1, k)\n    else:\n        return quickselect(arr, i + 1, high, k)\n\n# Example usage:\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nresult = kth_largest_element(arr, k)\nprint(f\"The {k}th largest element is: {result}\")\n```\n\n**Explanation**\n---------------\n\n1. The `kth_largest_element` function takes an array and `k` as input and checks if `k` is within bounds.\n2. It calls the `quickselect` function, passing the array, `k`, and the array bounds.\n3. The `quickselect` function partitions the array around a pivot element and recursively searches for the kth smallest element.\n4. The `quickselect` function returns the kth smallest element, which is equivalent to the kth largest element when `k` is adjusted accordingly.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this solution is O(n) on average, where n is the length of the array. However, in the worst-case scenario, the time complexity can be O(n^2). To mitigate this, we use a random pivot index to reduce the likelihood of worst-case scenarios.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of this solution is O(1), as we only use a constant amount of extra memory to store the pivot index and other temporary variables.",
  "timestamp": "2026-02-11T10:15:23.454361",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}