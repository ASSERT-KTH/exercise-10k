{
  "prompt": "Create a program to simulate the Game of Life.",
  "answer": "**Game of Life Simulator**\n==========================\n\nThe Game of Life is a cellular automaton devised by the British mathematician John Horton Conway. It is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input.\n\n### Rules of the Game\n\n1.  Any live cell with fewer than two live neighbours dies, as if by underpopulation.\n2.  Any live cell with two or three live neighbours lives on to the next generation.\n3.  Any live cell with more than three live neighbours dies, as if by overpopulation.\n4.  Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\n\n### Implementation\n\nBelow is a Python implementation of the Game of Life using the Pygame library for visualization.\n\n```python\nimport pygame\nimport numpy as np\n\n# Window dimensions\nWIDTH, HEIGHT = 800, 600\n\n# Cell size\nCELL_SIZE = 10\n\n# Colors\nALIVE_COLOR = (255, 255, 255)\nDEAD_COLOR = (0, 0, 0)\n\nclass GameOfLife:\n    def __init__(self, width, height, cell_size):\n        self.width = width\n        self.height = height\n        self.cell_size = cell_size\n        self.grid = np.random.choice([0, 1], size=(height // cell_size, width // cell_size), p=[0.5, 0.5])\n\n    def draw(self, screen):\n        screen.fill(DEAD_COLOR)\n        for i in range(self.grid.shape[0]):\n            for j in range(self.grid.shape[1]):\n                if self.grid[i, j] == 1:\n                    pygame.draw.rect(screen, ALIVE_COLOR, (j * self.cell_size, i * self.cell_size, self.cell_size, self.cell_size))\n\n    def update(self):\n        new_grid = self.grid.copy()\n        for i in range(self.grid.shape[0]):\n            for j in range(self.grid.shape[1]):\n                live_neighbours = self.count_live_neighbours(i, j)\n                if self.grid[i, j] == 1:\n                    if live_neighbours < 2 or live_neighbours > 3:\n                        new_grid[i, j] = 0\n                else:\n                    if live_neighbours == 3:\n                        new_grid[i, j] = 1\n        self.grid = new_grid\n\n    def count_live_neighbours(self, i, j):\n        count = 0\n        for x in range(-1, 2):\n            for y in range(-1, 2):\n                col = (j + y + self.grid.shape[1]) % self.grid.shape[1]\n                row = (i + x + self.grid.shape[0]) % self.grid.shape[0]\n                count += self.grid[row, col]\n        count -= self.grid[i, j]\n        return count\n\ndef main():\n    pygame.init()\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n    pygame.display.set_caption(\"Game of Life\")\n    clock = pygame.time.Clock()\n    game = GameOfLife(WIDTH, HEIGHT, CELL_SIZE)\n\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n\n        game.draw(screen)\n        pygame.display.flip()\n        game.update()\n        clock.tick(60)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n1.  The program initializes a grid of random cells, where each cell can be either alive (1) or dead (0).\n2.  The `draw` method draws the current state of the grid on the screen.\n3.  The `update` method applies the rules of the Game of Life to each cell in the grid, updating the grid for the next generation.\n4.  The `count_live_neighbours` method counts the number of live neighbours for a given cell.\n5.  The `main` function sets up the Pygame window and runs the Game of Life simulation in a loop, updating the grid and drawing the new state at 60 frames per second.\n\n### Running the Program\n\n1.  Install the required libraries by running `pip install pygame numpy` in your terminal.\n2.  Save the above code in a file named `game_of_life.py`.\n3.  Run the program by executing `python game_of_life.py` in your terminal.\n4.  The Game of Life simulation will run in a window, displaying the evolution of the grid over time.",
  "timestamp": "2026-02-10T17:09:15.958237",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}