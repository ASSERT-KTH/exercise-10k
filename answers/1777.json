{
  "prompt": "Write a function to check if a given graph has a cycle.",
  "answer": "### Cycle Detection in a Graph\n#### Overview\nThis solution uses a depth-first search (DFS) approach to detect cycles in a graph. The graph is represented as an adjacency list.\n\n#### Code\n```python\nfrom typing import Dict, List\n\ndef has_cycle(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Checks if a given graph has a cycle.\n\n    Args:\n    graph: A dictionary representing the graph as an adjacency list.\n\n    Returns:\n    True if the graph has a cycle, False otherwise.\n    \"\"\"\n    visited = set()\n    recursion_stack = set()\n\n    def dfs(node: int) -> bool:\n        \"\"\"\n        Recursive DFS function to detect cycles.\n\n        Args:\n        node: The current node being visited.\n\n        Returns:\n        True if a cycle is detected, False otherwise.\n        \"\"\"\n        visited.add(node)\n        recursion_stack.add(node)\n\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in recursion_stack:\n                return True\n\n        recursion_stack.remove(node)\n        return False\n\n    for node in graph:\n        if node not in visited:\n            if dfs(node):\n                return True\n\n    return False\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Define a graph with a cycle\n    graph_with_cycle = {\n        0: [1, 2],\n        1: [2],\n        2: [0, 3],\n        3: [3]\n    }\n\n    # Define a graph without a cycle\n    graph_without_cycle = {\n        0: [1, 2],\n        1: [2],\n        2: [3],\n        3: []\n    }\n\n    print(has_cycle(graph_with_cycle))  # Output: True\n    print(has_cycle(graph_without_cycle))  # Output: False\n```\n\n#### Explanation\n1.  We start by defining a function `has_cycle` that takes an adjacency list representation of the graph as input.\n2.  We initialize two sets: `visited` to keep track of visited nodes and `recursion_stack` to detect cycles.\n3.  The `dfs` function is a recursive helper function that performs the actual cycle detection.\n4.  In the `dfs` function, we mark the current node as visited and add it to the recursion stack.\n5.  We then iterate over the neighbors of the current node. If a neighbor is not visited, we recursively call `dfs` on it. If it is already in the recursion stack, we have detected a cycle.\n6.  After visiting all neighbors, we remove the current node from the recursion stack.\n7.  Finally, we iterate over all nodes in the graph and call `dfs` on unvisited nodes. If any call returns `True`, we return `True`, indicating the presence of a cycle.\n\n#### Time Complexity\nThe time complexity of this solution is O(V + E), where V is the number of vertices (nodes) and E is the number of edges, since we visit each node and edge once.\n\n#### Space Complexity\nThe space complexity is O(V), as in the worst case, the recursion stack and visited set can contain all nodes.",
  "timestamp": "2026-02-10T20:07:49.211854",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}