{
  "prompt": "Write a program that traverses a binary tree in-order, pre-order, and post-order. Use a while loop to recursively traverse the tree.",
  "answer": "Here's a high-quality, readable, and well-documented code that implements the binary tree traversal program in Python:\n\n```python\nclass Node:\n    \"\"\"Represents a node in the binary tree.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    \"\"\"Represents a binary tree with methods for traversal.\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def inorder(self, node):\n        \"\"\"Traverses the binary tree in-order using a stack.\"\"\"\n        stack = []\n        while True:\n            if node:\n                stack.append(node)\n                node = node.left\n            elif stack:\n                node = stack.pop()\n                print(node.value, end=\" \")\n                node = node.right\n            else:\n                break\n\n    def preorder(self, node):\n        \"\"\"Traverses the binary tree pre-order using a stack.\"\"\"\n        stack = [node]\n        while stack:\n            node = stack.pop()\n            if node:\n                print(node.value, end=\" \")\n                stack.append(node.right)\n                stack.append(node.left)\n\n    def postorder(self, node):\n        \"\"\"Traverses the binary tree post-order using a stack.\"\"\"\n        stack1 = [node]\n        stack2 = []\n        while stack1:\n            node = stack1.pop()\n            stack2.append(node)\n            if node.left:\n                stack1.append(node.left)\n            if node.right:\n                stack1.append(node.right)\n        while stack2:\n            node = stack2.pop()\n            print(node.value, end=\" \")\n\n    def insert(self, value):\n        \"\"\"Inserts a new node into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(self.root, value)\n\n    def _insert(self, node, value):\n        if value < node.value:\n            if node.left:\n                self._insert(node.left, value)\n            else:\n                node.left = Node(value)\n        else:\n            if node.right:\n                self._insert(node.right, value)\n            else:\n                node.right = Node(value)\n\n# Example usage\ntree = BinaryTree()\ntree.insert(8)\ntree.insert(3)\ntree.insert(10)\ntree.insert(1)\ntree.insert(6)\ntree.insert(14)\ntree.insert(4)\ntree.insert(7)\ntree.insert(13)\n\nprint(\"In-order traversal:\")\ntree.inorder(tree.root)\nprint(\"\\nPre-order traversal:\")\ntree.preorder(tree.root)\nprint(\"\\nPost-order traversal:\")\ntree.postorder(tree.root)\n```\n\n### Explanation\n\nThe provided solution defines a binary tree with a `Node` class and a `BinaryTree` class. The `BinaryTree` class includes methods for inserting nodes and traversing the tree in-order, pre-order, and post-order.\n\n*   The `inorder` method uses a stack to traverse the tree in-order. It pushes nodes onto the stack until it reaches a leaf node, then pops nodes off the stack and prints their values.\n*   The `preorder` method uses a stack to traverse the tree pre-order. It pushes the root node onto the stack, then enters a loop where it pops a node, prints its value, and pushes its right and left children onto the stack.\n*   The `postorder` method uses two stacks to traverse the tree post-order. It pushes nodes onto the first stack, then pops them off and pushes them onto the second stack. Finally, it pops nodes off the second stack and prints their values.\n*   The `insert` method inserts a new node into the binary tree by recursively finding the correct position for the node.\n\nThe example usage demonstrates how to create a binary tree, insert nodes, and perform the three types of traversals.\n\n### Time Complexity\n\nThe time complexity of the traversal methods is O(n), where n is the number of nodes in the binary tree, since each node is visited exactly once.\n\n### Space Complexity\n\nThe space complexity of the traversal methods is O(n) due to the use of stacks to store nodes. In the worst case, the stack can contain all nodes in the tree, which occurs when the tree is highly unbalanced.",
  "timestamp": "2026-02-11T14:34:37.789758",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}