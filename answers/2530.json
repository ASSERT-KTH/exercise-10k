{
  "prompt": "Implement a DFS algorithm to traverse a graph or tree",
  "answer": "**Depth-First Search (DFS) Algorithm Implementation**\n\n### Overview\n\nThe Depth-First Search (DFS) algorithm is a popular graph traversal technique used to visit all nodes in a graph or tree. In this implementation, we will use a recursive approach to traverse the graph.\n\n### Code Implementation\n\n```python\nclass Graph:\n    def __init__(self, num_vertices):\n        \"\"\"\n        Initialize a graph with a specified number of vertices.\n\n        Args:\n            num_vertices (int): The number of vertices in the graph.\n        \"\"\"\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n\n    def add_edge(self, v, w):\n        \"\"\"\n        Add an edge between two vertices in the graph.\n\n        Args:\n            v (int): The source vertex.\n            w (int): The destination vertex.\n        \"\"\"\n        self.adj_list[v].append(w)\n\n    def dfs(self, start_vertex):\n        \"\"\"\n        Perform a depth-first search traversal of the graph starting from a specified vertex.\n\n        Args:\n            start_vertex (int): The vertex to start the traversal from.\n\n        Returns:\n            list: A list of visited vertices.\n        \"\"\"\n        visited = [False] * self.num_vertices\n        traversal_order = []\n\n        def dfs_helper(vertex):\n            visited[vertex] = True\n            traversal_order.append(vertex)\n            for neighbor in self.adj_list[vertex]:\n                if not visited[neighbor]:\n                    dfs_helper(neighbor)\n\n        dfs_helper(start_vertex)\n        return traversal_order\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a sample graph\n    graph = Graph(5)\n    graph.add_edge(0, 1)\n    graph.add_edge(0, 2)\n    graph.add_edge(1, 3)\n    graph.add_edge(1, 4)\n\n    # Perform DFS traversal starting from vertex 0\n    traversal_order = graph.dfs(0)\n    print(\"DFS Traversal Order:\", traversal_order)\n```\n\n### Explanation\n\n1.  **Graph Representation**: The graph is represented using an adjacency list, where each vertex is associated with a list of its neighboring vertices.\n2.  **DFS Algorithm**: The `dfs` method performs the DFS traversal. It uses a recursive helper function `dfs_helper` to visit each vertex and its neighbors.\n3.  **Visited Array**: A `visited` array keeps track of the visited vertices to avoid revisiting them.\n4.  **Traversal Order**: The `traversal_order` list stores the order in which the vertices are visited.\n\n### Time and Space Complexity\n\n*   **Time Complexity**: O(V + E), where V is the number of vertices and E is the number of edges, since each vertex and edge is visited once.\n*   **Space Complexity**: O(V), for the `visited` array and the recursion stack.\n\n### Example Use Cases\n\n*   **Graph Traversal**: DFS is useful for traversing graphs and finding connected components.\n*   **Topological Sorting**: DFS can be used to perform topological sorting on directed acyclic graphs (DAGs).\n*   **Finding Strongly Connected Components**: DFS can be used to find strongly connected components in a graph.",
  "timestamp": "2026-02-10T23:19:38.996794",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}