{
  "prompt": "Write a program to find the minimum window substring that contains all characters of a given string.",
  "answer": "**Minimum Window Substring Program**\n=====================================\n\n### Overview\n\nThis program finds the minimum window substring that contains all characters of a given string. It uses a sliding window approach with two pointers to track the minimum window.\n\n### Code\n```python\nfrom collections import Counter\n\ndef min_window(s, t):\n    \"\"\"\n    Find the minimum window substring that contains all characters of string t.\n\n    Args:\n    s (str): The input string.\n    t (str): The string containing characters to search for.\n\n    Returns:\n    str: The minimum window substring.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    t_count = Counter(t)\n    required_chars = len(t_count)\n    left = 0\n    min_len = float('inf')\n    min_window = \"\"\n    formed_chars = 0\n\n    window_counts = {}\n\n    for right in range(len(s)):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed_chars += 1\n\n        while left <= right and formed_chars == required_chars:\n            character = s[left]\n\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_window = s[left:right + 1]\n\n            window_counts[character] -= 1\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed_chars -= 1\n\n            left += 1\n\n    return min_window\n\n\n# Example usage\nif __name__ == \"__main__\":\n    s = \"ADOBECODEBANC\"\n    t = \"ABC\"\n    print(min_window(s, t))  # Output: \"BANC\"\n```\n\n### Explanation\n\n1.  **Initialization**: The function `min_window` takes two strings `s` and `t` as input.\n2.  **Count Characters in String t**: It uses the `Counter` class from the `collections` module to count the frequency of each character in string `t`.\n3.  **Sliding Window Approach**: It initializes two pointers, `left` and `right`, to represent the sliding window.\n4.  **Minimum Window**: It keeps track of the minimum window substring found so far.\n5.  **Formed Characters**: It maintains a count of characters in the current window that match the characters in string `t`.\n6.  **Window Counts**: It uses a dictionary `window_counts` to store the frequency of each character in the current window.\n7.  **Main Loop**: The outer loop iterates over the string `s` using the `right` pointer. For each character, it updates the `window_counts` dictionary and checks if the character is in `t_count`. If it is, and the count matches, it increments the `formed_chars` count.\n8.  **Inner Loop**: The inner loop checks if the `formed_chars` count matches the `required_chars` count. If it does, it means the current window contains all characters of string `t`. It then updates the minimum window substring if the current window is smaller.\n9.  **Window Update**: It updates the `window_counts` dictionary and decrements the `formed_chars` count if necessary.\n10. **Return**: Finally, it returns the minimum window substring.\n\nThis program has a time complexity of O(n), where n is the length of string `s`, and a space complexity of O(k), where k is the number of unique characters in string `t`.",
  "timestamp": "2026-02-11T01:07:44.147814",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}