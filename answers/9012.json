{
  "prompt": "Write a function that demonstrates function overloading using default arguments.",
  "answer": "**Function Overloading with Default Arguments**\n==============================================\n\nPython does not support function overloading in the classical sense like some other languages (e.g., C++ or Java). However, we can achieve similar behavior using default arguments.\n\n### Example Function\n\nHere's an example of a function that calculates the area of different shapes using function overloading with default arguments:\n```python\ndef calculate_area(length, width=None, radius=None):\n    \"\"\"\n    Calculate the area of different shapes.\n\n    Args:\n        length (float): The length of the shape.\n        width (float, optional): The width of the shape. Defaults to None.\n        radius (float, optional): The radius of the shape. Defaults to None.\n\n    Returns:\n        float: The calculated area.\n    \"\"\"\n    if width is not None:\n        # Calculate area of a rectangle\n        return length * width\n    elif radius is not None:\n        # Calculate area of a circle\n        import math\n        return math.pi * (radius ** 2)\n    else:\n        # Calculate area of a square\n        return length ** 2\n\n# Example usage:\nprint(calculate_area(5))  # Calculate area of a square\nprint(calculate_area(4, 5))  # Calculate area of a rectangle\nprint(calculate_area(5, radius=5))  # Calculate area of a circle\n```\nIn this example, the `calculate_area` function takes three arguments: `length`, `width`, and `radius`. The `width` and `radius` arguments have default values of `None`, which allows us to use the function to calculate the area of different shapes.\n\nNote that this implementation uses the `None` value to distinguish between the different shapes. This approach works well for simple cases but may become cumbersome for more complex scenarios.\n\n### Alternative Approach\n\nAnother way to achieve function overloading in Python is by using the `*args` and `**kwargs` syntax, which allows us to pass a variable number of arguments to a function. Here's an example:\n```python\ndef calculate_area(*args, **kwargs):\n    \"\"\"\n    Calculate the area of different shapes.\n\n    Args:\n        *args: Variable number of arguments.\n        **kwargs: Keyword arguments.\n\n    Returns:\n        float: The calculated area.\n    \"\"\"\n    if len(args) == 1:\n        # Calculate area of a square\n        return args[0] ** 2\n    elif len(args) == 2:\n        # Calculate area of a rectangle\n        return args[0] * args[1]\n    elif 'radius' in kwargs:\n        # Calculate area of a circle\n        import math\n        return math.pi * (kwargs['radius'] ** 2)\n    else:\n        raise ValueError(\"Invalid input\")\n\n# Example usage:\nprint(calculate_area(5))  # Calculate area of a square\nprint(calculate_area(4, 5))  # Calculate area of a rectangle\nprint(calculate_area(radius=5))  # Calculate area of a circle\n```\nThis implementation uses the `*args` and `**kwargs` syntax to pass a variable number of arguments to the `calculate_area` function. We then use conditional statements to determine which shape to calculate the area for based on the input arguments.\n\nWhile this approach provides more flexibility than the previous one, it can still become complex and error-prone for large numbers of shapes or complex calculations.\n\n### Conclusion\n\nFunction overloading in Python can be achieved using default arguments or the `*args` and `**kwargs` syntax. While these approaches provide a way to implement function overloading, they may not be as elegant or efficient as the classical function overloading found in other languages. However, they can still be useful in certain situations where we need to handle different input scenarios.",
  "timestamp": "2026-02-12T02:30:25.927196",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}