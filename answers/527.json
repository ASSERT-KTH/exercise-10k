{
  "prompt": "Write a function to solve the 0/1 knapsack problem, where the goal is to maximize the value of items in a knapsack without exceeding its capacity.",
  "answer": "**0/1 Knapsack Problem Solution**\n=====================================\n\nThe 0/1 knapsack problem is a classic problem in combinatorial optimization. The goal is to maximize the value of items in a knapsack without exceeding its capacity.\n\n**Function Implementation**\n-------------------------\n\nHere is a Python function that solves the 0/1 knapsack problem using dynamic programming:\n```python\ndef knapsack(capacity, weights, values):\n    \"\"\"\n    Solves the 0/1 knapsack problem using dynamic programming.\n\n    Parameters:\n    capacity (int): The maximum capacity of the knapsack.\n    weights (list): A list of item weights.\n    values (list): A list of item values.\n\n    Returns:\n    A tuple containing the maximum value that can be put in the knapsack and the items to include.\n    \"\"\"\n    n = len(values)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i - 1] <= w:\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w])\n            else:\n                dp[i][w] = dp[i - 1][w]\n\n    # Reconstruct the solution\n    max_value = dp[n][capacity]\n    items = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i - 1][w]:\n            items.append(i - 1)\n            w -= weights[i - 1]\n\n    return max_value, items[::-1]\n\n# Example usage\nif __name__ == \"__main__\":\n    capacity = 10\n    weights = [3, 4, 5, 2]\n    values = [10, 20, 30, 5]\n    max_value, items = knapsack(capacity, weights, values)\n    print(f\"Maximum value: {max_value}\")\n    print(f\"Items to include: {items}\")\n```\n\n**Explanation**\n---------------\n\nThe function `knapsack` takes three parameters: `capacity`, `weights`, and `values`. It returns a tuple containing the maximum value that can be put in the knapsack and the items to include.\n\nThe function uses a dynamic programming approach to solve the problem. It creates a 2D table `dp` where `dp[i][w]` represents the maximum value that can be obtained with `i` items and a capacity of `w`.\n\nThe function then iterates over the items and capacities, filling in the `dp` table using the following recurrence relation:\n\n* If the weight of the current item is less than or equal to the current capacity, consider including the item.\n* Otherwise, do not include the item.\n\nFinally, the function reconstructs the solution by tracing back the items that were included in the optimal solution.\n\n**Time Complexity**\n------------------\n\nThe time complexity of the function is O(nW), where n is the number of items and W is the capacity of the knapsack.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of the function is O(nW), where n is the number of items and W is the capacity of the knapsack.",
  "timestamp": "2026-02-10T15:03:08.607402",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}