{
  "prompt": "Write a program to implement a binary search algorithm using a while loop.",
  "answer": "Here is a Python implementation of a binary search algorithm using a while loop:\n\n```python\ndef binary_search(arr, target):\n    \"\"\"\n    Perform a binary search on a sorted array.\n\n    Args:\n        arr (list): The sorted array to search.\n        target (int): The target value to find.\n\n    Returns:\n        int: The index of the target value if found, -1 otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n\n# Example usage\narr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\ntarget = 23\n\nresult = binary_search(arr, target)\n\nif result != -1:\n    print(f\"Element {target} found at index {result}\")\nelse:\n    print(f\"Element {target} not found in the array\")\n```\n\n### How it works\n\n1. **Initialization**: We initialize two pointers, `left` and `right`, to the start and end of the array, respectively.\n2. **Loop condition**: We continue the loop as long as `left` is less than or equal to `right`.\n3. **Midpoint calculation**: We calculate the midpoint `mid` of the current range using the formula `(left + right) // 2`.\n4. **Comparison**: We compare the value at the midpoint `arr[mid]` with the `target` value.\n\t* If they are equal, we return the midpoint index.\n\t* If `arr[mid]` is less than the `target`, we move the `left` pointer to `mid + 1` to search the right half.\n\t* If `arr[mid]` is greater than the `target`, we move the `right` pointer to `mid - 1` to search the left half.\n5. **Repeat**: We repeat steps 3-4 until the loop condition is met or the `target` is found.\n6. **Return**: If the `target` is not found, we return -1 to indicate that the element is not in the array.\n\n### Time complexity\n\nThe time complexity of this binary search algorithm is O(log n), where n is the length of the input array. This is because we divide the search space in half at each iteration, reducing the number of comparisons needed to find the target value.",
  "timestamp": "2026-02-11T08:33:56.915484",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}