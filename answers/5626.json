{
  "prompt": "Create a program to find an element in a sorted list using the binary search algorithm.",
  "answer": "Here's an example implementation of the binary search algorithm in Python:\n\n```python\ndef binary_search(arr, target):\n    \"\"\"\n    Searches for an element in a sorted list using the binary search algorithm.\n\n    Args:\n    arr (list): The sorted list to search.\n    target: The element to search for.\n\n    Returns:\n    int: The index of the target element if found, -1 otherwise.\n    \"\"\"\n    low, high = 0, len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\n# Example usage:\narr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\ntarget = 23\n\nresult = binary_search(arr, target)\n\nif result != -1:\n    print(f\"Element {target} is present at index {result}.\")\nelse:\n    print(f\"Element {target} is not present in the list.\")\n```\n\n### How it Works:\n\n1.  **Initialization:** We start by initializing two pointers, `low` and `high`, to the start and end indices of the list, respectively.\n2.  **Midpoint Calculation:** We calculate the midpoint of the current range using the formula `(low + high) // 2`.\n3.  **Comparison:** We compare the element at the midpoint index to the target element.\n    *   If they match, we return the midpoint index as the target element is found.\n    *   If the midpoint element is less than the target, we adjust the `low` pointer to `mid + 1` to search the right half.\n    *   If the midpoint element is greater than the target, we adjust the `high` pointer to `mid - 1` to search the left half.\n4.  **Iteration:** We repeat steps 2-3 until the target element is found or the search range becomes empty (`low > high`).\n5.  **Result:** If the target element is not found after the search, we return -1 to indicate its absence.\n\n### Time Complexity:\n\nThe binary search algorithm has a time complexity of O(log n), where n is the number of elements in the list. This makes it more efficient than linear search (O(n)) for large sorted lists.\n\n### Space Complexity:\n\nThe binary search algorithm has a space complexity of O(1), as it only uses a constant amount of space to store the pointers and the midpoint index.",
  "timestamp": "2026-02-11T15:53:53.911880",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}