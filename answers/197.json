{
  "prompt": "Write a program that uses a while loop to find an element in a sorted list using the Binary Search algorithm.",
  "answer": "Here is a simple implementation of the Binary Search algorithm in Python:\n```python\ndef binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1  # Return -1 if the target is not found\n\n# Example usage:\nsorted_list = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\ntarget = 23\nresult = binary_search(sorted_list, target)\n\nif result != -1:\n    print(f\"Element {target} found at index {result}.\")\nelse:\n    print(f\"Element {target} not found in the list.\")\n```\nIn this code:\n\n1.  We define a `binary_search` function that takes a sorted list and a target element as arguments.\n2.  We initialize two pointers, `low` and `high`, to the start and end of the list, respectively.\n3.  We enter a while loop, which continues until `low` is greater than `high`.\n4.  Inside the loop, we calculate the middle index `mid` and compare the element at `mid` with the target.\n5.  If the element at `mid` matches the target, we return the `mid` index.\n6.  If the element at `mid` is less than the target, we update `low` to `mid + 1` to search in the right half.\n7.  If the element at `mid` is greater than the target, we update `high` to `mid - 1` to search in the left half.\n8.  If the loop ends without finding the target, we return -1 to indicate that the element is not in the list.\n9.  Finally, we demonstrate the function's usage with an example sorted list and target element, printing the result accordingly.\n\nThis implementation has a time complexity of O(log n), making it efficient for searching large sorted lists.",
  "timestamp": "2026-02-10T13:45:15.691621",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}