{
  "prompt": "Find the minimum window substring that contains all characters of a given string",
  "answer": "**Minimum Window Substring Problem**\n=====================================\n\nGiven two strings `s` and `t`, find the minimum window substring of `s` that contains all characters of `t`. If no such window exists, return an empty string.\n\n**Solution**\n------------\n\nWe will use a sliding window approach to solve this problem. The idea is to maintain a window of characters in `s` that contains all characters of `t`.\n\n### Code\n\n```python\nfrom collections import Counter\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring of `s` that contains all characters of `t`.\n\n    Args:\n    s (str): The string to search for the minimum window.\n    t (str): The string containing the characters to search for.\n\n    Returns:\n    str: The minimum window substring of `s` that contains all characters of `t`. If no such window exists, returns an empty string.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    # Create a counter for the characters in `t`\n    t_count = Counter(t)\n\n    # Initialize the required character count to the length of `t`\n    required = len(t_count)\n\n    # Initialize the left and right pointers of the window\n    left = 0\n\n    # Initialize the minimum window substring and its length\n    min_len = float('inf')\n    min_window = \"\"\n\n    # Initialize the formed character count to 0\n    formed = 0\n\n    # Create a counter for the characters in the current window\n    window_counts = {}\n\n    # Iterate over the string `s`\n    for right in range(len(s)):\n        # Add the character at the right pointer to the window counter\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        # If the character is in `t` and its count in the window is equal to its count in `t`, increment the formed count\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed += 1\n\n        # While the window contains all characters of `t` and the left pointer is less than the right pointer\n        while left <= right and formed == required:\n            # Update the minimum window substring if the current window is smaller\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_window = s[left:right + 1]\n\n            # Remove the character at the left pointer from the window counter\n            character = s[left]\n            window_counts[character] -= 1\n\n            # If the character is in `t` and its count in the window is less than its count in `t`, decrement the formed count\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed -= 1\n\n            # Move the left pointer to the right\n            left += 1\n\n    # Return the minimum window substring\n    return min_window\n\n# Example usage:\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window(s, t))  # Output: \"BANC\"\n```\n\n**Explanation**\n---------------\n\n1.  We start by creating a counter for the characters in `t`.\n2.  We initialize the required character count to the length of `t`.\n3.  We initialize the left and right pointers of the window to 0.\n4.  We initialize the minimum window substring and its length to an empty string and infinity, respectively.\n5.  We create a counter for the characters in the current window.\n6.  We iterate over the string `s`, adding each character to the window counter.\n7.  If the character is in `t` and its count in the window is equal to its count in `t`, we increment the formed count.\n8.  While the window contains all characters of `t` and the left pointer is less than the right pointer, we update the minimum window substring if the current window is smaller.\n9.  We remove the character at the left pointer from the window counter and decrement the formed count if necessary.\n10. We move the left pointer to the right.\n11. Finally, we return the minimum window substring.\n\n**Time Complexity**\n--------------------\n\nThe time complexity of this solution is O(|s| + |t|), where |s| and |t| are the lengths of the strings `s` and `t`, respectively.\n\n**Space Complexity**\n---------------------\n\nThe space complexity of this solution is O(|t|), where |t| is the length of the string `t`.",
  "timestamp": "2026-02-10T13:05:46.731939",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}