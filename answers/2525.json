{
  "prompt": "Implement a binary search algorithm to find a specific element in a sorted list of numbers",
  "answer": "**Binary Search Algorithm**\n==========================\n\n### Overview\n\nBinary search is an efficient algorithm for finding a specific element in a sorted list of numbers. It works by repeatedly dividing the list in half until the target element is found.\n\n### Code Implementation\n\n```python\ndef binary_search(sorted_list, target):\n    \"\"\"\n    Searches for a target element in a sorted list using binary search.\n\n    Args:\n        sorted_list (list): A sorted list of numbers.\n        target (int): The target element to search for.\n\n    Returns:\n        int: The index of the target element if found, -1 otherwise.\n    \"\"\"\n    low = 0\n    high = len(sorted_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\n# Example usage\nif __name__ == \"__main__\":\n    sorted_list = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target = 23\n\n    result = binary_search(sorted_list, target)\n\n    if result != -1:\n        print(f\"Target element {target} found at index {result}.\")\n    else:\n        print(f\"Target element {target} not found in the list.\")\n```\n\n### Explanation\n\n1.  Initialize two pointers, `low` and `high`, to the start and end of the sorted list, respectively.\n2.  Calculate the middle index `mid` using the formula `(low + high) // 2`.\n3.  Compare the middle element `sorted_list[mid]` with the target element `target`.\n4.  If they are equal, return the middle index `mid`.\n5.  If the middle element is less than the target, update `low` to `mid + 1` to search the right half of the list.\n6.  If the middle element is greater than the target, update `high` to `mid - 1` to search the left half of the list.\n7.  Repeat steps 2-6 until `low` is greater than `high`.\n8.  If the target element is not found, return -1 to indicate that it is not in the list.\n\n### Time Complexity\n\nThe time complexity of the binary search algorithm is O(log n), where n is the length of the sorted list. This is because the algorithm divides the search space in half at each step, resulting in a logarithmic number of comparisons.\n\n### Space Complexity\n\nThe space complexity of the binary search algorithm is O(1), as it only uses a constant amount of space to store the pointers and the target element.",
  "timestamp": "2026-02-10T23:18:06.265361",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}