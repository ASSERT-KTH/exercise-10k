{
  "prompt": "Write a program that evaluates an expression with mixed arithmetic operations.",
  "answer": "**Expression Evaluator Program**\n================================\n\n### Overview\n\nThis program evaluates an expression with mixed arithmetic operations using a stack-based approach.\n\n### Code\n```python\ndef evaluate_expression(expression):\n    \"\"\"\n    Evaluates an expression with mixed arithmetic operations.\n\n    Args:\n    expression (str): The expression to evaluate.\n\n    Returns:\n    float: The result of the evaluation.\n    \"\"\"\n    # Define operator precedence\n    precedence = {\n        '+': 1,\n        '-': 1,\n        '*': 2,\n        '/': 2\n    }\n\n    # Split the expression into tokens\n    tokens = expression.replace('(', ' ( ').replace(')', ' ) ').split()\n\n    # Initialize operator and operand stacks\n    operator_stack = []\n    operand_stack = []\n\n    # Iterate through tokens\n    for token in tokens:\n        # Check if token is an operand\n        if token.replace('.', '', 1).isdigit():\n            operand_stack.append(float(token))\n        # Check if token is an operator\n        elif token in precedence:\n            # Pop operators with higher or equal precedence\n            while (operator_stack and\n                   operator_stack[-1] in precedence and\n                   precedence[operator_stack[-1]] >= precedence[token]):\n                apply_operator(operator_stack, operand_stack)\n            operator_stack.append(token)\n        # Check if token is a left parenthesis\n        elif token == '(':\n            operator_stack.append(token)\n        # Check if token is a right parenthesis\n        elif token == ')':\n            # Pop operators until left parenthesis is found\n            while operator_stack[-1] != '(':\n                apply_operator(operator_stack, operand_stack)\n            operator_stack.pop()  # Remove left parenthesis\n\n    # Apply remaining operators\n    while operator_stack:\n        apply_operator(operator_stack, operand_stack)\n\n    # Return the final result\n    return operand_stack[0]\n\n\ndef apply_operator(operator_stack, operand_stack):\n    \"\"\"\n    Applies the top operator to the top two operands.\n\n    Args:\n    operator_stack (list): The stack of operators.\n    operand_stack (list): The stack of operands.\n    \"\"\"\n    # Pop the top operator and operands\n    operator = operator_stack.pop()\n    operand2 = operand_stack.pop()\n    operand1 = operand_stack.pop()\n\n    # Apply the operator\n    if operator == '+':\n        result = operand1 + operand2\n    elif operator == '-':\n        result = operand1 - operand2\n    elif operator == '*':\n        result = operand1 * operand2\n    elif operator == '/':\n        result = operand1 / operand2\n\n    # Push the result back onto the operand stack\n    operand_stack.append(result)\n\n\n# Example usage\nif __name__ == \"__main__\":\n    expression = \"2 + 3 * (4 - 1)\"\n    result = evaluate_expression(expression)\n    print(f\"The result of '{expression}' is {result}\")\n```\n\n### Explanation\n\n1.  The program uses a stack-based approach to evaluate the expression.\n2.  It defines operator precedence to determine the order of operations.\n3.  The `evaluate_expression` function splits the input expression into tokens and initializes operator and operand stacks.\n4.  It iterates through the tokens, applying operators and operands to the stacks based on precedence and parentheses.\n5.  The `apply_operator` function applies the top operator to the top two operands and pushes the result back onto the operand stack.\n6.  Finally, the program returns the final result from the operand stack.\n\n### Advice\n\n*   This implementation assumes that the input expression is well-formed and follows the standard order of operations.\n*   You can extend this program to handle more advanced mathematical expressions, such as those with exponentiation or logarithms, by adding additional operators and precedence rules.\n*   Consider using a more robust parsing library or framework for complex expressions or to handle errors and edge cases.",
  "timestamp": "2026-02-11T13:30:48.470257",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}