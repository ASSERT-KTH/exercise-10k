{
  "prompt": "Write a program that takes two strings as input and returns the minimum window substring that contains all the characters of the second string.",
  "answer": "Here is the code that implements the specified solution:\n```\nfrom collections import Counter\n\ndef min_window_substring(s1, s2):\n    if not s1 or not s2:\n        return None\n\n    s2_counter = Counter(s2)\n    required_chars = len(s2_counter)\n    formed_chars = 0\n\n    window_counts = {}\n    ans = float(\"inf\"), None, None\n    window_start = 0\n\n    for window_end in range(len(s1)):\n        char = s1[window_end]\n        window_counts[char] = window_counts.get(char, 0) + 1\n\n        if char in s2_counter and window_counts[char] == s2_counter[char]:\n            formed_chars += 1\n\n        while window_start <= window_end and formed_chars == required_chars:\n            char = s1[window_start]\n\n            if window_end - window_start + 1 < ans[0]:\n                ans = (window_end - window_start + 1, window_start, window_end)\n\n            window_counts[char] -= 1\n            if char in s2_counter and window_counts[char] < s2_counter[char]:\n                formed_chars -= 1\n\n            window_start += 1\n\n    return ans[1:] if ans[0] != float(\"inf\") else None\n```\nHere's an explanation of the code:\n\nThe function `min_window_substring` takes two strings `s1` and `s2` as input. It first checks if either of the input strings is empty, and if so, returns `None`.\n\nIt then creates a counter `s2_counter` to count the frequency of each character in `s2`. The `required_chars` variable is set to the number of unique characters in `s2_counter`, which represents the number of characters that need to be covered in the substring.\n\nThe `window_counts` dictionary is used to keep track of the frequency of each character in the current window. The `formed_chars` variable is used to keep track of the number of characters that have been formed in the current window.\n\nThe `ans` variable is initialized to a tuple containing `float(\"inf\")` (representing infinity), `None`, and `None`. This variable will store the minimum window substring that covers all characters in `s2`.\n\nThe outer loop iterates over the characters in `s1`, and for each character, it increments the corresponding count in `window_counts`. If the character is in `s2_counter` and the count in `window_counts` matches the count in `s2_counter`, it increments `formed_chars`.\n\nThe inner while loop runs until `formed_chars` is equal to `required_chars`, which means that all characters in `s2` have been covered in the current window. In each iteration, it decrements the count of the character at the start of the window in `window_counts`, and if the count becomes less than the count in `s2_counter`, it decrements `formed_chars`. It then increments `window_start` to move the window to the right.\n\nIf the length of the current window is less than the length stored in `ans`, it updates `ans` with the new window.\n\nFinally, the function returns the minimum window substring that covers all characters in `s2` if it exists, or `None` otherwise. The returned substring is in the format `(start, end)`, where `start` and `end` are the indices of the substring in `s1`.",
  "timestamp": "2026-02-10T19:58:11.297436",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}