{
  "prompt": "Create a program to find the maximum flow in a flow network using the Ford-Fulkerson algorithm.",
  "answer": "**Maximum Flow in a Flow Network using Ford-Fulkerson Algorithm**\n\nThe Ford-Fulkerson algorithm is a method for computing the maximum flow in a flow network. The algorithm works by finding an augmenting path in the residual graph and augmenting the flow along this path until no more augmenting paths can be found.\n\n### Code Implementation\n\nHere's an implementation of the Ford-Fulkerson algorithm in Python:\n\n```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    # Using BFS as a searching algorithm\n    def BFS(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return True if visited[t] else False\n\n    # Applying the Ford-Fulkerson algorithm\n    def FordFulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n        while self.BFS(source, sink, parent):\n            path_flow = float(\"Inf\")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n            max_flow += path_flow\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n        return max_flow\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = [[0, 16, 13, 0, 0, 0],\n             [0, 0, 10, 12, 0, 0],\n             [0, 4, 0, 0, 14, 0],\n             [0, 0, 9, 0, 0, 20],\n             [0, 0, 0, 7, 0, 4],\n             [0, 0, 0, 0, 0, 0]]\n\n    g = Graph(graph)\n    source = 0\n    sink = 5\n    print(\"Maximum flow:\", g.FordFulkerson(source, sink))\n```\n\n### Explanation\n\n1.  **Graph Representation:** We represent the flow network as a directed graph where each edge has a capacity.\n2.  **Ford-Fulkerson Algorithm:**\n\n    *   We use a breadth-first search (BFS) to find an augmenting path in the residual graph.\n    *   We start at the source node and explore neighboring nodes until we reach the sink node or all reachable nodes have been visited.\n    *   If we find an augmenting path, we calculate the minimum capacity along this path (bottleneck capacity).\n    *   We then augment the flow along this path by subtracting the bottleneck capacity from the forward edges and adding it to the backward edges.\n    *   We repeat this process until no more augmenting paths can be found.\n3.  **Implementation:**\n\n    *   We define a `Graph` class to represent the flow network.\n    *   The `BFS` method is used to find an augmenting path in the residual graph.\n    *   The `FordFulkerson` method applies the Ford-Fulkerson algorithm to compute the maximum flow.\n4.  **Example Usage:**\n\n    *   We create a sample flow network represented as an adjacency matrix.\n    *   We instantiate the `Graph` class with the sample network and specify the source and sink nodes.\n    *   We call the `FordFulkerson` method to compute the maximum flow and print the result.\n\n### Time Complexity\n\nThe time complexity of the Ford-Fulkerson algorithm is O(max_flow \\* E), where max_flow is the maximum flow in the network and E is the number of edges. In the worst case, the algorithm may need to augment the flow along each edge once for each unit of flow, resulting in a time complexity of O(VE^2), where V is the number of vertices. However, with a more efficient implementation using a more advanced searching algorithm like Dijkstra's or Bellman-Ford, the time complexity can be improved to O(VE log V).",
  "timestamp": "2026-02-11T15:56:40.047434",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}