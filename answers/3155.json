{
  "prompt": "Write a function to check if a linked list has a cycle.",
  "answer": "**Detecting Cycles in Linked Lists**\n=====================================\n\nHere's an example of a function in Python that checks if a linked list has a cycle:\n\n```python\nclass Node:\n    \"\"\"Represents a node in a linked list.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef has_cycle(head):\n    \"\"\"\n    Checks if a linked list has a cycle.\n\n    Args:\n    head (Node): The head of the linked list.\n\n    Returns:\n    bool: True if the linked list has a cycle, False otherwise.\n    \"\"\"\n    if head is None or head.next is None:\n        return False\n\n    slow = head\n    fast = head.next\n\n    while slow != fast:\n        if fast is None or fast.next is None:\n            return False\n        slow = slow.next\n        fast = fast.next.next\n\n    return True\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a linked list with a cycle\n    node1 = Node(1)\n    node2 = Node(2)\n    node3 = Node(3)\n    node4 = Node(4)\n\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node2  # Create a cycle\n\n    print(has_cycle(node1))  # Output: True\n\n    # Create a linked list without a cycle\n    node5 = Node(5)\n    node6 = Node(6)\n    node7 = Node(7)\n\n    node5.next = node6\n    node6.next = node7\n\n    print(has_cycle(node5))  # Output: False\n```\n\n**Explanation**\n---------------\n\nThis solution uses the Floyd's Tortoise and Hare algorithm, also known as the \"slow and fast pointers\" technique. The idea is to have two pointers, `slow` and `fast`, that move through the linked list at different speeds. If there is a cycle, the `fast` pointer will eventually catch up to the `slow` pointer. If there is no cycle, the `fast` pointer will reach the end of the linked list.\n\n*   We first check if the `head` is `None` or if the `head` has no `next` node. If either condition is true, we return `False` because a cycle cannot exist in an empty or single-node linked list.\n*   We initialize the `slow` pointer to the `head` and the `fast` pointer to the `head.next`.\n*   We enter a loop where we move the `slow` pointer one step at a time and the `fast` pointer two steps at a time.\n*   If the `fast` pointer reaches the end of the linked list (`fast` is `None` or `fast.next` is `None`), we return `False` because there is no cycle.\n*   If the `slow` and `fast` pointers meet at some point, we return `True` because there is a cycle.\n\n**Time Complexity**\n--------------------\n\nThe time complexity of this solution is O(n), where n is the number of nodes in the linked list. This is because in the worst-case scenario, we need to traverse the entire linked list to detect a cycle.\n\n**Space Complexity**\n---------------------\n\nThe space complexity of this solution is O(1), which means the space required does not change with the size of the input linked list. We only use a constant amount of space to store the `slow` and `fast` pointers.",
  "timestamp": "2026-02-11T01:56:55.645740",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}