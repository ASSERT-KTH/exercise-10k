{
  "prompt": "Implement a shortest path algorithm to find the minimum distance between two nodes in a graph",
  "answer": "**Dijkstra's Shortest Path Algorithm Implementation**\n\n### Overview\n\nDijkstra's algorithm is a popular choice for finding the shortest path between two nodes in a graph. It works by maintaining a priority queue of nodes, where the priority of each node is its minimum distance from the source node.\n\n### Code Implementation\n\n```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, source, target):\n    \"\"\"\n    Dijkstra's shortest path algorithm implementation.\n\n    Args:\n    graph (dict): Adjacency list representation of the graph.\n    source (node): Source node.\n    target (node): Target node.\n\n    Returns:\n    distance (float): Minimum distance between the source and target nodes.\n    path (list): Shortest path from the source to the target node.\n    \"\"\"\n    # Initialize distances and previous nodes\n    distances = {node: sys.maxsize for node in graph}\n    previous = {node: None for node in graph}\n    distances[source] = 0\n\n    # Priority queue to store nodes to be processed\n    priority_queue = [(0, source)]\n\n    while priority_queue:\n        # Extract the node with the minimum distance\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        # If the current node is the target node, construct the path\n        if current_node == target:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = previous[current_node]\n            path.reverse()\n            return distances[target], path\n\n        # If the current distance is greater than the known distance, skip\n        if current_distance > distances[current_node]:\n            continue\n\n        # Iterate over the neighbors of the current node\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            # If a shorter path is found, update the distance and previous node\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous[neighbor] = current_node\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    # If there is no path to the target node, return infinity and an empty path\n    return sys.maxsize, []\n\n# Example usage\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\nsource_node = 'A'\ntarget_node = 'D'\n\ndistance, path = dijkstra(graph, source_node, target_node)\nprint(f\"Minimum distance from {source_node} to {target_node}: {distance}\")\nprint(f\"Shortest path from {source_node} to {target_node}: {path}\")\n```\n\n### Explanation\n\n1.  **Initialization**: The algorithm starts by initializing the distances to all nodes as infinity, except for the source node, which is set to 0. The previous nodes are also initialized as None.\n2.  **Priority Queue**: A priority queue is used to store nodes to be processed, where the priority of each node is its minimum distance from the source node.\n3.  **Node Extraction**: The node with the minimum distance is extracted from the priority queue.\n4.  **Target Node**: If the extracted node is the target node, the algorithm constructs the shortest path by backtracking from the target node to the source node.\n5.  **Neighbor Iteration**: The algorithm iterates over the neighbors of the extracted node and calculates the tentative distance to each neighbor.\n6.  **Distance Update**: If a shorter path to a neighbor is found, the algorithm updates the distance and previous node for that neighbor.\n7.  **Priority Queue Update**: The updated neighbor is added to the priority queue.\n8.  **Termination**: The algorithm terminates when the target node is reached or the priority queue is empty.\n\n### Time Complexity\n\n*   The time complexity of Dijkstra's algorithm is O((V + E) \\* logV) in the worst case, where V is the number of vertices (nodes) and E is the number of edges.\n*   The space complexity is O(V + E), as the algorithm needs to store the distances, previous nodes, and the priority queue.",
  "timestamp": "2026-02-10T23:20:32.982081",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}