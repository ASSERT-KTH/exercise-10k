{
  "prompt": "Create a program that simulates a chat server where multiple clients can connect and send messages to each other.",
  "answer": "Here's a simple implementation of a chat server and client using Python's socket library.\n\n**Server Code (chat_server.py)**\n```python\nimport socket\nimport threading\n\nclass ChatServer:\n    def __init__(self, host='127.0.0.1', port=55555):\n        self.host = host\n        self.port = port\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server.bind((self.host, self.port))\n        self.server.listen()\n        self.clients = []\n        self.nicknames = []\n\n    def broadcast(self, message):\n        for client in self.clients:\n            client.send(message)\n\n    def handle(self, client):\n        while True:\n            try:\n                message = client.recv(1024)\n                self.broadcast(message)\n            except:\n                index = self.clients.index(client)\n                self.clients.remove(client)\n                client.close()\n                nickname = self.nicknames[index]\n                self.nicknames.remove(nickname)\n                self.broadcast(f'{nickname} left the chat!'.encode('ascii'))\n                break\n\n    def receive(self):\n        while True:\n            client, address = self.server.accept()\n            print(f\"Connected with {str(address)}\")\n\n            client.send('NICK'.encode('ascii'))\n            nickname = client.recv(1024).decode('ascii')\n            self.nicknames.append(nickname)\n            self.clients.append(client)\n\n            print(f'Nickname of the client is {nickname}!')\n            self.broadcast(f'{nickname} joined the chat!'.encode('ascii'))\n            client.send('Connected to the server!'.encode('ascii'))\n\n            thread = threading.Thread(target=self.handle, args=(client,))\n            thread.start()\n\n    def run(self):\n        print(\"Server Started!\")\n        self.receive()\n\n\nif __name__ == \"__main__\":\n    ChatServer().run()\n```\n\n**Client Code (chat_client.py)**\n```python\nimport socket\nimport threading\n\nclass ChatClient:\n    def __init__(self, host='127.0.0.1', port=55555):\n        self.host = host\n        self.port = port\n        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.client.connect((self.host, self.port))\n\n    def receive(self):\n        while True:\n            try:\n                message = self.client.recv(1024).decode('ascii')\n                if message == 'NICK':\n                    self.client.send(input(\"Choose a nickname: \").encode('ascii'))\n                else:\n                    print(message)\n            except:\n                print(\"An error occurred!\")\n                self.client.close()\n                break\n\n    def write(self):\n        while True:\n            message = f'{input(\"\")}'\n            self.client.send(message.encode('ascii'))\n\n    def run(self):\n        receive_thread = threading.Thread(target=self.receive)\n        receive_thread.start()\n        write_thread = threading.Thread(target=self.write)\n        write_thread.start()\n\n\nif __name__ == \"__main__\":\n    ChatClient().run()\n```\n\n**How to Run the Program**\n\n1. Open two or more terminal windows.\n2. In one window, run the server by typing `python chat_server.py`.\n3. In the other windows, run the clients by typing `python chat_client.py`.\n4. Each client will be prompted to choose a nickname.\n5. After choosing a nickname, the client can start sending messages to the chat server.\n6. The chat server will broadcast the messages to all connected clients.\n\n**Note**: This is a basic implementation of a chat server and client. It does not include any error handling or security measures. In a real-world application, you would need to add these features to ensure the reliability and security of your chat server.",
  "timestamp": "2026-02-11T08:57:33.075505",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}