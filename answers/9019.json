{
  "prompt": "Create a function that uses generators to produce a sequence of values on-the-fly.",
  "answer": "### Generator Function\n#### Overview\nThe following is an example of a function that uses generators to produce a sequence of values on-the-fly. This function generates the Fibonacci sequence, a series of numbers where a number is the sum of the two preceding ones, usually starting with 0 and 1.\n\n#### Code\n```python\ndef fibonacci(n):\n    \"\"\"\n    Generates the Fibonacci sequence up to the nth number.\n\n    Args:\n        n (int): The number of Fibonacci numbers to generate.\n\n    Yields:\n        int: The next number in the Fibonacci sequence.\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n\n# Example usage:\nif __name__ == \"__main__\":\n    n = 10  # Generate the first 10 Fibonacci numbers\n    print(\"Fibonacci sequence up to {} numbers:\".format(n))\n    for i, num in enumerate(fibonacci(n)):\n        print(\"F({}) = {}\".format(i, num))\n```\n\n#### Explanation\n1.  The `fibonacci` function takes an integer `n` as input, representing the number of Fibonacci numbers to generate.\n2.  It initializes two variables, `a` and `b`, to 0 and 1, which are the first two numbers in the Fibonacci sequence.\n3.  The function uses a `for` loop to generate the Fibonacci sequence up to the nth number.\n4.  Inside the loop, the `yield` statement produces the current value of `a` and pauses the function's execution until the next value is requested.\n5.  After yielding the current value, the function updates `a` and `b` to the next two numbers in the sequence.\n6.  In the example usage, we call the `fibonacci` function with `n = 10` to generate the first 10 Fibonacci numbers and print them.\n\n#### Advantages\nUsing generators to produce sequences on-the-fly offers several advantages, including:\n\n*   **Memory efficiency**: Generators store only the current state of the sequence, making them more memory-efficient than storing the entire sequence in a list or array.\n*   **Lazy evaluation**: Generators only compute the next value when requested, which can improve performance when dealing with large or complex sequences.\n*   **Flexibility**: Generators can be used to implement a wide range of sequence types, from simple arithmetic sequences to complex algorithms like the Fibonacci sequence.",
  "timestamp": "2026-02-12T02:32:20.653148",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}