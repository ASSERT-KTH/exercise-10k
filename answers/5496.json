{
  "prompt": "Write a program to check if a given graph contains a cycle.",
  "answer": "**Detecting Cycles in Graphs**\n================================\n\nHere's an example implementation in Python to check if a given graph contains a cycle using Depth-First Search (DFS).\n\n### Code\n```python\nfrom typing import Dict, List\n\ndef has_cycle(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Checks if a given graph contains a cycle.\n\n    Args:\n    graph: A dictionary representing the graph, where each key is a node and its corresponding value is a list of adjacent nodes.\n\n    Returns:\n    bool: True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = set()\n    recursion_stack = set()\n\n    def dfs(node: int) -> bool:\n        visited.add(node)\n        recursion_stack.add(node)\n\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in recursion_stack:\n                return True\n\n        recursion_stack.remove(node)\n        return False\n\n    for node in graph:\n        if node not in visited:\n            if dfs(node):\n                return True\n\n    return False\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create a sample graph with a cycle\n    graph_with_cycle = {\n        0: [1, 2],\n        1: [2],\n        2: [0, 3],\n        3: [3]\n    }\n\n    # Create a sample graph without a cycle\n    graph_without_cycle = {\n        0: [1, 2],\n        1: [2],\n        2: [],\n        3: []\n    }\n\n    print(\"Graph with cycle:\", has_cycle(graph_with_cycle))  # Expected output: True\n    print(\"Graph without cycle:\", has_cycle(graph_without_cycle))  # Expected output: False\n```\n\n### Explanation\n\n1.  We define a function `has_cycle` that takes a graph represented as a dictionary where each key is a node, and its corresponding value is a list of adjacent nodes.\n2.  We use two sets, `visited` and `recursion_stack`, to keep track of visited nodes and nodes in the current recursion stack, respectively.\n3.  We define a nested function `dfs` that performs the depth-first search. It marks the current node as visited and adds it to the recursion stack.\n4.  The `dfs` function recursively explores neighboring nodes. If it encounters a node that is already in the recursion stack, it means a cycle is detected, and the function returns `True`.\n5.  After exploring all neighbors of a node, we remove it from the recursion stack.\n6.  The `has_cycle` function iterates over all nodes in the graph and calls the `dfs` function for unvisited nodes.\n7.  If the `dfs` function returns `True` for any node, the `has_cycle` function returns `True`, indicating that the graph contains a cycle. Otherwise, it returns `False`.\n\n### Time Complexity\n\n*   The time complexity of this algorithm is O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph, since we visit each node and edge once.\n\n### Space Complexity\n\n*   The space complexity is O(V), as we use sets to store visited nodes and nodes in the recursion stack, which can contain up to V nodes in the worst case.",
  "timestamp": "2026-02-11T15:19:12.318575",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}