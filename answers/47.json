{
  "prompt": "Reverse a singly linked list",
  "answer": "**Reversing a Singly Linked List**\n=====================================\n\n### Problem Statement\n\nGiven a singly linked list, reverse the order of its nodes.\n\n### Solution\n\nWe can solve this problem by iterating over the linked list and reversing the `next` pointers of each node.\n\n#### Code\n```python\nclass Node:\n    \"\"\"A node in the linked list.\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    \"\"\"A singly linked list.\"\"\"\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        \"\"\"Append a new node to the end of the list.\"\"\"\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        current = self.head\n        while current.next:\n            current = current.next\n        current.next = new_node\n\n    def reverse(self):\n        \"\"\"Reverse the linked list.\"\"\"\n        prev_node = None\n        current = self.head\n        while current:\n            next_node = current.next\n            current.next = prev_node\n            prev_node = current\n            current = next_node\n        self.head = prev_node\n\n    def print_list(self):\n        \"\"\"Print the linked list.\"\"\"\n        current = self.head\n        while current:\n            print(current.data, end=\" \")\n            current = current.next\n        print()\n\n# Example usage\nlinked_list = LinkedList()\nlinked_list.append(1)\nlinked_list.append(2)\nlinked_list.append(3)\nlinked_list.append(4)\nlinked_list.append(5)\n\nprint(\"Original Linked List:\")\nlinked_list.print_list()\n\nlinked_list.reverse()\n\nprint(\"Reversed Linked List:\")\nlinked_list.print_list()\n```\n\n### Explanation\n\n1. We start by initializing three pointers: `prev_node`, `current`, and `next_node`.\n2. We set `prev_node` to `None` and `current` to the head of the list.\n3. We iterate over the list until `current` is `None`.\n4. In each iteration, we do the following:\n\t* Store the next node in `next_node`.\n\t* Reverse the `next` pointer of the current node by setting `current.next` to `prev_node`.\n\t* Move `prev_node` and `current` one step forward.\n5. After the loop, we update the head of the list to point to the new first node, which is `prev_node`.\n\n### Time Complexity\n\nThe time complexity of this solution is O(n), where n is the number of nodes in the linked list, since we only traverse the list once.\n\n### Space Complexity\n\nThe space complexity is O(1), since we only use a constant amount of space to store the pointers.",
  "timestamp": "2026-02-10T13:06:05.408109",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}