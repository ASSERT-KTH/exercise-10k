{
  "prompt": "Write a program to solve the fractional knapsack problem",
  "answer": "Fractional Knapsack Problem\n==========================\n\nThe fractional knapsack problem is a problem in combinatorial optimization. Given a set of items, each with a weight and a value, determine the subset of these items to include in a knapsack of limited capacity that maximizes the total value.\n\n### Algorithm\n\nThe algorithm used to solve the fractional knapsack problem is a greedy algorithm. The idea is to calculate the value-to-weight ratio for each item and sort them in descending order. Then, we start including the items with the highest ratio in the knapsack until the knapsack is full.\n\n### Code\n\nHere is a Python implementation of the fractional knapsack problem:\n\n```python\nclass Item:\n    \"\"\"Represents an item with a weight and a value.\"\"\"\n\n    def __init__(self, weight, value):\n        self.weight = weight\n        self.value = value\n        self.ratio = value / weight\n\n    def __repr__(self):\n        return f\"Item(weight={self.weight}, value={self.value}, ratio={self.ratio})\"\n\n\ndef fractional_knapsack(items, capacity):\n    \"\"\"\n    Solves the fractional knapsack problem.\n\n    Args:\n    items (list of Item): The items to consider.\n    capacity (float): The capacity of the knapsack.\n\n    Returns:\n    float: The maximum total value.\n    list of Item: The items to include in the knapsack.\n    \"\"\"\n    # Sort the items by their value-to-weight ratio in descending order\n    items.sort(key=lambda item: item.ratio, reverse=True)\n\n    total_value = 0.0\n    included_items = []\n\n    for item in items:\n        if capacity >= item.weight:\n            # Include the entire item\n            capacity -= item.weight\n            total_value += item.value\n            included_items.append((item, 1.0))  # (item, fraction)\n        else:\n            # Include a fraction of the item\n            fraction = capacity / item.weight\n            total_value += item.value * fraction\n            included_items.append((item, fraction))\n            break\n\n    return total_value, included_items\n\n\n# Example usage\nif __name__ == \"__main__\":\n    items = [\n        Item(10, 60),\n        Item(20, 100),\n        Item(30, 120),\n    ]\n    capacity = 50.0\n\n    max_value, included_items = fractional_knapsack(items, capacity)\n\n    print(\"Maximum total value:\", max_value)\n    print(\"Included items:\")\n    for item, fraction in included_items:\n        print(f\"  - {item} (fraction: {fraction})\")\n```\n\n### Explanation\n\n1.  We define a class `Item` to represent each item with a weight and a value.\n2.  The `fractional_knapsack` function takes a list of items and the knapsack capacity as input.\n3.  We sort the items by their value-to-weight ratio in descending order.\n4.  We iterate over the sorted items and include them in the knapsack until it is full.\n5.  If an item can be fully included, we subtract its weight from the capacity and add its value to the total value.\n6.  If an item cannot be fully included, we calculate the fraction of the item that can be included and update the total value accordingly.\n7.  Finally, we return the maximum total value and the included items along with their fractions.\n\n### Time Complexity\n\nThe time complexity of this algorithm is O(n log n) due to the sorting step, where n is the number of items. The subsequent iteration over the items has a time complexity of O(n), which is dominated by the sorting step.",
  "timestamp": "2026-02-10T23:23:13.780379",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}