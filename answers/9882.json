{
  "prompt": "Write a program that simulates the Game of Life.",
  "answer": "**Game of Life Simulation**\n==========================\n\nThe Game of Life is a cellular automaton devised by the British mathematician John Horton Conway. The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input.\n\n### Rules of the Game\n\n1. **Survival**: Every cell that has two or three neighbors survives to the next generation.\n2. **Death by isolation**: Each cell with one or zero neighbors dies, as if by underpopulation.\n3. **Death by overpopulation**: Each cell with four or more neighbors dies, as if by overpopulation.\n4. **Reproduction**: Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\n### Implementation\n\nBelow is a Python implementation of the Game of Life using the Pygame library for visualization.\n\n```python\nimport pygame\nimport numpy as np\n\n# Window size\nWIDTH, HEIGHT = 800, 600\n\n# Cell size\nCELL_SIZE = 10\n\n# Colors\nALIVE_COLOR = (255, 255, 255)\nDEAD_COLOR = (0, 0, 0)\n\nclass GameOfLife:\n    def __init__(self, width, height, cell_size):\n        self.width = width\n        self.height = height\n        self.cell_size = cell_size\n        self.grid = np.random.choice([0,1], size=(height // cell_size, width // cell_size), p=[0.5, 0.5])\n\n    def draw(self, screen):\n        screen.fill(DEAD_COLOR)\n        for i in range(self.grid.shape[0]):\n            for j in range(self.grid.shape[1]):\n                if self.grid[i, j] == 1:\n                    pygame.draw.rect(screen, ALIVE_COLOR, (j * self.cell_size, i * self.cell_size, self.cell_size, self.cell_size))\n\n    def update(self):\n        new_grid = self.grid.copy()\n        for i in range(self.grid.shape[0]):\n            for j in range(self.grid.shape[1]):\n                live_neighbors = self.count_live_neighbors(i, j)\n                if self.grid[i, j] == 1 and (live_neighbors < 2 or live_neighbors > 3):\n                    new_grid[i, j] = 0\n                elif self.grid[i, j] == 0 and live_neighbors == 3:\n                    new_grid[i, j] = 1\n        self.grid = new_grid\n\n    def count_live_neighbors(self, i, j):\n        count = 0\n        for x in range(-1, 2):\n            for y in range(-1, 2):\n                col = (j + y + self.grid.shape[1]) % self.grid.shape[1]\n                row = (i + x + self.grid.shape[0]) % self.grid.shape[0]\n                count += self.grid[row, col]\n        count -= self.grid[i, j]\n        return count\n\ndef main():\n    pygame.init()\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n    clock = pygame.time.Clock()\n    game = GameOfLife(WIDTH, HEIGHT, CELL_SIZE)\n\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n\n        game.draw(screen)\n        pygame.display.flip()\n        game.update()\n        clock.tick(60)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Usage\n\n1. Install the required libraries: `pygame` and `numpy`.\n2. Run the script using Python.\n3. The Game of Life simulation will be displayed in a window.\n4. The simulation will update at a rate of 60 frames per second.\n5. You can close the window to exit the simulation.\n\nNote: This implementation uses a random initial state for the grid. You can modify the `__init__` method of the `GameOfLife` class to use a different initial state if desired.",
  "timestamp": "2026-02-12T10:13:37.415910",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}