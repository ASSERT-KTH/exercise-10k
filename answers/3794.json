{
  "prompt": "Write a function to solve the N-Queens problem and return all possible configurations of queens on a chessboard.",
  "answer": "**N-Queens Problem Solution**\n\nThe N-Queens problem is a classic backtracking problem where the goal is to place N queens on an NxN chessboard such that no two queens attack each other.\n\n### Code Solution\n```python\ndef solve_n_queens(n):\n    \"\"\"\n    Solves the N-Queens problem and returns all possible configurations of queens on a chessboard.\n\n    Args:\n    n (int): The size of the chessboard (number of rows and columns).\n\n    Returns:\n    list: A list of all possible configurations, where each configuration is a list of strings representing the chessboard.\n    \"\"\"\n\n    def is_safe(board, row, col):\n        \"\"\"\n        Checks if a queen can be placed at the given position on the board.\n\n        Args:\n        board (list): The current state of the board.\n        row (int): The row to check.\n        col (int): The column to check.\n\n        Returns:\n        bool: True if the queen can be placed, False otherwise.\n        \"\"\"\n        for i in range(row):\n            if board[i][col] == 'Q':\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 'Q':\n                return False\n            if col + (row - i) < n and board[i][col + (row - i)] == 'Q':\n                return False\n        return True\n\n    def backtrack(board, row):\n        \"\"\"\n        Recursively tries to place queens on the board.\n\n        Args:\n        board (list): The current state of the board.\n        row (int): The current row to place a queen.\n\n        Yields:\n        list: A solution configuration.\n        \"\"\"\n        if row == n:\n            yield [''.join(row) for row in board]\n        else:\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 'Q'\n                    yield from backtrack(board, row + 1)\n                    board[row][col] = '.'\n\n    # Initialize the board and start the backtracking process\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    return list(backtrack(board, 0))\n\n# Example usage\nn = 4\nsolutions = solve_n_queens(n)\nfor i, solution in enumerate(solutions):\n    print(f\"Solution {i+1}:\")\n    for row in solution:\n        print(row)\n    print()\n```\n\n### Explanation\n\n1.  The `solve_n_queens` function takes an integer `n` as input and returns a list of all possible configurations of queens on an NxN chessboard.\n2.  The `is_safe` function checks if a queen can be placed at a given position on the board by checking for conflicts with existing queens.\n3.  The `backtrack` function recursively tries to place queens on the board, starting from the first row and moving down. It uses the `is_safe` function to ensure that each placement is valid.\n4.  The `backtrack` function yields a solution configuration when a queen has been placed in each row.\n5.  The main function initializes the board and starts the backtracking process by calling the `backtrack` function with the initial board and row 0.\n6.  The solutions are returned as a list of lists, where each inner list represents a solution configuration.\n\n### Time Complexity\n\nThe time complexity of this solution is O(N!), where N is the size of the chessboard. This is because in the worst case, we need to try all possible placements of queens on the board, which is N! (N factorial) permutations.\n\n### Space Complexity\n\nThe space complexity of this solution is O(N^2), where N is the size of the chessboard. This is because we need to store the current state of the board, which is an NxN matrix. Additionally, we need to store the recursive call stack, which can grow up to a depth of N in the worst case.",
  "timestamp": "2026-02-11T08:28:04.919550",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}