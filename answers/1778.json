{
  "prompt": "Write a function to find the topological sort of a given directed acyclic graph (DAG).",
  "answer": "**Topological Sort Function**\n================================\n\nHere is an example of a Python function that performs a topological sort on a directed acyclic graph (DAG). This function uses the Kahn's algorithm to find the topological sort.\n\n```python\nfrom collections import defaultdict, deque\n\ndef topological_sort(graph):\n    \"\"\"\n    Performs a topological sort on a directed acyclic graph (DAG).\n\n    Args:\n    graph (dict): A dictionary representing the DAG, where each key is a node\n                  and its corresponding value is a list of its neighbors.\n\n    Returns:\n    list: A list of nodes in topological order.\n    \"\"\"\n    # Initialize the in-degree of each node to 0\n    in_degree = {node: 0 for node in graph}\n\n    # Calculate the in-degree of each node\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n\n    # Initialize a queue with nodes having in-degree 0\n    queue = deque([node for node in in_degree if in_degree[node] == 0])\n\n    # Initialize an empty list to store the topological sort\n    topological_order = []\n\n    # Perform the topological sort\n    while queue:\n        node = queue.popleft()\n        topological_order.append(node)\n\n        # Decrease the in-degree of each neighbor by 1\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Check if the graph has a cycle (i.e., it's not a DAG)\n    if len(topological_order) != len(graph):\n        raise ValueError(\"The graph has a cycle and cannot be topologically sorted\")\n\n    return topological_order\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Define a sample DAG\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D'],\n        'D': []\n    }\n\n    # Perform the topological sort\n    try:\n        topological_order = topological_sort(graph)\n        print(\"Topological order:\", topological_order)\n    except ValueError as e:\n        print(e)\n```\n\n**How it Works**\n---------------\n\nThe provided Python function performs a topological sort on a directed acyclic graph (DAG) using Kahn's algorithm. Here's a step-by-step explanation of the process:\n\n1.  **Initialize In-Degree**: The function initializes a dictionary to store the in-degree of each node in the graph. The in-degree of a node is the number of edges pointing to it.\n2.  **Calculate In-Degree**: The function iterates through the graph and calculates the in-degree of each node by counting the number of edges pointing to it.\n3.  **Initialize Queue**: A queue is initialized with nodes that have an in-degree of 0, meaning they have no incoming edges. These nodes are the starting points for the topological sort.\n4.  **Perform Topological Sort**: The function enters a loop where it dequeues a node from the queue, adds it to the topological order list, and decreases the in-degree of its neighbors by 1. If a neighbor's in-degree becomes 0, it is added to the queue.\n5.  **Check for Cycles**: After the loop, the function checks if the length of the topological order list is equal to the number of nodes in the graph. If not, it raises a `ValueError` indicating that the graph has a cycle and cannot be topologically sorted.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this algorithm is O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. This is because the algorithm visits each node and edge once during the topological sort process.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of this algorithm is O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. This is because the algorithm uses dictionaries and lists to store the graph, in-degrees, and topological order, which require space proportional to the number of nodes and edges.",
  "timestamp": "2026-02-10T20:08:18.532052",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}