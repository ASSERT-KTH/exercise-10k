{
  "prompt": "Write a program to find the strongly connected components of a graph using Tarjan's algorithm.",
  "answer": "**Tarjan's Algorithm for Strongly Connected Components**\n\n### Overview\n\nTarjan's algorithm is a popular method for finding strongly connected components in a graph. A strongly connected component is a subgraph where there is a path from every vertex to every other vertex.\n\n### Code\n\n```python\nfrom collections import defaultdict\n\nclass Tarjan:\n    def __init__(self, graph):\n        \"\"\"\n        Initialize the Tarjan algorithm with a graph.\n\n        Args:\n        graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n        \"\"\"\n        self.graph = graph\n        self.index = 0\n        self.stack = []\n        self.lowlinks = {}\n        self.indexes = {}\n        self.result = []\n\n    def strong_connect(self, node):\n        \"\"\"\n        Recursive function to find strongly connected components.\n\n        Args:\n        node: The current node being processed.\n        \"\"\"\n        self.indexes[node] = self.index\n        self.lowlinks[node] = self.index\n        self.index += 1\n        self.stack.append(node)\n\n        for successor in self.graph[node]:\n            if successor not in self.lowlinks:\n                self.strong_connect(successor)\n                self.lowlinks[node] = min(self.lowlinks[node], self.lowlinks[successor])\n            elif successor in self.stack:\n                self.lowlinks[node] = min(self.lowlinks[node], self.indexes[successor])\n\n        if self.lowlinks[node] == self.indexes[node]:\n            connected_component = []\n            while True:\n                successor = self.stack.pop()\n                connected_component.append(successor)\n                if successor == node:\n                    break\n            self.result.append(connected_component)\n\n    def find_scc(self):\n        \"\"\"\n        Find strongly connected components in the graph.\n        \"\"\"\n        for node in self.graph:\n            if node not in self.lowlinks:\n                self.strong_connect(node)\n        return self.result\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = {\n        'A': ['B'],\n        'B': ['C', 'D'],\n        'C': ['A', 'D'],\n        'D': ['E'],\n        'E': []\n    }\n\n    tarjan = Tarjan(graph)\n    scc = tarjan.find_scc()\n    print(\"Strongly Connected Components:\")\n    for i, component in enumerate(scc):\n        print(f\"Component {i+1}: {component}\")\n\n```\n\n### Explanation\n\n1.  The algorithm starts by initializing the index, stack, lowlinks, indexes, and result.\n2.  The `strong_connect` function is a recursive function that finds strongly connected components.\n3.  It assigns the current index to the node and increments the index.\n4.  It then adds the node to the stack and iterates over its successors.\n5.  If a successor has not been visited yet, the function calls itself recursively with the successor as the new node.\n6.  If a successor is in the stack, it means that there is a path from the current node to the successor, so it updates the lowlink value of the current node.\n7.  If the lowlink value of the current node is equal to its index, it means that the current node is the root of a strongly connected component.\n8.  The function then pops nodes from the stack until it finds the current node, and these nodes form a strongly connected component.\n9.  The `find_scc` function iterates over all nodes in the graph and calls the `strong_connect` function for each unvisited node.\n10. Finally, it returns the list of strongly connected components.\n\n### Time Complexity\n\nThe time complexity of Tarjan's algorithm is O(V + E), where V is the number of vertices and E is the number of edges in the graph. This is because each vertex and edge is visited once.\n\n### Space Complexity\n\nThe space complexity of Tarjan's algorithm is O(V), where V is the number of vertices in the graph. This is because the algorithm uses a stack and several dictionaries to store the lowlink values, indexes, and strongly connected components.",
  "timestamp": "2026-02-11T15:25:32.030056",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}