{
  "prompt": "Write a program that finds the longest increasing subsequence of a given list of numbers.",
  "answer": "**Longest Increasing Subsequence Program**\n=====================================\n\nThis program finds the longest increasing subsequence of a given list of numbers using dynamic programming.\n\n### Code\n\n```python\ndef longest_increasing_subsequence(numbers):\n    \"\"\"\n    Find the longest increasing subsequence of a given list of numbers.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    list: The longest increasing subsequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    # Initialize lists to store the lengths and predecessors of the longest increasing subsequences\n    lengths = [1] * len(numbers)\n    predecessors = [None] * len(numbers)\n\n    # Compute the lengths and predecessors of the longest increasing subsequences\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j] and lengths[i] < lengths[j] + 1:\n                lengths[i] = lengths[j] + 1\n                predecessors[i] = j\n\n    # Find the index of the longest increasing subsequence\n    max_length_idx = max(range(len(lengths)), key=lambda i: lengths[i])\n\n    # Reconstruct the longest increasing subsequence\n    subsequence = []\n    while max_length_idx is not None:\n        subsequence.append(numbers[max_length_idx])\n        max_length_idx = predecessors[max_length_idx]\n\n    # Return the longest increasing subsequence in the correct order\n    return subsequence[::-1]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    numbers = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n    print(\"Input list:\", numbers)\n    print(\"Longest increasing subsequence:\", longest_increasing_subsequence(numbers))\n```\n\n### Explanation\n\n1.  Initialize lists `lengths` and `predecessors` to store the lengths and predecessors of the longest increasing subsequences.\n2.  Iterate through the input list and update the `lengths` and `predecessors` lists based on the comparisons between elements.\n3.  Find the index of the longest increasing subsequence by finding the maximum value in the `lengths` list.\n4.  Reconstruct the longest increasing subsequence by backtracking from the index found in step 3.\n5.  Return the longest increasing subsequence in the correct order by reversing the reconstructed list.\n\n### Time Complexity\n\nThe time complexity of this program is O(n^2), where n is the length of the input list. This is because the program uses nested loops to compare elements and update the `lengths` and `predecessors` lists.\n\n### Space Complexity\n\nThe space complexity of this program is O(n), where n is the length of the input list. This is because the program uses lists of length n to store the lengths and predecessors of the longest increasing subsequences.",
  "timestamp": "2026-02-10T21:33:36.526196",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}