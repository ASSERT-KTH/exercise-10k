{
  "prompt": "Implement a binary search algorithm to find an element in a sorted array.",
  "answer": "**Binary Search Algorithm Implementation**\n\nHere's a step-by-step guide to implementing a binary search algorithm in Python:\n\n### Code Implementation\n\n```python\ndef binary_search(arr, target):\n    \"\"\"\n    Searches for an element in a sorted array using binary search.\n\n    Args:\n        arr (list): A sorted list of elements.\n        target: The element to search for.\n\n    Returns:\n        int: The index of the target element if found, -1 otherwise.\n    \"\"\"\n    low, high = 0, len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\n\n# Example usage\nif __name__ == \"__main__\":\n    sorted_array = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target_element = 23\n\n    result = binary_search(sorted_array, target_element)\n\n    if result != -1:\n        print(f\"Element {target_element} found at index {result}.\")\n    else:\n        print(f\"Element {target_element} not found in the array.\")\n```\n\n### Explanation\n\n1.  **Initialize Variables**:\n    *   `low` and `high` are initialized to the first and last indices of the array, respectively.\n2.  **Loop Until Convergence**:\n    *   The algorithm enters a loop that continues until `low` is greater than `high`.\n3.  **Calculate Midpoint**:\n    *   In each iteration, the midpoint `mid` is calculated as the average of `low` and `high`, rounded down to the nearest integer.\n4.  **Compare Midpoint Element to Target**:\n    *   The element at the midpoint index `mid` is compared to the target element.\n    *   If they match, the algorithm returns the midpoint index.\n    *   If the midpoint element is less than the target, the search space is reduced to the upper half of the array by updating `low` to `mid + 1`.\n    *   If the midpoint element is greater than the target, the search space is reduced to the lower half of the array by updating `high` to `mid - 1`.\n5.  **Return Result**:\n    *   If the loop ends without finding the target element, the algorithm returns -1 to indicate that the element is not in the array.\n\n### Time Complexity\n\n*   The binary search algorithm has a time complexity of **O(log n)**, where n is the number of elements in the array. This is because the algorithm effectively halves the search space in each iteration.\n\n### Space Complexity\n\n*   The binary search algorithm has a space complexity of **O(1)**, as it only uses a constant amount of space to store the indices and the target element.",
  "timestamp": "2026-02-10T15:01:03.108561",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}