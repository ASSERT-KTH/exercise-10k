{
  "prompt": "Write a function to perform a topological sort on a directed acyclic graph (DAG).",
  "answer": "**Topological Sort Function**\n================================\n\n### Overview\n\nThis function performs a topological sort on a directed acyclic graph (DAG). A topological sort is an ordering of the vertices in a DAG such that for every directed edge `u -> v`, vertex `u` comes before `v` in the ordering.\n\n### Code\n\n```python\nfrom collections import defaultdict, deque\n\ndef topological_sort(graph):\n    \"\"\"\n    Performs a topological sort on a directed acyclic graph (DAG).\n\n    Args:\n    graph: A dictionary representing the graph, where each key is a node and its corresponding value is a list of its neighbors.\n\n    Returns:\n    A list of nodes in topological order.\n    \"\"\"\n    # Initialize the in-degree dictionary\n    in_degree = defaultdict(int)\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n\n    # Initialize the queue with nodes having in-degree 0\n    queue = deque([node for node in graph if in_degree[node] == 0])\n\n    # Initialize the result list\n    result = []\n\n    # Perform the topological sort\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Check for cycles\n    if len(result) != len(graph):\n        raise ValueError(\"Graph contains a cycle\")\n\n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n\n    sorted_nodes = topological_sort(graph)\n    print(\"Topological order:\", sorted_nodes)\n```\n\n### Explanation\n\n1.  Initialize an in-degree dictionary to store the in-degree of each node.\n2.  Initialize a queue with nodes having an in-degree of 0.\n3.  Perform the topological sort by dequeuing nodes from the queue, appending them to the result list, and decreasing the in-degree of their neighbors.\n4.  Check for cycles by verifying that the length of the result list is equal to the number of nodes in the graph.\n\n### Time Complexity\n\nThe time complexity of this function is O(V + E), where V is the number of vertices and E is the number of edges in the graph. This is because we visit each node and edge once during the topological sort process.\n\n### Space Complexity\n\nThe space complexity of this function is O(V + E), where V is the number of vertices and E is the number of edges in the graph. This is because we store the in-degree of each node and the graph itself in dictionaries.",
  "timestamp": "2026-02-11T08:26:06.197455",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}