{
  "prompt": "Create a function that uses memoization to cache its results",
  "answer": "**Memoization Function**\n=======================\n\nBelow is an example of a function that uses memoization to cache its results. This example uses a Python function to calculate the Fibonacci sequence.\n\n```python\ndef memoize(func):\n    \"\"\"\n    A decorator to memoize the results of a function.\n    \"\"\"\n    cache = dict()\n\n    def memoized_func(*args):\n        if args in cache:\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n\n    return memoized_func\n\n\n@memoize\ndef fibonacci(n):\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Args:\n    n (int): The position of the Fibonacci number to calculate.\n\n    Returns:\n    int: The nth Fibonacci number.\n    \"\"\"\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(f\"Fibonacci number {i} is: {fibonacci(i)}\")\n```\n\n**How it Works**\n----------------\n\n1.  The `memoize` function is a decorator that takes a function `func` as an argument.\n2.  It creates a cache dictionary to store the results of `func` for different input arguments.\n3.  The `memoized_func` function checks if the result for the given arguments is already in the cache.\n4.  If the result is in the cache, it returns the cached result.\n5.  If not, it calculates the result using `func`, stores it in the cache, and returns it.\n6.  The `@memoize` decorator is applied to the `fibonacci` function to enable memoization.\n7.  The `fibonacci` function calculates the nth Fibonacci number using recursion.\n\n**Benefits of Memoization**\n-------------------------\n\n*   **Improved Performance**: Memoization reduces the number of redundant calculations, making the function more efficient.\n*   **Reduced Recursion**: By caching results, memoization reduces the depth of recursion, which can help avoid stack overflow errors.\n\n**When to Use Memoization**\n---------------------------\n\n*   **Expensive Function Calls**: Use memoization when a function is expensive to compute and has overlapping subproblems.\n*   **Recursive Functions**: Memoization is particularly useful for recursive functions that have redundant calculations.",
  "timestamp": "2026-02-11T20:28:50.019902",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}