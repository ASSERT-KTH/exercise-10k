{
  "prompt": "Write a function that demonstrates memoization.",
  "answer": "**Memoization Example: Fibonacci Sequence**\n=============================================\n\nMemoization is an optimization technique that stores the results of expensive function calls and returns the cached result when the same inputs occur again. Here, we will demonstrate memoization using the Fibonacci sequence.\n\n### Python Code\n\n```python\ndef fibonacci(n, memo={}):\n    \"\"\"\n    Calculates the nth Fibonacci number using memoization.\n\n    Args:\n        n (int): The position of the Fibonacci number to calculate.\n        memo (dict, optional): A dictionary to store previously calculated Fibonacci numbers. Defaults to {}.\n\n    Returns:\n        int: The nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n in memo:\n        # If the Fibonacci number is already calculated, return the cached result\n        return memo[n]\n    else:\n        # Calculate the Fibonacci number and store it in the cache\n        result = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        memo[n] = result\n        return result\n\n# Example usage:\nprint(fibonacci(10))  # Output: 55\n```\n\n### Explanation\n\n*   The `fibonacci` function takes two arguments: `n` (the position of the Fibonacci number to calculate) and `memo` (a dictionary to store previously calculated Fibonacci numbers).\n*   If `n` is less than or equal to 0, the function returns 0. If `n` is 1, the function returns 1.\n*   If `n` is already in the `memo` dictionary, the function returns the cached result.\n*   If `n` is not in the `memo` dictionary, the function calculates the Fibonacci number recursively and stores it in the cache.\n*   The example usage demonstrates how to use the `fibonacci` function to calculate the 10th Fibonacci number.\n\n### Time Complexity\n\nThe time complexity of the memoized Fibonacci function is O(n), which is a significant improvement over the naive recursive implementation with a time complexity of O(2^n). This is because the memoized function avoids redundant calculations by storing and reusing previously calculated results.",
  "timestamp": "2026-02-10T18:05:04.771166",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}