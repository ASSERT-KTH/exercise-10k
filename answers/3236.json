{
  "prompt": "Write a program to find the minimum window substring that contains all characters of a given string.",
  "answer": "**Minimum Window Substring**\n================================\n\nThis program finds the minimum window substring that contains all characters of a given string.\n\n**Code**\n------\n\n```python\nfrom collections import Counter\n\ndef min_window(s, t):\n    \"\"\"\n    Find the minimum window substring that contains all characters of a given string.\n\n    Args:\n        s (str): The string to search in.\n        t (str): The string to search for.\n\n    Returns:\n        str: The minimum window substring.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    t_count = Counter(t)\n    required_chars = len(t_count)\n\n    left = 0\n    min_len = float('inf')\n    min_window = \"\"\n\n    formed_chars = 0\n    window_counts = {}\n\n    for right in range(len(s)):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed_chars += 1\n\n        while left <= right and formed_chars == required_chars:\n            character = s[left]\n\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_window = s[left:right + 1]\n\n            window_counts[character] -= 1\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed_chars -= 1\n\n            left += 1\n\n    return min_window\n\n# Example usage\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window(s, t))  # Output: \"BANC\"\n```\n\n**Explanation**\n-------------\n\nThis program uses the sliding window technique to find the minimum window substring.\n\n1.  **Initialization**: We create a counter `t_count` to store the frequency of each character in the string `t`. We also initialize the `required_chars` variable to the number of unique characters in `t`.\n2.  **Window Expansion**: We iterate over the string `s` from left to right, expanding the window to the right. For each character, we update the `window_counts` dictionary to store the frequency of each character in the current window.\n3.  **Window Contraction**: When the window contains all characters of `t` (i.e., `formed_chars` equals `required_chars`), we contract the window from the left. We update the `min_len` and `min_window` variables if the current window is smaller than the minimum window found so far.\n4.  **Result**: Finally, we return the minimum window substring.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this program is O(|s| + |t|), where |s| and |t| are the lengths of the strings `s` and `t`, respectively. This is because we iterate over each string once.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of this program is O(|t|), where |t| is the length of the string `t`. This is because we store the frequency of each character in `t` in the `t_count` dictionary.",
  "timestamp": "2026-02-11T02:16:49.654771",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}