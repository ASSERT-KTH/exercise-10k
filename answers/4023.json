{
  "prompt": "Implement a binary search algorithm to find an element in a sorted array",
  "answer": "**Binary Search Algorithm Implementation**\n\n### Overview\n\nBinary search is an efficient algorithm for finding an element in a sorted array. It works by repeatedly dividing the search interval in half until the desired element is found.\n\n### Code Implementation (Python)\n```python\ndef binary_search(arr, target):\n    \"\"\"\n    Searches for an element in a sorted array using binary search.\n\n    Args:\n    - arr (list): Sorted array to search in.\n    - target (int): Element to search for.\n\n    Returns:\n    - int: Index of the target element if found, -1 otherwise.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\n# Example usage\nif __name__ == \"__main__\":\n    arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target = 23\n    result = binary_search(arr, target)\n\n    if result != -1:\n        print(f\"Element {target} found at index {result}.\")\n    else:\n        print(f\"Element {target} not found in the array.\")\n```\n\n### Explanation\n\n1.  Initialize two pointers, `low` and `high`, to the start and end of the array, respectively.\n2.  Calculate the middle index `mid` using the average of `low` and `high`.\n3.  Compare the middle element `arr[mid]` with the target element `target`.\n    *   If they match, return the middle index `mid`.\n    *   If `arr[mid]` is less than `target`, update `low` to `mid + 1` to search in the right half.\n    *   If `arr[mid]` is greater than `target`, update `high` to `mid - 1` to search in the left half.\n4.  Repeat steps 2-3 until `low` is greater than `high`.\n5.  If the loop ends without finding the target, return -1 to indicate that the element is not in the array.\n\n### Time Complexity\n\nThe binary search algorithm has a time complexity of **O(log n)**, where n is the number of elements in the array. This makes it much more efficient than linear search (O(n)) for large datasets.",
  "timestamp": "2026-02-11T09:27:17.845222",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}