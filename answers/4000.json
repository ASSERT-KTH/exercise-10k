{
  "prompt": "Create a program that finds the minimum window substring that contains all characters of another string.",
  "answer": "Here's an implementation of the minimum window substring program in Python. This program uses the sliding window technique to find the minimum window substring.\n\n```python\nfrom collections import Counter\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    This function finds the minimum window substring that contains all characters of another string.\n    \n    Args:\n        s (str): The string in which we need to find the minimum window substring.\n        t (str): The string that contains all the characters that the minimum window substring should have.\n        \n    Returns:\n        str: The minimum window substring if it exists, otherwise an empty string.\n    \"\"\"\n    \n    # Base case: If string t is longer than string s, return an empty string\n    if len(t) > len(s):\n        return \"\"\n    \n    # Create a counter for string t\n    t_count = Counter(t)\n    \n    # Initialize variables to keep track of the minimum window substring\n    required_chars = len(t_count)\n    formed_chars = 0\n    \n    # Initialize variables for the window boundaries\n    window_counts = {}\n    min_window = (0, float('inf'))\n    \n    # Initialize the window boundaries\n    left = 0\n    \n    # Traverse the string s\n    for right in range(len(s)):\n        # Add the character at the right boundary to the window counts\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        \n        # If the added character is in t and its frequency in the window is equal to its frequency in t,\n        # increment the formed_chars count\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed_chars += 1\n        \n        # While the window contains all characters of t and the left boundary is not at the beginning of the string,\n        # try to shrink the window from the left\n        while left <= right and formed_chars == required_chars:\n            # Update the minimum window substring if the current window is smaller\n            if right - left + 1 < min_window[1] - min_window[0]:\n                min_window = (left, right + 1)\n            \n            # Remove the character at the left boundary from the window counts\n            character = s[left]\n            window_counts[character] -= 1\n            \n            # If the removed character is in t and its frequency in the window is less than its frequency in t,\n            # decrement the formed_chars count\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed_chars -= 1\n            \n            # Move the left boundary to the right\n            left += 1\n    \n    # Return the minimum window substring if it exists, otherwise an empty string\n    return \"\" if min_window[1] == float('inf') else s[min_window[0]:min_window[1]]\n\n# Example usage:\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window(s, t))  # Output: \"BANC\"\n```\n\nThis program works as follows:\n\n*   It first checks if the string `t` is longer than the string `s`. If it is, the program returns an empty string because it's impossible to find a substring of `s` that contains all characters of `t`.\n*   It creates a counter `t_count` to store the frequency of each character in the string `t`.\n*   It initializes variables `required_chars` and `formed_chars` to keep track of the number of unique characters in `t` and the number of unique characters in the current window that are also in `t`, respectively.\n*   It initializes variables `window_counts` and `min_window` to keep track of the frequency of each character in the current window and the minimum window substring found so far, respectively.\n*   It traverses the string `s` using a sliding window approach. For each character in `s`, it adds the character to the window counts and updates the `formed_chars` count if necessary.\n*   While the window contains all characters of `t`, it tries to shrink the window from the left by removing characters from the window counts and updating the `formed_chars` count if necessary.\n*   If the current window is smaller than the minimum window substring found so far, it updates the `min_window` variable.\n*   Finally, it returns the minimum window substring if it exists, otherwise an empty string.",
  "timestamp": "2026-02-11T09:22:59.301105",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}