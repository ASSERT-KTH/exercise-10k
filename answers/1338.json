{
  "prompt": "Write a function that takes two strings as input and returns the Levenshtein distance between them.",
  "answer": "**Levenshtein Distance Function**\n================================\n\nThe Levenshtein distance between two strings is a measure of the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into the other.\n\n### Code\n\n```python\ndef levenshtein_distance(s1: str, s2: str) -> int:\n    \"\"\"\n    Calculate the Levenshtein distance between two strings.\n\n    Args:\n        s1 (str): The first string.\n        s2 (str): The second string.\n\n    Returns:\n        int: The Levenshtein distance between s1 and s2.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Initialize the base cases\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    # Fill in the rest of the table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            cost = 0 if s1[i - 1] == s2[j - 1] else 1\n            dp[i][j] = min(\n                dp[i - 1][j] + 1,      # Deletion\n                dp[i][j - 1] + 1,      # Insertion\n                dp[i - 1][j - 1] + cost  # Substitution or no operation\n            )\n\n    return dp[m][n]\n\n# Example usage\nif __name__ == \"__main__\":\n    s1 = \"kitten\"\n    s2 = \"sitting\"\n    print(f\"Levenshtein distance between '{s1}' and '{s2}': {levenshtein_distance(s1, s2)}\")\n```\n\n### Explanation\n\nThis function uses dynamic programming to build a 2D table `dp` where `dp[i][j]` represents the Levenshtein distance between the first `i` characters of `s1` and the first `j` characters of `s2`.\n\n*   The base cases are initialized as follows:\n    *   `dp[i][0] = i` represents the Levenshtein distance between the first `i` characters of `s1` and an empty string, which is `i` deletions.\n    *   `dp[0][j] = j` represents the Levenshtein distance between an empty string and the first `j` characters of `s2`, which is `j` insertions.\n*   The rest of the table is filled in using the following recurrence relation:\n    *   If `s1[i - 1]` is equal to `s2[j - 1]`, there is no operation needed, so the cost is 0.\n    *   Otherwise, the cost is 1 (substitution).\n    *   The Levenshtein distance `dp[i][j]` is the minimum of:\n        *   `dp[i - 1][j] + 1` (deletion)\n        *   `dp[i][j - 1] + 1` (insertion)\n        *   `dp[i - 1][j - 1] + cost` (substitution or no operation)\n*   The final Levenshtein distance is stored in `dp[m][n]`, where `m` and `n` are the lengths of `s1` and `s2`, respectively.\n\nThis function has a time complexity of O(m \\* n) and a space complexity of O(m \\* n), where m and n are the lengths of the input strings.",
  "timestamp": "2026-02-10T18:23:30.162521",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}