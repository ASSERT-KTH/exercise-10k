{
  "prompt": "Create a function that takes in a number and returns the factorial of that number.",
  "answer": "**Calculating Factorial**\n=======================\n\n### Overview\n\nThe following code defines a function to calculate the factorial of a given number.\n\n### Code\n```python\ndef calculate_factorial(n):\n    \"\"\"\n    Calculate the factorial of a given number.\n\n    Args:\n        n (int): The number to calculate the factorial of.\n\n    Returns:\n        int: The factorial of the given number.\n\n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    elif n == 0 or n == 1:\n        return 1\n    else:\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n\n# Example usage\ndef main():\n    num = 5\n    try:\n        factorial = calculate_factorial(num)\n        print(f\"The factorial of {num} is: {factorial}\")\n    except ValueError as e:\n        print(e)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n*   The function `calculate_factorial` takes an integer `n` as input.\n*   It checks if the input number is negative and raises a `ValueError` if true.\n*   It handles the base cases where `n` is 0 or 1, returning 1 as the factorial.\n*   For `n` greater than 1, it calculates the factorial using a loop and returns the result.\n*   The `main` function demonstrates example usage of the `calculate_factorial` function.\n\n### Alternative Approach\n\nYou can also use recursion to calculate the factorial:\n\n```python\ndef calculate_factorial_recursive(n):\n    \"\"\"\n    Calculate the factorial of a given number using recursion.\n\n    Args:\n        n (int): The number to calculate the factorial of.\n\n    Returns:\n        int: The factorial of the given number.\n\n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    elif n == 0 or n == 1:\n        return 1\n    else:\n        return n * calculate_factorial_recursive(n - 1)\n```\n\nNote that while recursion can be a elegant solution, it may cause a stack overflow for large input values due to the recursive call stack. The iterative approach is generally more efficient and scalable.",
  "timestamp": "2026-02-11T08:05:18.818645",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}