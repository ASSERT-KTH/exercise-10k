{
  "prompt": "Write a program to find the shortest path between two nodes in a weighted graph using Bellman-Ford algorithm.",
  "answer": "**Bellman-Ford Algorithm Implementation**\n======================================\n\n### Overview\n\nThe Bellman-Ford algorithm is a graph search algorithm that finds the shortest path between a source node and all other nodes in a weighted graph. It can handle negative weight edges, and can detect negative weight cycles.\n\n### Code\n\n```python\nclass Graph:\n    def __init__(self, num_vertices):\n        self.num_vertices = num_vertices\n        self.edges = []\n\n    def add_edge(self, u, v, weight):\n        self.edges.append((u, v, weight))\n\n    def bellman_ford(self, source):\n        # Initialize distances and predecessors\n        distances = [float('inf')] * self.num_vertices\n        distances[source] = 0\n        predecessors = [None] * self.num_vertices\n\n        # Relax edges repeatedly\n        for _ in range(self.num_vertices - 1):\n            for u, v, weight in self.edges:\n                if distances[u] + weight < distances[v]:\n                    distances[v] = distances[u] + weight\n                    predecessors[v] = u\n\n        # Check for negative weight cycles\n        for u, v, weight in self.edges:\n            if distances[u] + weight < distances[v]:\n                print(\"Negative weight cycle detected\")\n                return None\n\n        return distances, predecessors\n\n    def get_shortest_path(self, source, target):\n        distances, predecessors = self.bellman_ford(source)\n        if distances is None:\n            return None\n\n        path = []\n        current = target\n        while current is not None:\n            path.append(current)\n            current = predecessors[current]\n        path.reverse()\n\n        return path, distances[target]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = Graph(5)\n    graph.add_edge(0, 1, -1)\n    graph.add_edge(0, 2, 4)\n    graph.add_edge(1, 2, 3)\n    graph.add_edge(1, 3, 2)\n    graph.add_edge(1, 4, 2)\n    graph.add_edge(3, 2, 5)\n    graph.add_edge(3, 1, 1)\n    graph.add_edge(4, 3, -3)\n\n    source = 0\n    target = 4\n    path, distance = graph.get_shortest_path(source, target)\n\n    if path is not None:\n        print(f\"Shortest path from {source} to {target}: {path}\")\n        print(f\"Distance: {distance}\")\n```\n\n### Explanation\n\n1.  We define a `Graph` class with methods to add edges and run the Bellman-Ford algorithm.\n2.  The `bellman_ford` method initializes distances and predecessors, relaxes edges repeatedly, and checks for negative weight cycles.\n3.  The `get_shortest_path` method uses the `bellman_ford` method to find the shortest path between a source and target node.\n4.  In the example usage, we create a graph, add edges, and find the shortest path from node 0 to node 4.\n\n### Time Complexity\n\nThe time complexity of the Bellman-Ford algorithm is O(V \\* E), where V is the number of vertices and E is the number of edges. This is because we relax each edge V - 1 times.\n\n### Space Complexity\n\nThe space complexity of the Bellman-Ford algorithm is O(V), as we need to store distances and predecessors for each vertex.",
  "timestamp": "2026-02-11T15:58:46.776137",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}