{
  "prompt": "Write a program to perform a topological sort on a given directed acyclic graph (DAG).",
  "answer": "**Topological Sort Program**\n================================\n\n### Description\n\nThis program performs a topological sort on a given directed acyclic graph (DAG). A topological sort is a ordering of the vertices in a DAG such that for every directed edge `u -> v`, vertex `u` comes before vertex `v` in the ordering.\n\n### Code\n\n```python\nfrom collections import defaultdict, deque\n\ndef topological_sort(graph):\n    \"\"\"\n    Performs a topological sort on a given DAG.\n\n    Args:\n        graph (dict): A dictionary representing the DAG, where each key is a vertex and its corresponding value is a list of its neighbors.\n\n    Returns:\n        list: A list of vertices in topologically sorted order.\n    \"\"\"\n\n    # Initialize a dictionary to store the in-degree of each vertex\n    in_degree = defaultdict(int)\n\n    # Calculate the in-degree of each vertex\n    for vertex in graph:\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] += 1\n\n    # Initialize a queue with vertices having in-degree 0\n    queue = deque([vertex for vertex in graph if in_degree[vertex] == 0])\n\n    # Initialize an empty list to store the sorted vertices\n    sorted_vertices = []\n\n    # Perform the topological sort\n    while queue:\n        vertex = queue.popleft()\n        sorted_vertices.append(vertex)\n\n        # Decrease the in-degree of each neighbor by 1\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] -= 1\n\n            # Add the neighbor to the queue if its in-degree becomes 0\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Check if the graph has a cycle (i.e., it's not a DAG)\n    if len(sorted_vertices) != len(graph):\n        raise ValueError(\"The graph has a cycle and is not a DAG\")\n\n    return sorted_vertices\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n\n    sorted_vertices = topological_sort(graph)\n    print(\"Topologically sorted vertices:\", sorted_vertices)\n```\n\n### Explanation\n\n1.  The program uses a dictionary to represent the DAG, where each key is a vertex and its corresponding value is a list of its neighbors.\n2.  It calculates the in-degree of each vertex by iterating over the graph and incrementing the in-degree of each neighbor.\n3.  It initializes a queue with vertices having in-degree 0 and an empty list to store the sorted vertices.\n4.  The program performs the topological sort by dequeuing a vertex, adding it to the sorted list, and decreasing the in-degree of its neighbors. If a neighbor's in-degree becomes 0, it is added to the queue.\n5.  Finally, it checks if the graph has a cycle by comparing the length of the sorted list with the number of vertices in the graph. If they are not equal, it raises a `ValueError`.\n\n### Time Complexity\n\nThe time complexity of this program is O(V + E), where V is the number of vertices and E is the number of edges in the graph. This is because it iterates over the graph once to calculate the in-degrees and once to perform the topological sort.\n\n### Space Complexity\n\nThe space complexity is O(V + E), as it uses dictionaries and lists to store the graph, in-degrees, and sorted vertices.",
  "timestamp": "2026-02-11T15:57:04.764869",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}