{
  "prompt": "Write a function that uses a decorator to implement memoization",
  "answer": "**Memoization Decorator Function**\n=====================================\n\nMemoization is a technique where you store the results of expensive function calls and re-use them when the same inputs occur again. Here's an example of a decorator that implements memoization in Python:\n\n```python\nfrom functools import wraps\n\ndef memoize(func):\n    \"\"\"Memoization decorator\"\"\"\n    cache = dict()\n\n    @wraps(func)\n    def memoized_func(*args):\n        if args in cache:\n            return cache[args]\n        else:\n            result = func(*args)\n            cache[args] = result\n            return result\n\n    return memoized_func\n\n# Example usage:\n@memoize\ndef fibonacci(n):\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Test the memoized function\nprint(fibonacci(10))  # Calculate the 10th Fibonacci number\n```\n\n**How it works**\n----------------\n\n1. The `memoize` decorator is defined, which takes a function `func` as its argument.\n2. A dictionary `cache` is created to store the results of function calls.\n3. The `memoized_func` is defined, which checks if the input arguments are already in the cache. If they are, it returns the cached result. Otherwise, it calls the original function, stores the result in the cache, and returns it.\n4. The `@wraps(func)` decorator is used to preserve the original function's name, docstring, and other metadata.\n5. The `memoize` decorator is applied to the `fibonacci` function, which calculates the nth Fibonacci number recursively.\n6. When the `fibonacci` function is called, the memoized version checks the cache first and returns the cached result if available, reducing the number of recursive calls.\n\n**Advantages**\n--------------\n\n*   Reduces the number of function calls, improving performance for expensive or recursive functions.\n*   Simplifies the implementation of memoization, making it easy to apply to existing functions.\n\n**Note**\n----\n\n*   This implementation only works for functions with hashable arguments (e.g., integers, strings, tuples). For functions with unhashable arguments (e.g., lists, dictionaries), a different approach is needed.\n*   The cache grows indefinitely as the function is called with new arguments. In a real-world application, you might want to implement a cache eviction policy to limit the cache size.",
  "timestamp": "2026-02-11T23:25:23.549625",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}