{
  "prompt": "Implement the bubble sort algorithm to sort an array of integers in ascending order.",
  "answer": "Here is a Python implementation of the Bubble Sort algorithm to sort an array of integers in ascending order:\n```python\ndef bubble_sort(arr):\n    \"\"\"\n    Sorts an array of integers in ascending order using the Bubble Sort algorithm.\n\n    Args:\n        arr (list): The input array of integers.\n\n    Returns:\n        list: The sorted array of integers.\n    \"\"\"\n    n = len(arr)\n\n    for i in range(n - 1):\n        # Create a flag that will allow the function to terminate early if there's nothing left to sort\n        swapped = False\n\n        # Start looking at each item of the array one by one, comparing it with its adjacent value\n        for j in range(n - i - 1):\n            # If the current element is greater than the next one, swap them\n            if arr[j] > arr[j + 1]:\n                # Swap values\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                # Set the flag to True so we'll loop again\n                swapped = True\n\n        # If no two elements were swapped in the inner loop, the array is sorted\n        if not swapped:\n            break\n\n    return arr\n\n# Example usage:\narr = [64, 34, 25, 12, 22, 11, 90]\nprint(\"Original array:\", arr)\nprint(\"Sorted array:\", bubble_sort(arr))\n```\nOutput:\n```\nOriginal array: [64, 34, 25, 12, 22, 11, 90]\nSorted array: [11, 12, 22, 25, 34, 64, 90]\n```\nExplanation:\n\n1. The outer loop `for i in range(n - 1):` iterates `n-1` times, where `n` is the length of the array.\n2. The inner loop `for j in range(n - i - 1):` compares each element with its adjacent value.\n3. If an element is greater than its adjacent value, they are swapped using tuple assignment `arr[j], arr[j + 1] = arr[j + 1], arr[j]`.\n4. A flag `swapped` is used to check if any swaps were made in the inner loop. If no swaps were made, the array is already sorted, and the algorithm can terminate early.\n\nNote that Bubble Sort has a time complexity of O(n^2) in the worst case, making it less efficient than other sorting algorithms like QuickSort or MergeSort for large datasets. However, it is simple to implement and can be useful for small datasets or educational purposes.",
  "timestamp": "2026-02-11T01:53:51.654318",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}