{
  "prompt": "Write a program to find the minimum spanning tree of a graph using Kruskal's algorithm.",
  "answer": "Here's an implementation of Kruskal's algorithm in Python to find the minimum spanning tree of a graph. This implementation assumes that the graph is represented as a list of edges, where each edge is a tuple of (node1, node2, weight).\n\n```python\nclass DisjointSet:\n    \"\"\"Disjoint set data structure for union-find operations.\"\"\"\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Union the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\n\ndef kruskal(graph):\n    \"\"\"Kruskal's algorithm to find the minimum spanning tree of a graph.\"\"\"\n    # Sort the edges by weight\n    edges = sorted(graph, key=lambda x: x[2])\n\n    # Initialize the disjoint set data structure\n    vertices = set()\n    for edge in graph:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n\n    # Initialize the minimum spanning tree\n    mst = []\n\n    # Iterate over the sorted edges\n    for edge in edges:\n        vertex1, vertex2, weight = edge\n        # Check if the edge connects two different sets\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Union the sets containing the two vertices\n            disjoint_set.union(vertex1, vertex2)\n\n    return mst\n\n\n# Example usage:\ngraph = [\n    ('A', 'B', 2),\n    ('A', 'C', 3),\n    ('B', 'C', 1),\n    ('B', 'D', 1),\n    ('C', 'D', 4)\n]\n\nmst = kruskal(graph)\nprint(\"Minimum Spanning Tree:\")\nfor edge in mst:\n    print(f\"{edge[0]} - {edge[1]} : {edge[2]}\")\n\n```\n\n**Explanation:**\n\n1.  We start by defining a `DisjointSet` class that implements the union-find operations using a disjoint set data structure. This data structure is used to keep track of the connected components in the graph.\n2.  The `kruskal` function takes a graph as input, which is represented as a list of edges. Each edge is a tuple of `(node1, node2, weight)`.\n3.  We sort the edges in non-decreasing order of their weights.\n4.  We initialize the disjoint set data structure with all the vertices in the graph.\n5.  We iterate over the sorted edges. For each edge, we check if it connects two different sets by using the `find` operation. If it does, we add the edge to the minimum spanning tree and union the sets containing the two vertices.\n6.  Finally, we return the minimum spanning tree, which is a list of edges that form a tree with the minimum total weight.\n\n**Time Complexity:** The time complexity of Kruskal's algorithm is O(E log E) or O(E log V), where E is the number of edges and V is the number of vertices in the graph. This is because we sort the edges and perform union-find operations, which take logarithmic time.\n\n**Space Complexity:** The space complexity is O(V + E), as we need to store the vertices, edges, and the disjoint set data structure.",
  "timestamp": "2026-02-11T01:04:27.860533",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}