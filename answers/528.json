{
  "prompt": "Implement a function to find the shortest path between two nodes in a weighted graph.",
  "answer": "**Dijkstra's Algorithm Implementation**\n=====================================\n\nHere's a Python implementation of Dijkstra's algorithm to find the shortest path between two nodes in a weighted graph.\n\n### Code\n\n```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, end):\n    \"\"\"\n    Find the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): Adjacency list representation of the graph.\n    start (node): Starting node.\n    end (node): Ending node.\n\n    Returns:\n    tuple: Shortest distance and path from start to end.\n    \"\"\"\n    # Initialize distances and previous nodes\n    distances = {node: sys.maxsize for node in graph}\n    distances[start] = 0\n    previous = {node: None for node in graph}\n\n    # Priority queue to store nodes to visit\n    queue = [(0, start)]\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # Skip if current node is already visited with shorter distance\n        if current_distance > distances[current_node]:\n            continue\n\n        # Visit neighbors\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            # Update distance and previous node if shorter path found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous[neighbor] = current_node\n                heapq.heappush(queue, (distance, neighbor))\n\n    # Build the shortest path\n    path = []\n    current_node = end\n    while current_node is not None:\n        path.append(current_node)\n        current_node = previous[current_node]\n    path.reverse()\n\n    return distances[end], path\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = {\n        'A': {'B': 1, 'C': 4},\n        'B': {'A': 1, 'C': 2, 'D': 5},\n        'C': {'A': 4, 'B': 2, 'D': 1},\n        'D': {'B': 5, 'C': 1}\n    }\n\n    start_node = 'A'\n    end_node = 'D'\n\n    distance, path = dijkstra(graph, start_node, end_node)\n    print(f\"Shortest distance from {start_node} to {end_node}: {distance}\")\n    print(f\"Path: {' -> '.join(path)}\")\n```\n\n### Explanation\n\n1.  **Initialization**: The function initializes the distances to all nodes as infinity, except for the start node, which is set to 0. It also initializes the previous nodes for all nodes as None.\n2.  **Priority Queue**: A priority queue is used to store nodes to visit, with the start node as the first node.\n3.  **Node Visitation**: The function visits each node in the priority queue, skipping nodes that have already been visited with a shorter distance.\n4.  **Neighbor Visitation**: For each neighbor of the current node, the function calculates the tentative distance and updates the distance and previous node if a shorter path is found.\n5.  **Shortest Path Construction**: After visiting all nodes, the function builds the shortest path by tracing back the previous nodes from the end node to the start node.\n6.  **Example Usage**: The code includes an example usage with a sample graph, demonstrating how to use the `dijkstra` function to find the shortest path between two nodes.\n\nThis implementation assumes a weighted graph represented as an adjacency list, where each key is a node and its corresponding value is a dictionary of neighboring nodes with their respective weights. The function returns a tuple containing the shortest distance and the path from the start node to the end node.",
  "timestamp": "2026-02-10T15:03:34.247347",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}