{
  "prompt": "Implement a BFS algorithm to traverse a graph or tree",
  "answer": "**Breadth-First Search (BFS) Algorithm Implementation**\n=====================================================\n\n### Overview\n\nBreadth-First Search (BFS) is a graph traversal algorithm that visits all the nodes at a given depth level before moving on to the next level. This implementation provides a BFS algorithm to traverse a graph or tree.\n\n### Code Implementation\n\n```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self):\n        \"\"\"\n        Initialize an empty graph.\n        \"\"\"\n        self.adjacency_list = {}\n\n    def add_node(self, node):\n        \"\"\"\n        Add a node to the graph.\n\n        Args:\n        node (any): The node to be added.\n        \"\"\"\n        if node not in self.adjacency_list:\n            self.adjacency_list[node] = []\n\n    def add_edge(self, node1, node2):\n        \"\"\"\n        Add an edge between two nodes in the graph.\n\n        Args:\n        node1 (any): The first node.\n        node2 (any): The second node.\n        \"\"\"\n        if node1 in self.adjacency_list and node2 in self.adjacency_list:\n            self.adjacency_list[node1].append(node2)\n            self.adjacency_list[node2].append(node1)\n\n    def bfs(self, start_node):\n        \"\"\"\n        Perform a breadth-first search traversal of the graph.\n\n        Args:\n        start_node (any): The node to start the traversal from.\n\n        Returns:\n        list: A list of nodes in the order they were visited.\n        \"\"\"\n        visited = set()\n        traversal_order = []\n        queue = deque([start_node])\n\n        while queue:\n            node = queue.popleft()\n            if node not in visited:\n                visited.add(node)\n                traversal_order.append(node)\n                for neighbor in self.adjacency_list[node]:\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n\n        return traversal_order\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = Graph()\n    nodes = ['A', 'B', 'C', 'D', 'E']\n    edges = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'E')]\n\n    for node in nodes:\n        graph.add_node(node)\n\n    for edge in edges:\n        graph.add_edge(*edge)\n\n    start_node = 'A'\n    traversal_order = graph.bfs(start_node)\n    print(f\"BFS Traversal Order starting from {start_node}: {traversal_order}\")\n```\n\n### Explanation\n\n*   The `Graph` class represents a graph using an adjacency list.\n*   The `add_node` method adds a node to the graph, and the `add_edge` method adds an edge between two nodes.\n*   The `bfs` method performs a breadth-first search traversal of the graph, starting from a given node. It uses a queue to keep track of nodes to visit and a set to keep track of visited nodes.\n*   The algorithm visits all the nodes at a given depth level before moving on to the next level, resulting in a breadth-first traversal order.\n\n### Time Complexity\n\n*   The time complexity of the BFS algorithm is O(|V| + |E|), where |V| is the number of vertices (nodes) and |E| is the number of edges, since each node and edge is visited once.\n\n### Space Complexity\n\n*   The space complexity of the BFS algorithm is O(|V|), since we need to store the visited nodes and the queue of nodes to visit.",
  "timestamp": "2026-02-10T23:19:17.160562",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}