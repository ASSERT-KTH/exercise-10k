{
  "prompt": "Implement the KMP algorithm to search for a substring in a string",
  "answer": "**KMP Algorithm Implementation**\n================================\n\nThe KMP (Knuth-Morris-Pratt) algorithm is a linear-time string searching algorithm that uses the observation that when a mismatch occurs, the information about the mismatch can be used to skip characters in the text and to shift the pattern along the text.\n\n**Code Implementation**\n----------------------\n\nHere is a Python implementation of the KMP algorithm:\n\n```python\ndef compute_prefix_function(pattern):\n    \"\"\"\n    Compute the prefix function for the given pattern.\n\n    The prefix function is a list where the i-th element is the length of the\n    longest proper prefix of the pattern that is also a proper suffix of the\n    pattern up to the i-th position.\n\n    Args:\n        pattern (str): The pattern to search for.\n\n    Returns:\n        list: The prefix function for the pattern.\n    \"\"\"\n    prefix = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n            j = prefix[j - 1]\n        if pattern[j] == pattern[i]:\n            j += 1\n        prefix[i] = j\n    return prefix\n\n\ndef kmp_search(text, pattern):\n    \"\"\"\n    Search for the given pattern in the given text using the KMP algorithm.\n\n    Args:\n        text (str): The text to search in.\n        pattern (str): The pattern to search for.\n\n    Returns:\n        list: A list of indices where the pattern was found in the text.\n    \"\"\"\n    prefix = compute_prefix_function(pattern)\n    indices = []\n    j = 0\n    for i in range(len(text)):\n        while j > 0 and text[i] != pattern[j]:\n            j = prefix[j - 1]\n        if text[i] == pattern[j]:\n            j += 1\n        if j == len(pattern):\n            indices.append(i - j + 1)\n            j = prefix[j - 1]\n    return indices\n\n\n# Example usage:\ntext = \"abxabcabcaby\"\npattern = \"abcaby\"\nindices = kmp_search(text, pattern)\nprint(\"Pattern found at indices:\", indices)\n```\n\n**Explanation**\n---------------\n\n1.  The `compute_prefix_function` function computes the prefix function for the given pattern. This function is used to skip characters in the text and to shift the pattern along the text.\n2.  The `kmp_search` function uses the prefix function to search for the pattern in the text. It keeps track of the current position in the pattern and the current position in the text.\n3.  When a mismatch occurs, the function uses the prefix function to determine how many characters to skip in the text and how to shift the pattern along the text.\n4.  When a match is found, the function adds the index of the match to the list of indices and continues searching for the pattern in the text.\n\n**Time Complexity**\n------------------\n\nThe time complexity of the KMP algorithm is O(n + m), where n is the length of the text and m is the length of the pattern. This is because the algorithm only needs to traverse the text and the pattern once.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of the KMP algorithm is O(m), where m is the length of the pattern. This is because the algorithm needs to store the prefix function for the pattern.",
  "timestamp": "2026-02-10T13:10:10.436575",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}