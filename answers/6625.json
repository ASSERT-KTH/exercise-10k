{
  "prompt": "Write a recursive function that calculates the factorial of a given number",
  "answer": "**Recursive Factorial Function**\n================================\n\n### Code\n\n```python\ndef factorial(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a given number.\n\n    Args:\n    n (int): The number to calculate the factorial of.\n\n    Returns:\n    int: The factorial of the given number.\n\n    Raises:\n    ValueError: If the input number is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input number cannot be negative.\")\n    elif n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n\n# Example usage\ndef main():\n    num = 5\n    try:\n        result = factorial(num)\n        print(f\"The factorial of {num} is: {result}\")\n    except ValueError as e:\n        print(e)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n*   The `factorial` function takes an integer `n` as input and returns its factorial.\n*   It first checks if the input number is negative, in which case it raises a `ValueError`.\n*   If the input number is 0 or 1, it returns 1, since the factorial of 0 and 1 is defined to be 1.\n*   For any other positive number, it calls itself with the argument `n-1` and multiplies the result by `n`.\n*   The `main` function demonstrates how to use the `factorial` function with an example.\n\n### Step-by-Step Solution\n\n1.  Define the base case: If `n` is 0 or 1, return 1.\n2.  Define the recursive case: If `n` is greater than 1, return `n` multiplied by the factorial of `n-1`.\n3.  Handle the error case: If `n` is negative, raise a `ValueError`.\n\n### Time Complexity\n\n*   The time complexity of this recursive function is O(n), where n is the input number. This is because the function makes n recursive calls to calculate the factorial.",
  "timestamp": "2026-02-11T19:46:00.271576",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}