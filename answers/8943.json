{
  "prompt": "Write a program to match a string against a wildcard pattern.",
  "answer": "**Wildcard Pattern Matching Program**\n=====================================\n\n### Overview\n\nThis program uses dynamic programming to match a string against a wildcard pattern. The wildcard pattern can contain two special characters:\n\n*   `*`: matches any sequence of characters (including an empty sequence)\n*   `?`: matches any single character\n\n### Code\n\n```python\ndef wildcard_pattern_matching(string, pattern):\n    \"\"\"\n    Matches a string against a wildcard pattern.\n\n    Args:\n    string (str): The input string to match.\n    pattern (str): The wildcard pattern to match against.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n\n    # Initialize a 2D table to store the dynamic programming results\n    dp = [[False] * (len(pattern) + 1) for _ in range(len(string) + 1)]\n\n    # An empty string matches an empty pattern\n    dp[0][0] = True\n\n    # A '*' in the pattern can match an empty string\n    for j in range(1, len(pattern) + 1):\n        if pattern[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n\n    # Fill in the rest of the table\n    for i in range(1, len(string) + 1):\n        for j in range(1, len(pattern) + 1):\n            if pattern[j - 1] == '*':\n                # '*' can match any sequence of characters\n                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n            elif pattern[j - 1] == '?':\n                # '?' can match any single character\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                # Exact character match\n                dp[i][j] = dp[i - 1][j - 1] and string[i - 1] == pattern[j - 1]\n\n    # The result is stored in the bottom-right corner of the table\n    return dp[len(string)][len(pattern)]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    string = \"hello\"\n    pattern = \"h?llo\"\n    result = wildcard_pattern_matching(string, pattern)\n    print(f\"'{string}' matches '{pattern}': {result}\")\n\n    string = \"hello\"\n    pattern = \"h*llo\"\n    result = wildcard_pattern_matching(string, pattern)\n    print(f\"'{string}' matches '{pattern}': {result}\")\n\n    string = \"hello\"\n    pattern = \"h*l\"\n    result = wildcard_pattern_matching(string, pattern)\n    print(f\"'{string}' matches '{pattern}': {result}\")\n```\n\n### Explanation\n\nThe `wildcard_pattern_matching` function takes a string and a wildcard pattern as input and returns `True` if the string matches the pattern, `False` otherwise.\n\nThe function uses a 2D table `dp` to store the dynamic programming results, where `dp[i][j]` represents whether the first `i` characters of the string match the first `j` characters of the pattern.\n\nThe table is filled in row by row, using the following rules:\n\n*   If the current character in the pattern is `*`, it can match any sequence of characters in the string, so `dp[i][j]` is set to `dp[i][j - 1]` (the pattern without the `*`) or `dp[i - 1][j]` (the string without the current character).\n*   If the current character in the pattern is `?`, it can match any single character in the string, so `dp[i][j]` is set to `dp[i - 1][j - 1]`.\n*   If the current character in the pattern is not `*` or `?`, it must match the current character in the string exactly, so `dp[i][j]` is set to `dp[i - 1][j - 1]` and the characters must be equal.\n\nFinally, the result is stored in the bottom-right corner of the table, `dp[len(string)][len(pattern)]`, which indicates whether the entire string matches the entire pattern.",
  "timestamp": "2026-02-12T02:16:37.133765",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}