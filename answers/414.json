{
  "prompt": "Given an array of integers, find the longest increasing subsequence.",
  "answer": "**Longest Increasing Subsequence Problem**\n=============================================\n\n### Problem Statement\n\nGiven an array of integers, find the longest increasing subsequence (LIS). A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n\n### Example\n\n* Input: `[10, 22, 9, 33, 21, 50, 41, 60, 80]`\n* Output: `[10, 22, 33, 50, 60, 80]` (one possible LIS)\n\n### Solution\n\nWe can solve this problem using dynamic programming.\n\n#### Algorithm\n\n1. Initialize an array `dp` of the same length as the input array, where `dp[i]` will store the length of the LIS ending at index `i`.\n2. Initialize the first element of `dp` to 1, since a single element is always an increasing subsequence of length 1.\n3. Iterate through the input array from the second element to the last element.\n4. For each element, compare it with all previous elements. If the current element is greater than a previous element, update `dp[i]` to be the maximum of its current value and `dp[j] + 1`, where `j` is the index of the previous element.\n5. Keep track of the maximum value in `dp`, which represents the length of the LIS.\n6. To reconstruct the LIS, iterate through the input array and find the elements that correspond to the maximum values in `dp`.\n\n#### Code\n\n```python\ndef longest_increasing_subsequence(nums):\n    \"\"\"\n    Find the longest increasing subsequence in a given array of integers.\n\n    Args:\n    - nums (list): The input array of integers.\n\n    Returns:\n    - list: The longest increasing subsequence.\n    \"\"\"\n    if not nums:\n        return []\n\n    n = len(nums)\n    dp = [1] * n\n    prev = [-1] * n\n\n    max_length = 1\n    max_index = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n        if dp[i] > max_length:\n            max_length = dp[i]\n            max_index = i\n\n    # Reconstruct the LIS\n    lis = []\n    while max_index != -1:\n        lis.append(nums[max_index])\n        max_index = prev[max_index]\n\n    return lis[::-1]\n\n# Example usage\nnums = [10, 22, 9, 33, 21, 50, 41, 60, 80]\nprint(longest_increasing_subsequence(nums))  # [10, 22, 33, 50, 60, 80]\n```\n\n### Time Complexity\n\nThe time complexity of this solution is O(n^2), where n is the length of the input array.\n\n### Space Complexity\n\nThe space complexity of this solution is O(n), where n is the length of the input array.",
  "timestamp": "2026-02-10T14:32:45.736711",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}