{
  "prompt": "Write a program that finds the minimum spanning tree of a graph.",
  "answer": "**Minimum Spanning Tree Program**\n=====================================\n\nThis program uses Kruskal's algorithm to find the minimum spanning tree of a graph. The graph is represented as a list of edges, where each edge is a tuple containing the source vertex, the destination vertex, and the weight of the edge.\n\n**Code**\n--------\n\n```python\nclass DisjointSet:\n    \"\"\"Disjoint set data structure for union-find operations.\"\"\"\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Union the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\n\ndef kruskal(graph):\n    \"\"\"Kruskal's algorithm to find the minimum spanning tree of a graph.\"\"\"\n    vertices = set()\n    for edge in graph:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n\n    disjoint_set = DisjointSet(vertices)\n    mst = []\n    graph.sort(key=lambda x: x[2])\n\n    for edge in graph:\n        vertex1, vertex2, weight = edge\n        if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n            mst.append(edge)\n            disjoint_set.union(vertex1, vertex2)\n\n    return mst\n\n\ndef main():\n    # Example graph represented as a list of edges\n    graph = [\n        ('A', 'B', 2),\n        ('A', 'C', 3),\n        ('B', 'C', 1),\n        ('B', 'D', 4),\n        ('C', 'D', 5)\n    ]\n\n    mst = kruskal(graph)\n    print(\"Minimum Spanning Tree:\")\n    for edge in mst:\n        print(f\"{edge[0]} - {edge[1]} : {edge[2]}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Explanation**\n---------------\n\n1.  The `DisjointSet` class represents a disjoint set data structure, which is used to keep track of the connected components in the graph.\n2.  The `kruskal` function implements Kruskal's algorithm to find the minimum spanning tree.\n3.  It first creates a disjoint set data structure for all vertices in the graph.\n4.  Then, it sorts the edges of the graph in non-decreasing order of their weights.\n5.  It iterates over the sorted edges and checks if the two endpoints of each edge belong to different connected components. If they do, it adds the edge to the minimum spanning tree and merges the two components.\n6.  Finally, it returns the minimum spanning tree as a list of edges.\n\n**Time Complexity**\n------------------\n\nThe time complexity of Kruskal's algorithm is O(E log E) or O(E log V), where E is the number of edges and V is the number of vertices in the graph. This is because we sort the edges, which takes O(E log E) time, and then iterate over the sorted edges, which takes O(E) time. The disjoint set operations (find and union) take approximately constant time.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of Kruskal's algorithm is O(V + E), where V is the number of vertices and E is the number of edges in the graph. This is because we store the vertices and edges in the disjoint set data structure and the minimum spanning tree.",
  "timestamp": "2026-02-11T23:10:27.056348",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}