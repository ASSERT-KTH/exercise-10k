{
  "prompt": "Write a program to find the shortest path between two nodes in a graph.",
  "answer": "**Shortest Path Program**\n==========================\n\nThis program uses Dijkstra's algorithm to find the shortest path between two nodes in a graph.\n\n**Code**\n------\n\n```python\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = {}\n\n    def add_edge(self, node1, node2, weight):\n        if node1 in self.nodes and node2 in self.nodes:\n            self.nodes[node1][node2] = weight\n            self.nodes[node2][node1] = weight  # Comment this line for directed graph\n\n    def dijkstra(self, start_node):\n        distances = {node: sys.maxsize for node in self.nodes}\n        distances[start_node] = 0\n        queue = [(0, start_node)]\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.nodes[current_node].items():\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return distances\n\n    def shortest_path(self, start_node, end_node):\n        distances = self.dijkstra(start_node)\n        return distances[end_node]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = Graph()\n    graph.add_node(\"A\")\n    graph.add_node(\"B\")\n    graph.add_node(\"C\")\n    graph.add_node(\"D\")\n\n    graph.add_edge(\"A\", \"B\", 1)\n    graph.add_edge(\"B\", \"C\", 2)\n    graph.add_edge(\"A\", \"C\", 3)\n    graph.add_edge(\"C\", \"D\", 1)\n\n    start_node = \"A\"\n    end_node = \"D\"\n    shortest_distance = graph.shortest_path(start_node, end_node)\n    print(f\"Shortest distance from {start_node} to {end_node}: {shortest_distance}\")\n```\n\n**Explanation**\n--------------\n\n1.  We define a `Graph` class to represent the graph.\n2.  The `add_node` method adds a new node to the graph.\n3.  The `add_edge` method adds an edge between two nodes with a specified weight.\n4.  The `dijkstra` method implements Dijkstra's algorithm to find the shortest distances from a start node to all other nodes.\n5.  The `shortest_path` method uses the `dijkstra` method to find the shortest distance between two nodes.\n6.  In the example usage, we create a graph, add nodes and edges, and find the shortest distance between two nodes.\n\n**Time Complexity**\n------------------\n\nThe time complexity of Dijkstra's algorithm is O((V + E) \\* log(V)), where V is the number of vertices (nodes) and E is the number of edges. This is because we use a priority queue to efficiently select the next node to process.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of Dijkstra's algorithm is O(V + E), where V is the number of vertices (nodes) and E is the number of edges. This is because we need to store the graph and the distances for each node.",
  "timestamp": "2026-02-11T13:55:42.541007",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}