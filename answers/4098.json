{
  "prompt": "Create a function that uses memoization to cache the results of expensive function calls",
  "answer": "**Memoization Function Example**\n=====================================\n\nHere's an example implementation of a memoization function in Python, which uses a dictionary to cache the results of expensive function calls.\n\n```python\nfrom functools import wraps\n\ndef memoize(func):\n    \"\"\"Memoization decorator to cache the results of expensive function calls.\"\"\"\n    cache = dict()\n\n    @wraps(func)\n    def memoized_func(*args):\n        if args in cache:\n            return cache[args]\n        else:\n            result = func(*args)\n            cache[args] = result\n            return result\n\n    return memoized_func\n\n# Example usage:\n@memoize\ndef expensive_function(x):\n    \"\"\"Simulating an expensive function call.\"\"\"\n    import time\n    time.sleep(2)  # Simulating a 2-second delay\n    return x * x\n\n# Test the memoized function\nprint(expensive_function(5))  # Takes 2 seconds\nprint(expensive_function(5))  # Returns immediately from cache\nprint(expensive_function(10))  # Takes 2 seconds\nprint(expensive_function(10))  # Returns immediately from cache\n```\n\n**How Memoization Works**\n-------------------------\n\n1.  The `memoize` function takes another function `func` as an argument.\n2.  It creates an empty dictionary `cache` to store the results of `func` calls.\n3.  The `memoized_func` is defined inside `memoize`, which checks if the input arguments `args` are already in the `cache`.\n4.  If `args` is in the `cache`, it returns the cached result directly.\n5.  If `args` is not in the `cache`, it calls the original `func` with `args`, stores the result in the `cache`, and returns the result.\n6.  The `@wraps(func)` decorator is used to preserve the original function's name, docstring, and other metadata.\n\n**Advantages of Memoization**\n-----------------------------\n\n*   **Improved Performance**: Memoization avoids redundant calculations by reusing previously computed results, leading to significant performance improvements for expensive function calls.\n*   **Reduced Computational Overhead**: By caching results, memoization reduces the computational overhead associated with repeated function calls.\n\n**Common Use Cases for Memoization**\n--------------------------------------\n\n*   **Dynamic Programming**: Memoization is often used in dynamic programming to solve problems that have overlapping subproblems.\n*   **Optimization Problems**: Memoization can help optimize the solution to problems by avoiding redundant calculations and reducing computational overhead.\n*   **Expensive Function Calls**: Memoization is useful when dealing with expensive function calls, such as those involving database queries, network requests, or computationally intensive calculations.",
  "timestamp": "2026-02-11T09:43:52.056274",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}