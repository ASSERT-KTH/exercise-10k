{
  "prompt": "Write a program to perform topological sorting on a directed acyclic graph (DAG)",
  "answer": "**Topological Sorting Program**\n================================\n\n### Overview\n\nTopological sorting is a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge `u -> v`, vertex `u` comes before `v` in the ordering. This program performs topological sorting on a given DAG.\n\n### Code\n\n```python\nfrom collections import defaultdict, deque\n\ndef topological_sorting(graph):\n    \"\"\"\n    Performs topological sorting on a given DAG.\n\n    Args:\n    graph (dict): Adjacency list representation of the DAG.\n\n    Returns:\n    list: Topologically sorted list of vertices.\n    \"\"\"\n    # Initialize in-degree dictionary\n    in_degree = {vertex: 0 for vertex in graph}\n    \n    # Calculate in-degrees of all vertices\n    for vertex in graph:\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] += 1\n    \n    # Initialize queue with vertices having in-degree 0\n    queue = deque([vertex for vertex in in_degree if in_degree[vertex] == 0])\n    \n    # Initialize result list\n    result = []\n    \n    # Perform topological sorting\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        # Decrease in-degrees of neighboring vertices\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check for cycles\n    if len(result) != len(graph):\n        raise ValueError(\"Graph contains a cycle\")\n    \n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    # Define a sample DAG\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    \n    # Perform topological sorting\n    try:\n        sorted_vertices = topological_sorting(graph)\n        print(\"Topologically sorted vertices:\", sorted_vertices)\n    except ValueError as e:\n        print(e)\n```\n\n### Explanation\n\n1.  The program takes an adjacency list representation of the DAG as input.\n2.  It initializes a dictionary `in_degree` to store the in-degrees of all vertices.\n3.  It calculates the in-degrees of all vertices by iterating over the adjacency list.\n4.  It initializes a queue with vertices having an in-degree of 0, which are the starting points for the topological sorting.\n5.  It performs the topological sorting by dequeuing vertices from the queue, adding them to the result list, and decreasing the in-degrees of their neighboring vertices.\n6.  If a neighboring vertex has its in-degree reduced to 0, it is added to the queue.\n7.  The program checks for cycles by verifying that the length of the result list matches the number of vertices in the graph.\n8.  If a cycle is detected, it raises a `ValueError`.\n\n### Time Complexity\n\n*   The time complexity of the program is O(V + E), where V is the number of vertices and E is the number of edges in the graph. This is because it iterates over the adjacency list and the queue.\n\n### Space Complexity\n\n*   The space complexity of the program is O(V + E), as it uses dictionaries and a queue to store the graph and the result.",
  "timestamp": "2026-02-10T23:20:02.793668",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}