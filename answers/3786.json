{
  "prompt": "Write a function to find the shortest path between two nodes in a weighted graph using Dijkstra's algorithm.",
  "answer": "### Dijkstra's Algorithm Implementation\n#### Overview\nDijkstra's algorithm is a well-known algorithm in graph theory used for finding the shortest paths between nodes in a graph. Here's an implementation of Dijkstra's algorithm using Python.\n\n#### Code\n```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start_node):\n    \"\"\"\n    Dijkstra's algorithm to find the shortest path between nodes in a weighted graph.\n\n    Args:\n    - graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                    The inner dictionary's keys are the node's neighbors and its values are the edge weights.\n    - start_node (str): The node to start the search from.\n\n    Returns:\n    - distances (dict): A dictionary where the keys are the nodes and the values are the shortest distances from the start node.\n    - shortest_paths (dict): A dictionary where the keys are the nodes and the values are the shortest paths from the start node.\n    \"\"\"\n\n    # Initialize distances and previous nodes\n    distances = {node: sys.maxsize for node in graph}\n    distances[start_node] = 0\n    shortest_paths = {node: [] for node in graph}\n    shortest_paths[start_node] = [start_node]\n\n    # Priority queue to store nodes to be processed\n    priority_queue = [(0, start_node)]\n\n    while priority_queue:\n        # Extract the node with the minimum distance from the priority queue\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        # If the current distance is greater than the already known distance, skip this node\n        if current_distance > distances[current_node]:\n            continue\n\n        # Iterate over the neighbors of the current node\n        for neighbor, weight in graph[current_node].items():\n            # Calculate the distance to the neighbor through the current node\n            distance = current_distance + weight\n\n            # If this distance is less than the already known distance, update the distance and previous node\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                shortest_paths[neighbor] = shortest_paths[current_node] + [neighbor]\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances, shortest_paths\n\ndef main():\n    # Example usage\n    graph = {\n        'A': {'B': 1, 'C': 4},\n        'B': {'A': 1, 'C': 2, 'D': 5},\n        'C': {'A': 4, 'B': 2, 'D': 1},\n        'D': {'B': 5, 'C': 1}\n    }\n\n    start_node = 'A'\n    distances, shortest_paths = dijkstra(graph, start_node)\n\n    print(\"Shortest Distances:\")\n    for node, distance in distances.items():\n        print(f\"{start_node} -> {node}: {distance}\")\n\n    print(\"\\nShortest Paths:\")\n    for node, path in shortest_paths.items():\n        print(f\"{start_node} -> {node}: {path}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n#### Explanation\n1.  **Initialization**: The distances to all nodes are initialized to infinity, except for the start node, which is set to 0. The shortest paths are also initialized with the start node as the only node in the path.\n2.  **Priority Queue**: A priority queue is used to store nodes to be processed, with the node having the minimum distance at the top of the queue.\n3.  **Node Processing**: The node with the minimum distance is extracted from the priority queue, and its neighbors are processed. If a shorter path to a neighbor is found, the distance and previous node are updated.\n4.  **Termination**: The algorithm terminates when all nodes have been processed, and the shortest distances and paths are returned.\n\n#### Time Complexity\nThe time complexity of Dijkstra's algorithm is O((V + E) log V) in the worst case, where V is the number of vertices (nodes) and E is the number of edges. This is because each node and edge is processed once, and the priority queue operations (insertion and extraction) take O(log V) time.",
  "timestamp": "2026-02-11T08:25:12.271074",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}