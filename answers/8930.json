{
  "prompt": "Write a program to check if a given linked list is a palindrome.",
  "answer": "Here's a Python solution that checks if a linked list is a palindrome. This program uses a two-pointer approach to compare the first and last nodes of the list.\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n\n    def is_palindrome(self):\n        # Step 1: Find the end of first half and reverse second half.\n        first_half_end = self.end_of_first_half()\n        second_half_start = self.reverse_list(first_half_end.next)\n\n        # Check whether or not there's a palindrome.\n        result = True\n        first_position = self.head\n        second_position = second_half_start\n        while result and second_position is not None:\n            if first_position.data != second_position.data:\n                result = False\n            first_position = first_position.next\n            second_position = second_position.next\n\n        # Restore the list and return the result.\n        first_half_end.next = self.reverse_list(second_half_start)\n        return result\n\n    def end_of_first_half(self):\n        slow = self.head\n        fast = self.head\n        while fast.next is not None and fast.next.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n    def reverse_list(self, head):\n        previous = None\n        current = head\n        while current is not None:\n            next_node = current.next\n            current.next = previous\n            previous = current\n            current = next_node\n        return previous\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" \")\n            current = current.next\n        print()\n\n\n# Test the program\nlinked_list = LinkedList()\nlinked_list.append(1)\nlinked_list.append(2)\nlinked_list.append(3)\nlinked_list.append(2)\nlinked_list.append(1)\nprint(\"Linked List:\")\nlinked_list.print_list()\nprint(\"Is Palindrome:\", linked_list.is_palindrome())\n\nlinked_list2 = LinkedList()\nlinked_list2.append(1)\nlinked_list2.append(2)\nlinked_list2.append(3)\nprint(\"Linked List 2:\")\nlinked_list2.print_list()\nprint(\"Is Palindrome:\", linked_list2.is_palindrome())\n\n```\n\n### Explanation\n1. **Node and LinkedList Classes**: The code starts with the definition of a `Node` class and a `LinkedList` class. The `Node` class has an `__init__` method to initialize the node with data and a `next` pointer. The `LinkedList` class has methods to append data to the list, check if the list is a palindrome, and print the list.\n\n2. **is_palindrome Method**: This method checks if the linked list is a palindrome. It does this by first finding the end of the first half of the list and reversing the second half. Then, it compares the first half and the reversed second half. If they are the same, the list is a palindrome.\n\n3. **end_of_first_half Method**: This method finds the end of the first half of the linked list using the slow and fast pointer approach.\n\n4. **reverse_list Method**: This method reverses a linked list.\n\n5. **print_list Method**: This method prints the elements of the linked list.\n\n6. **Testing the Program**: The code includes a test section where it creates two linked lists, one that is a palindrome and one that is not, and checks if they are palindromes using the `is_palindrome` method.\n\n### Time Complexity\nThe time complexity of this solution is O(n), where n is the number of nodes in the linked list. This is because we are traversing the list twice: once to find the end of the first half and reverse the second half, and once to compare the first half and the reversed second half.\n\n### Space Complexity\nThe space complexity of this solution is O(1), which means the space required does not change with the size of the input list. This is because we are only using a constant amount of space to store the pointers and variables.",
  "timestamp": "2026-02-12T02:13:57.820324",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}