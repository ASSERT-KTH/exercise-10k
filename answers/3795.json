{
  "prompt": "Create a function that finds all combinations of numbers that sum up to a target value.",
  "answer": "**Combination Sum Problem**\n================================\n\n### Problem Statement\n\nGiven a list of numbers and a target value, find all combinations of numbers that sum up to the target value.\n\n### Solution\n\nHere is a Python solution using recursion and backtracking:\n```python\ndef combination_sum(candidates, target):\n    \"\"\"\n    Finds all combinations of numbers that sum up to the target value.\n\n    Args:\n        candidates (list): A list of numbers.\n        target (int): The target value.\n\n    Returns:\n        list: A list of lists, where each sublist is a combination of numbers that sum up to the target value.\n    \"\"\"\n    def backtrack(remain, comb, start):\n        if remain == 0:\n            result.append(list(comb))\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(candidates)):\n            comb.append(candidates[i])\n            backtrack(remain - candidates[i], comb, i)\n            comb.pop()\n\n    result = []\n    backtrack(target, [], 0)\n    return result\n\n# Example usage:\ncandidates = [2, 3, 5]\ntarget = 8\nresult = combination_sum(candidates, target)\nprint(result)\n```\n### Explanation\n\nThe `combination_sum` function takes a list of numbers `candidates` and a target value `target` as input. It uses a recursive helper function `backtrack` to find all combinations of numbers that sum up to the target value.\n\nThe `backtrack` function takes three arguments:\n\n* `remain`: the remaining value to reach the target\n* `comb`: the current combination of numbers\n* `start`: the starting index for the next iteration\n\nThe function works as follows:\n\n1. If `remain` is 0, it means we have found a valid combination, so we append it to the result list.\n2. If `remain` is negative, it means the current combination exceeds the target value, so we return immediately.\n3. We iterate over the `candidates` list starting from the `start` index.\n4. For each candidate, we add it to the current combination and recursively call `backtrack` with the updated remaining value and combination.\n5. After the recursive call, we remove the last added candidate from the combination to backtrack and try the next candidate.\n\nThe `combination_sum` function initializes an empty result list and calls the `backtrack` function with the initial values. Finally, it returns the result list.\n\n### Example Output\n\nFor the example input `candidates = [2, 3, 5]` and `target = 8`, the output will be:\n```python\n[[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n```\nThis means there are three combinations of numbers that sum up to 8: `[2, 2, 2, 2]`, `[2, 3, 3]`, and `[3, 5]`.",
  "timestamp": "2026-02-11T08:28:25.319338",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}