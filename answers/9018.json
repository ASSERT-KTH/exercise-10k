{
  "prompt": "Write a function that uses function decorators to add a feature to an existing function.",
  "answer": "**Function Decorator Example: Timing Function Execution**\n==========================================================\n\nHere is an example of a function decorator that adds a timing feature to an existing function. This decorator measures the execution time of the function and prints it out.\n\n```python\nimport time\nfrom functools import wraps\n\ndef timing_decorator(func):\n    \"\"\"\n    Decorator to measure the execution time of a function.\n    \n    Args:\n    func: The function to be decorated.\n    \n    Returns:\n    A wrapper function that measures the execution time of the input function.\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        execution_time = end_time - start_time\n        print(f\"Function {func.__name__} executed in {execution_time:.4f} seconds\")\n        return result\n    return wrapper\n\n# Example usage\n@timing_decorator\ndef example_function(n):\n    \"\"\"\n    An example function that simulates some time-consuming operation.\n    \n    Args:\n    n: The number of seconds to sleep.\n    \"\"\"\n    time.sleep(n)\n    print(\"Example function finished\")\n\n# Test the example function\nexample_function(2)\n```\n\n**How it Works:**\n\n1.  The `timing_decorator` function takes a function `func` as input and returns a wrapper function.\n2.  The `wrapper` function measures the execution time of the input function `func` by recording the start and end times.\n3.  It then calculates the execution time by subtracting the start time from the end time.\n4.  The execution time is printed out along with the name of the function.\n5.  The `@wraps(func)` decorator is used to preserve the original function's name and docstring in the wrapper function.\n6.  The `example_function` is decorated with the `@timing_decorator` to demonstrate its usage.\n\n**Benefits of Using Function Decorators:**\n\n*   Function decorators allow you to add new features to existing functions without modifying their source code.\n*   They promote code reuse and make it easier to maintain and extend your codebase.\n*   Decorators can be stacked to combine multiple features, making them a powerful tool for functional programming in Python.",
  "timestamp": "2026-02-12T02:32:03.640161",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}