{
  "prompt": "Find the median of two sorted arrays",
  "answer": "Finding the Median of Two Sorted Arrays\n=====================================\n\n### Problem Statement\n\nGiven two sorted arrays, find the median of the combined array.\n\n### Approach\n\nTo find the median of two sorted arrays, we can use a binary search approach. The idea is to find the partition point for both arrays such that the elements on the left side of the partition point in both arrays are less than or equal to the elements on the right side.\n\n### Algorithm\n\n1.  Ensure that the first array is smaller than the second array. If not, swap them.\n2.  Calculate the total length of both arrays.\n3.  If the total length is odd, the median is the middle element. If it's even, the median is the average of the two middle elements.\n4.  Use binary search to find the partition point for the smaller array.\n5.  For each partition point, calculate the corresponding partition point for the larger array.\n6.  Check if the partition is correct by comparing the elements on the left and right sides of the partition point.\n7.  If the partition is not correct, adjust the partition point and repeat the process.\n\n### Code\n\n```python\ndef find_median_sorted_arrays(nums1, nums2):\n    \"\"\"\n    Find the median of two sorted arrays.\n\n    Args:\n    nums1 (list): The first sorted array.\n    nums2 (list): The second sorted array.\n\n    Returns:\n    float: The median of the combined array.\n    \"\"\"\n    # Ensure that nums1 is the smaller array\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    # Calculate the total length\n    total_length = len(nums1) + len(nums2)\n\n    # If the total length is odd, the median is the middle element\n    # If it's even, the median is the average of the two middle elements\n    half_length = total_length // 2\n\n    # Initialize the binary search range\n    left, right = 0, len(nums1) - 1\n\n    while True:\n        # Calculate the partition point for nums1\n        i = (left + right) // 2\n\n        # Calculate the corresponding partition point for nums2\n        j = half_length - i - 2\n\n        # Calculate the elements on the left and right sides of the partition point\n        nums1_left = nums1[i] if i >= 0 else float(\"-infinity\")\n        nums1_right = nums1[i + 1] if (i + 1) < len(nums1) else float(\"infinity\")\n        nums2_left = nums2[j] if j >= 0 else float(\"-infinity\")\n        nums2_right = nums2[j + 1] if (j + 1) < len(nums2) else float(\"infinity\")\n\n        # Check if the partition is correct\n        if nums1_left <= nums2_right and nums2_left <= nums1_right:\n            # If the total length is odd, return the middle element\n            if total_length % 2:\n                return min(nums1_right, nums2_right)\n            # If the total length is even, return the average of the two middle elements\n            else:\n                return (max(nums1_left, nums2_left) + min(nums1_right, nums2_right)) / 2\n        # If the partition is not correct, adjust the partition point\n        elif nums1_left > nums2_right:\n            right = i - 1\n        else:\n            left = i + 1\n\n# Example usage\nnums1 = [1, 3]\nnums2 = [2]\nprint(find_median_sorted_arrays(nums1, nums2))  # Output: 2\n\nnums1 = [1, 2]\nnums2 = [3, 4]\nprint(find_median_sorted_arrays(nums1, nums2))  # Output: 2.5\n```\n\n### Time Complexity\n\n*   The time complexity of the above solution is O(log(min(m, n))), where m and n are the lengths of the two input arrays. This is because we are using a binary search approach to find the partition point.\n\n### Space Complexity\n\n*   The space complexity of the above solution is O(1), which means the space required does not change with the size of the input array, making it very efficient.",
  "timestamp": "2026-02-10T13:09:47.220132",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}