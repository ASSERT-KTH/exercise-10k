{
  "prompt": "Write a program to check if a graph is connected using depth-first search.",
  "answer": "**Checking Graph Connectivity using Depth-First Search**\n\nBelow is an example of a Python program that checks if a graph is connected using depth-first search (DFS). This implementation assumes a graph represented as an adjacency list.\n\n```python\nfrom typing import Dict, List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = {i: [] for i in range(num_vertices)}\n\n    def add_edge(self, u: int, v: int):\n        \"\"\"Add an edge between vertices u and v.\"\"\"\n        self.adj_list[u].append(v)\n        self.adj_list[v].append(u)\n\n    def dfs(self, vertex: int, visited: List[bool]) -> None:\n        \"\"\"Perform DFS traversal from the given vertex.\"\"\"\n        visited[vertex] = True\n        for neighbor in self.adj_list[vertex]:\n            if not visited[neighbor]:\n                self.dfs(neighbor, visited)\n\n    def is_connected(self) -> bool:\n        \"\"\"Check if the graph is connected.\"\"\"\n        visited = [False] * self.num_vertices\n        self.dfs(0, visited)\n        return all(visited)\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a graph with 5 vertices\n    graph = Graph(5)\n\n    # Add edges to the graph\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 3)\n    graph.add_edge(3, 4)\n\n    # Check if the graph is connected\n    if graph.is_connected():\n        print(\"The graph is connected.\")\n    else:\n        print(\"The graph is not connected.\")\n\n    # Create another graph with 5 vertices\n    graph_disconnected = Graph(5)\n\n    # Add edges to the graph\n    graph_disconnected.add_edge(0, 1)\n    graph_disconnected.add_edge(1, 2)\n    graph_disconnected.add_edge(3, 4)\n\n    # Check if the graph is connected\n    if graph_disconnected.is_connected():\n        print(\"The graph is connected.\")\n    else:\n        print(\"The graph is not connected.\")\n```\n\n**Explanation**\n\n1.  We define a `Graph` class to represent the graph.\n2.  The `add_edge` method adds an edge between two vertices.\n3.  The `dfs` method performs a depth-first search traversal from a given vertex and marks all visited vertices.\n4.  The `is_connected` method checks if the graph is connected by performing a DFS traversal from an arbitrary vertex (in this case, vertex 0) and verifying if all vertices are visited.\n5.  In the example usage, we create two graphs: one connected and one disconnected. We add edges to both graphs and check their connectivity using the `is_connected` method.\n\n**Time Complexity**\n\n*   The time complexity of the `dfs` method is O(V + E), where V is the number of vertices and E is the number of edges, since we visit each vertex and edge once.\n*   The time complexity of the `is_connected` method is also O(V + E), as it calls the `dfs` method.\n\n**Space Complexity**\n\n*   The space complexity of the `Graph` class is O(V + E), as we store the adjacency list representation of the graph.\n*   The space complexity of the `dfs` and `is_connected` methods is O(V), as we use a visited array to keep track of visited vertices during the DFS traversal.",
  "timestamp": "2026-02-11T15:25:03.759425",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}