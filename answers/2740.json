{
  "prompt": "Write a program to find the minimum window substring that contains all characters of a given string",
  "answer": "**Minimum Window Substring Program**\n=====================================\n\nThis program finds the minimum window substring that contains all characters of a given string.\n\n### Solution Overview\n\nWe will use a sliding window approach with the help of two pointers (left and right) to solve this problem. We will also use a dictionary to keep track of the characters in the given string and their frequencies.\n\n### Code\n\n```python\nfrom collections import defaultdict\n\ndef min_window(s, t):\n    \"\"\"\n    Find the minimum window substring that contains all characters of a given string.\n\n    Args:\n        s (str): The string to search in.\n        t (str): The string containing the characters to search for.\n\n    Returns:\n        str: The minimum window substring that contains all characters of t. If no such substring exists, returns an empty string.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    # Create a dictionary to store the characters in t and their frequencies\n    t_count = defaultdict(int)\n    for char in t:\n        t_count[char] += 1\n\n    # Initialize the required character count to the length of t\n    required = len(t_count)\n\n    # Initialize the left and right pointers of the sliding window\n    left = 0\n\n    # Initialize the minimum window substring and its length\n    min_len = float('inf')\n    min_window = \"\"\n\n    # Initialize the formed character count to 0\n    formed = 0\n\n    # Create a dictionary to store the characters in the current window and their frequencies\n    window_counts = defaultdict(int)\n\n    # Iterate over the string s\n    for right in range(len(s)):\n        # Add the character at the right pointer to the window counts\n        character = s[right]\n        window_counts[character] += 1\n\n        # If the added character is in t and its frequency in the window is equal to its frequency in t, increment the formed count\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed += 1\n\n        # While the window contains all characters in t and the left pointer is less than the right pointer\n        while left <= right and formed == required:\n            # Update the minimum window substring if the current window is smaller\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_window = s[left:right + 1]\n\n            # Remove the character at the left pointer from the window counts\n            character = s[left]\n            window_counts[character] -= 1\n\n            # If the removed character is in t and its frequency in the window is less than its frequency in t, decrement the formed count\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed -= 1\n\n            # Move the left pointer to the right\n            left += 1\n\n    # Return the minimum window substring\n    return min_window\n\n\n# Example usage\nif __name__ == \"__main__\":\n    s = \"ADOBECODEBANC\"\n    t = \"ABC\"\n    print(min_window(s, t))  # Output: \"BANC\"\n```\n\n### Explanation\n\n1.  Create a dictionary `t_count` to store the characters in `t` and their frequencies.\n2.  Initialize the left and right pointers of the sliding window.\n3.  Initialize the minimum window substring `min_window` and its length `min_len`.\n4.  Create a dictionary `window_counts` to store the characters in the current window and their frequencies.\n5.  Iterate over the string `s` using the right pointer.\n6.  Add the character at the right pointer to the window counts.\n7.  If the added character is in `t` and its frequency in the window is equal to its frequency in `t`, increment the `formed` count.\n8.  While the window contains all characters in `t` and the left pointer is less than the right pointer, update the minimum window substring if the current window is smaller.\n9.  Remove the character at the left pointer from the window counts and decrement the `formed` count if necessary.\n10. Move the left pointer to the right.\n11. Return the minimum window substring.\n\n### Time Complexity\n\nThe time complexity of this solution is O(n), where n is the length of the string `s`.\n\n### Space Complexity\n\nThe space complexity of this solution is O(n), where n is the length of the string `s`.",
  "timestamp": "2026-02-11T00:11:12.524750",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}