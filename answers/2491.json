{
  "prompt": "Write a program to find the minimum window of a string that contains all characters of another string",
  "answer": "**Minimum Window Substring**\n==========================\n\nThis program finds the minimum window of a string that contains all characters of another string.\n\n**Code**\n```python\nfrom collections import Counter\n\ndef min_window(s, t):\n    \"\"\"\n    Find the minimum window of string `s` that contains all characters of string `t`.\n\n    Args:\n    s (str): The string to search in.\n    t (str): The string that must be contained in the window.\n\n    Returns:\n    str: The minimum window substring of `s` that contains all characters of `t`. If no such window exists, returns an empty string.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    t_count = Counter(t)\n    required_chars = len(t_count)\n\n    left = 0\n    min_length = float('inf')\n    min_window = \"\"\n\n    formed_chars = 0\n    window_counts = {}\n\n    for right in range(len(s)):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed_chars += 1\n\n        while left <= right and formed_chars == required_chars:\n            character = s[left]\n\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n                min_window = s[left:right + 1]\n\n            window_counts[character] -= 1\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed_chars -= 1\n\n            left += 1\n\n    return min_window\n\n# Example usage\nif __name__ == \"__main__\":\n    s = \"ADOBECODEBANC\"\n    t = \"ABC\"\n    print(min_window(s, t))  # Output: \"BANC\"\n```\n\n**Explanation**\n---------------\n\n1.  We start by counting the frequency of each character in string `t` using the `Counter` class from the `collections` module.\n2.  We then initialize two pointers, `left` and `right`, to the start of string `s`. We also initialize `min_length` to infinity and `min_window` to an empty string.\n3.  We iterate over string `s` using the `right` pointer. For each character, we increment its count in the `window_counts` dictionary.\n4.  If the character is in `t_count` and its count in `window_counts` is equal to its count in `t_count`, we increment `formed_chars`.\n5.  If `formed_chars` is equal to `required_chars`, it means we have found a window that contains all characters of `t`. We then try to minimize this window by moving the `left` pointer to the right.\n6.  If the length of the current window is less than `min_length`, we update `min_length` and `min_window`.\n7.  We continue this process until we have iterated over the entire string `s`.\n8.  Finally, we return `min_window`, which is the minimum window substring of `s` that contains all characters of `t`. If no such window exists, we return an empty string.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this algorithm is O(n), where n is the length of string `s`. This is because we are iterating over string `s` once using the `right` pointer and potentially once using the `left` pointer.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of this algorithm is O(k), where k is the number of unique characters in string `t`. This is because we are storing the frequency of each character in `t_count` and `window_counts`.",
  "timestamp": "2026-02-10T23:09:33.900758",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}