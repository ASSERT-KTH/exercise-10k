{
  "prompt": "Write a function to find the minimum window substring that contains all characters of a given string",
  "answer": "**Minimum Window Substring Function**\n\n### Description\n\nThis function finds the minimum window substring that contains all characters of a given string.\n\n### Code\n\n```python\nfrom collections import Counter\n\ndef min_window(s, t):\n    \"\"\"\n    Find the minimum window substring that contains all characters of a given string.\n\n    Args:\n    s (str): The string to search in.\n    t (str): The string containing the characters to search for.\n\n    Returns:\n    str: The minimum window substring that contains all characters of t.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    # Create a counter for the characters in t\n    t_count = Counter(t)\n\n    # Initialize the required character count\n    required_chars = len(t_count)\n\n    # Initialize the window boundaries\n    left = 0\n\n    # Initialize the minimum window substring\n    min_window = \"\"\n    min_window_len = float('inf')\n\n    # Initialize the formed character count\n    formed_chars = 0\n\n    # Create a counter for the characters in the window\n    window_counts = {}\n\n    # Iterate over the string s\n    for right in range(len(s)):\n        # Add the character at the right boundary to the window counter\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        # If the character is in t and its count in the window is equal to its count in t, increment the formed character count\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed_chars += 1\n\n        # While the window contains all characters of t and the left boundary is not at the start of the window\n        while left <= right and formed_chars == required_chars:\n            # Update the minimum window substring if the current window is smaller\n            if right - left + 1 < min_window_len:\n                min_window = s[left:right + 1]\n                min_window_len = right - left + 1\n\n            # Remove the character at the left boundary from the window counter\n            character = s[left]\n            window_counts[character] -= 1\n\n            # If the character is in t and its count in the window is less than its count in t, decrement the formed character count\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed_chars -= 1\n\n            # Move the left boundary to the right\n            left += 1\n\n    return min_window\n\n# Example usage\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window(s, t))  # Output: \"BANC\"\n```\n\n### Explanation\n\nThis function uses the sliding window technique to find the minimum window substring that contains all characters of the given string `t`.\n\n1.  Create a counter `t_count` for the characters in `t`.\n2.  Initialize the required character count `required_chars` to the number of unique characters in `t`.\n3.  Initialize the window boundaries `left` and `right` to 0.\n4.  Initialize the minimum window substring `min_window` to an empty string and its length `min_window_len` to infinity.\n5.  Create a counter `window_counts` for the characters in the window.\n6.  Iterate over the string `s` using the `right` pointer.\n7.  Add the character at the `right` boundary to the `window_counts` counter.\n8.  If the character is in `t` and its count in the window is equal to its count in `t`, increment the `formed_chars` count.\n9.  While the window contains all characters of `t` and the `left` boundary is not at the start of the window, update the minimum window substring if the current window is smaller, remove the character at the `left` boundary from the `window_counts` counter, and move the `left` boundary to the right.\n10. Return the minimum window substring `min_window`.\n\n### Time Complexity\n\nThe time complexity of this function is O(n), where n is the length of the string `s`, because it iterates over the string `s` once.\n\n### Space Complexity\n\nThe space complexity of this function is O(n), where n is the length of the string `t`, because it uses a counter to store the characters in `t`.",
  "timestamp": "2026-02-11T09:32:37.109838",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}