{
  "prompt": "Create a function to find the minimum window substring that contains all characters of another string.",
  "answer": "### Minimum Window Substring Function\n#### Problem Description\nThe function should find the minimum window substring in a given string that contains all characters of another string.\n\n#### Solution\n```python\nfrom collections import defaultdict\n\ndef min_window(s, t):\n    \"\"\"\n    Find the minimum window substring in string `s` that contains all characters of string `t`.\n\n    Args:\n    s (str): The string to search for the minimum window substring.\n    t (str): The string containing the characters to search for.\n\n    Returns:\n    str: The minimum window substring. If no such substring exists, returns an empty string.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    # Create a dictionary to store the frequency of characters in string `t`\n    t_count = defaultdict(int)\n    for char in t:\n        t_count[char] += 1\n\n    # Initialize variables to keep track of the minimum window substring\n    required_chars = len(t_count)\n    formed_chars = 0\n\n    # Initialize variables to keep track of the window boundaries\n    window_counts = defaultdict(int)\n    min_window = float(\"inf\")\n    min_window_substring = \"\"\n\n    # Initialize the window boundaries\n    left = 0\n\n    # Iterate over the string `s` to find the minimum window substring\n    for right in range(len(s)):\n        character = s[right]\n        window_counts[character] += 1\n\n        # If the frequency of the current character in the window is equal to the frequency in string `t`,\n        # increment the `formed_chars` count\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed_chars += 1\n\n        # While the window contains all characters of string `t` and the left boundary is not at the start of the string,\n        # try to shrink the window from the left\n        while left <= right and formed_chars == required_chars:\n            character = s[left]\n\n            # If the current window is smaller than the minimum window found so far, update the minimum window\n            if right - left + 1 < min_window:\n                min_window = right - left + 1\n                min_window_substring = s[left:right + 1]\n\n            # Decrement the frequency of the character at the left boundary and move the left boundary to the right\n            window_counts[character] -= 1\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed_chars -= 1\n\n            left += 1\n\n    return min_window_substring\n\n\n# Example usage:\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window(s, t))  # Output: \"BANC\"\n```\n\n#### Explanation\nThe function uses the sliding window technique to find the minimum window substring in string `s` that contains all characters of string `t`. It maintains two dictionaries, `t_count` and `window_counts`, to store the frequency of characters in string `t` and the current window, respectively. The function also keeps track of the number of characters in the window that match the characters in string `t` using the `formed_chars` variable.\n\nThe function iterates over string `s` and expands the window to the right. When the window contains all characters of string `t`, it tries to shrink the window from the left by moving the left boundary to the right. If the current window is smaller than the minimum window found so far, it updates the minimum window.\n\nFinally, the function returns the minimum window substring. If no such substring exists, it returns an empty string.",
  "timestamp": "2026-02-12T01:46:18.153551",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}