{
  "prompt": "Write a function to calculate the maximum flow in a flow network.",
  "answer": "**Maximum Flow in a Flow Network**\n=====================================\n\nThe maximum flow problem is a classic problem in graph theory and computer science. It involves finding the maximum amount of flow that can be sent from a source node to a sink node in a flow network.\n\n**Algorithm: Ford-Fulkerson Method with Edmonds-Karp Implementation**\n--------------------------------------------------------------------\n\nWe will use the Ford-Fulkerson method with the Edmonds-Karp implementation to solve this problem. This algorithm works by finding augmenting paths in the residual graph and augmenting the flow along these paths until no more augmenting paths can be found.\n\n**Code: Python**\n----------------\n\n```python\nfrom collections import deque\n\ndef bfs(graph, source, sink, parent):\n    \"\"\"\n    Breadth-first search to find if there is a path from source to sink.\n    \n    Args:\n    graph (list of lists): Residual graph.\n    source (int): Source node.\n    sink (int): Sink node.\n    parent (list): Parent array to store the path.\n    \n    Returns:\n    bool: True if there is a path from source to sink, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    queue = deque()\n    queue.append(source)\n    visited[source] = True\n    \n    while queue:\n        u = queue.popleft()\n        for ind, val in enumerate(graph[u]):\n            if not visited[ind] and val > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parent[ind] = u\n                \n                if ind == sink:\n                    return True\n                    \n    return False\n\n\ndef ford_fulkerson(graph, source, sink):\n    \"\"\"\n    Ford-Fulkerson method to find the maximum flow.\n    \n    Args:\n    graph (list of lists): Flow network.\n    source (int): Source node.\n    sink (int): Sink node.\n    \n    Returns:\n    int: Maximum flow.\n    \"\"\"\n    parent = [-1] * len(graph)\n    max_flow = 0\n    \n    while bfs(graph, source, sink, parent):\n        path_flow = float(\"inf\")\n        s = sink\n        while s != source:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        \n        max_flow += path_flow\n        \n        v = sink\n        while v != source:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    \n    return max_flow\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = [[0, 16, 13, 0, 0, 0],\n             [0, 0, 10, 12, 0, 0],\n             [0, 4, 0, 0, 14, 0],\n             [0, 0, 9, 0, 0, 20],\n             [0, 0, 0, 7, 0, 4],\n             [0, 0, 0, 0, 0, 0]]\n    \n    source = 0\n    sink = 5\n    \n    max_flow = ford_fulkerson(graph, source, sink)\n    print(\"Maximum flow:\", max_flow)\n```\n\n**Explanation:**\n\n1.  The `bfs` function performs a breadth-first search to find if there is a path from the source to the sink in the residual graph.\n2.  The `ford_fulkerson` function implements the Ford-Fulkerson method. It repeatedly finds augmenting paths in the residual graph using the `bfs` function and augments the flow along these paths until no more augmenting paths can be found.\n3.  The maximum flow is calculated by summing up the path flows along the augmenting paths.\n\n**Time Complexity:**\n\n*   The time complexity of the `bfs` function is O(V + E), where V is the number of vertices and E is the number of edges.\n*   The time complexity of the `ford_fulkerson` function is O(VE^2), where V is the number of vertices and E is the number of edges.\n\nNote: The time complexity can be improved using more efficient algorithms like the Dinic's algorithm or the push-relabel algorithm. However, these algorithms are more complex and may be overkill for simple use cases.",
  "timestamp": "2026-02-10T15:04:04.490611",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}