{
  "prompt": "Use a union type to store a value that can be of multiple types",
  "answer": "**Using Union Types**\n=======================\n\nUnion types allow you to store a value that can be of multiple types. Here's an example in TypeScript:\n\n```typescript\n// Define a union type\ntype UnionType = string | number | boolean;\n\n// Declare a variable with the union type\nlet value: UnionType;\n\n// Assign different types of values to the variable\nvalue = 'Hello, World!';  // string\nconsole.log(value);\n\nvalue = 42;  // number\nconsole.log(value);\n\nvalue = true;  // boolean\nconsole.log(value);\n```\n\nIn this example, the `value` variable can hold a `string`, `number`, or `boolean` value.\n\n**Using Union Types with Functions**\n------------------------------------\n\nYou can also use union types as function parameters or return types:\n\n```typescript\n// Define a function with a union type parameter\nfunction printValue(value: string | number | boolean): void {\n    console.log(value);\n}\n\n// Call the function with different types of values\nprintValue('Hello, World!');  // string\nprintValue(42);  // number\nprintValue(true);  // boolean\n```\n\n**Using Union Types with Arrays**\n-------------------------------\n\nYou can use union types to define arrays that can hold multiple types of values:\n\n```typescript\n// Define an array with a union type\nlet array: (string | number | boolean)[] = [];\n\n// Push different types of values to the array\narray.push('Hello, World!');  // string\narray.push(42);  // number\narray.push(true);  // boolean\n\nconsole.log(array);\n```\n\n**Using Union Types with Objects**\n---------------------------------\n\nYou can use union types to define objects that can have properties with multiple types of values:\n\n```typescript\n// Define an object with a union type property\ninterface ObjectType {\n    value: string | number | boolean;\n}\n\n// Create an object with different types of values\nlet obj1: ObjectType = { value: 'Hello, World!' };  // string\nlet obj2: ObjectType = { value: 42 };  // number\nlet obj3: ObjectType = { value: true };  // boolean\n\nconsole.log(obj1);\nconsole.log(obj2);\nconsole.log(obj3);\n```\n\n**Advantages of Union Types**\n-----------------------------\n\n1.  **Flexibility**: Union types allow you to define variables, function parameters, or return types that can hold multiple types of values.\n2.  **Type Safety**: Union types help ensure type safety by preventing you from assigning a value of an unsupported type to a variable or function parameter.\n3.  **Improved Code Readability**: Union types make your code more readable by explicitly defining the types of values that a variable or function can handle.\n\n**Best Practices for Using Union Types**\n------------------------------------------\n\n1.  **Use Union Types Judiciously**: Only use union types when necessary, as they can make your code more complex.\n2.  **Keep Union Types Simple**: Avoid using union types with too many types, as this can make your code harder to understand.\n3.  **Use Type Guards**: Use type guards to narrow the type of a value within a union type, making your code more type-safe and efficient.",
  "timestamp": "2026-02-12T10:37:02.710373",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}