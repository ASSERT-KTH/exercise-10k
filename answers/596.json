{
  "prompt": "Write a program that takes two strings as input and returns the minimum window substring that contains all characters of the second string.",
  "answer": "Here is a Python solution using the sliding window technique:\n\n```python\nfrom collections import Counter\n\ndef min_window(s1, s2):\n    \"\"\"\n    Returns the minimum window substring of s1 that contains all characters of s2.\n\n    Args:\n    s1 (str): The string to search for the minimum window.\n    s2 (str): The string containing the characters to search for.\n\n    Returns:\n    str: The minimum window substring of s1 that contains all characters of s2. If no such window exists, returns an empty string.\n    \"\"\"\n\n    # Base case: If s2 is longer than s1, there can't be a valid window\n    if len(s2) > len(s1):\n        return \"\"\n\n    # Create a counter for the characters in s2\n    s2_count = Counter(s2)\n\n    # Initialize the minimum window size to infinity\n    min_window_size = float('inf')\n    min_window = \"\"\n\n    # Initialize the left and right pointers of the sliding window\n    left = 0\n    right = 0\n\n    # Initialize a counter for the characters in the current window\n    window_count = {}\n\n    # Initialize the number of characters in the window that match s2\n    matched_chars = 0\n\n    # Expand the window to the right\n    while right < len(s1):\n        # Add the character at the right pointer to the window counter\n        char = s1[right]\n        window_count[char] = window_count.get(char, 0) + 1\n\n        # If the character is in s2 and its count in the window is less than or equal to its count in s2, increment the matched chars count\n        if char in s2_count and window_count[char] <= s2_count[char]:\n            matched_chars += 1\n\n        # While the window contains all characters of s2, try to shrink the window from the left\n        while matched_chars == len(s2):\n            # Update the minimum window if the current window is smaller\n            if right - left + 1 < min_window_size:\n                min_window_size = right - left + 1\n                min_window = s1[left:right + 1]\n\n            # Remove the character at the left pointer from the window counter\n            char = s1[left]\n            window_count[char] -= 1\n\n            # If the character is in s2 and its count in the window is less than its count in s2, decrement the matched chars count\n            if char in s2_count and window_count[char] < s2_count[char]:\n                matched_chars -= 1\n\n            # Move the left pointer to the right\n            left += 1\n\n        # Move the right pointer to the right\n        right += 1\n\n    return min_window\n\n\n# Example usage:\ns1 = \"ADOBECODEBANC\"\ns2 = \"ABC\"\nprint(min_window(s1, s2))  # Output: \"BANC\"\n```\n\nThis program works by maintaining a sliding window over the string `s1` and expanding it to the right until it contains all characters of `s2`. It then tries to shrink the window from the left while keeping all characters of `s2` in the window. The minimum window size is updated whenever a smaller window is found. The program returns the minimum window substring of `s1` that contains all characters of `s2`. If no such window exists, it returns an empty string.",
  "timestamp": "2026-02-10T15:20:30.051404",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}