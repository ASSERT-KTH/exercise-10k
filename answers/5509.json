{
  "prompt": "Write a program to find the longest common subsequence (LCS) of two strings.",
  "answer": "**Longest Common Subsequence (LCS) Program**\n=============================================\n\n### Overview\n\nThis program finds the longest common subsequence (LCS) of two input strings using dynamic programming.\n\n### Code\n```python\ndef longest_common_subsequence(str1, str2):\n    \"\"\"\n    Find the longest common subsequence of two strings.\n\n    Args:\n        str1 (str): The first input string.\n        str2 (str): The second input string.\n\n    Returns:\n        str: The longest common subsequence.\n    \"\"\"\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Initialize the dynamic programming table\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Reconstruct the LCS from the dynamic programming table\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            lcs.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # Return the LCS as a string\n    return \"\".join(reversed(lcs))\n\n\n# Example usage\ndef main():\n    str1 = \"AGGTAB\"\n    str2 = \"GXTXAYB\"\n    lcs = longest_common_subsequence(str1, str2)\n    print(f\"LCS of '{str1}' and '{str2}': {lcs}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n1.  Initialize a dynamic programming table `dp` with dimensions `(m + 1) x (n + 1)`, where `m` and `n` are the lengths of the input strings `str1` and `str2`, respectively.\n2.  Fill the table using the following rules:\n    *   If `i` or `j` is 0, set `dp[i][j]` to 0.\n    *   If `str1[i - 1]` equals `str2[j - 1]`, set `dp[i][j]` to `dp[i - 1][j - 1] + 1`.\n    *   Otherwise, set `dp[i][j]` to the maximum of `dp[i - 1][j]` and `dp[i][j - 1]`.\n3.  Reconstruct the LCS by tracing back the table from the bottom-right corner to the top-left corner.\n4.  If `str1[i - 1]` equals `str2[j - 1]`, add the character to the LCS and move diagonally up-left.\n5.  Otherwise, move up or left based on which cell has a higher value.\n6.  Return the LCS as a string by joining the characters in reverse order.\n\n### Time Complexity\n\nThe time complexity of this algorithm is O(m \\* n), where m and n are the lengths of the input strings. This is because we need to fill the dynamic programming table, which has m \\* n cells.\n\n### Space Complexity\n\nThe space complexity is also O(m \\* n) for the dynamic programming table. The space required for the LCS string is O(min(m, n)), as the LCS cannot be longer than the shorter input string.",
  "timestamp": "2026-02-11T15:22:55.491525",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}