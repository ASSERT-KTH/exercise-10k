{
  "prompt": "Write a program to find the shortest path between two nodes in a graph using Dijkstra's algorithm.",
  "answer": "**Dijkstra's Algorithm Implementation**\n=====================================\n\nBelow is a Python implementation of Dijkstra's algorithm to find the shortest path between two nodes in a graph.\n\n### Code\n\n```python\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_nodes):\n        self.num_nodes = num_nodes\n        self.adj_list = [[] for _ in range(num_nodes)]\n\n    def add_edge(self, node1, node2, weight):\n        self.adj_list[node1].append((node2, weight))\n        self.adj_list[node2].append((node1, weight))\n\n    def dijkstra(self, start_node):\n        distances = [sys.maxsize] * self.num_nodes\n        distances[start_node] = 0\n        pq = [(0, start_node)]\n\n        while pq:\n            current_distance, current_node = heapq.heappop(pq)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.adj_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n\n        return distances\n\n    def shortest_path(self, start_node, end_node):\n        distances = self.dijkstra(start_node)\n        return distances[end_node]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    num_nodes = 6\n    edges = [\n        (0, 1, 4),\n        (0, 2, 2),\n        (1, 3, 5),\n        (2, 1, 1),\n        (2, 3, 8),\n        (2, 4, 10),\n        (3, 4, 2),\n        (3, 5, 6),\n        (4, 5, 3)\n    ]\n\n    graph = Graph(num_nodes)\n    for node1, node2, weight in edges:\n        graph.add_edge(node1, node2, weight)\n\n    start_node = 0\n    end_node = 5\n    shortest_distance = graph.shortest_path(start_node, end_node)\n    print(f\"Shortest distance from node {start_node} to node {end_node}: {shortest_distance}\")\n```\n\n### Explanation\n\n1.  We define a `Graph` class with an adjacency list representation.\n2.  The `add_edge` method allows adding edges between nodes with their respective weights.\n3.  The `dijkstra` method implements Dijkstra's algorithm to find the shortest distances from a given start node to all other nodes.\n4.  We use a priority queue (implemented using `heapq`) to efficiently select the node with the minimum distance to explore next.\n5.  The `shortest_path` method calculates the shortest distance from a start node to an end node using the `dijkstra` method.\n6.  In the example usage, we create a graph with 6 nodes and add edges with their weights. We then find the shortest distance from node 0 to node 5 using the `shortest_path` method.\n\n### Time Complexity\n\n*   The time complexity of Dijkstra's algorithm is O((V + E) \\* logV) in the worst case, where V is the number of vertices (nodes) and E is the number of edges.\n*   The space complexity is O(V + E) for storing the adjacency list and priority queue.\n\n### Note\n\n*   This implementation assumes an undirected graph. If you need to work with a directed graph, simply remove the line that adds the reverse edge in the `add_edge` method.\n*   This code does not handle negative weight edges. If you need to work with graphs containing negative weight edges, consider using Bellman-Ford algorithm instead.",
  "timestamp": "2026-02-11T15:55:26.029585",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}