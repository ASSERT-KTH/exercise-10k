{
  "prompt": "Write a program to find the majority element in a given list of integers, where the majority element occurs more than n/2 times.",
  "answer": "**Majority Element Program**\n==========================\n\nBelow is a Python solution using the Boyer-Moore Majority Vote algorithm. This algorithm works by essentially keeping a counter for the majority element. As we iterate through the list, we increment the counter when we see the majority element and decrement it when we see a different element. If the counter becomes zero, we change the majority element to the current element.\n\n```python\ndef find_majority_element(nums):\n    \"\"\"\n    Find the majority element in a given list of integers.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The majority element if it exists, otherwise None.\n    \"\"\"\n    if not nums:\n        return None\n\n    # Initialize the majority element and count\n    majority_element = nums[0]\n    count = 1\n\n    # Iterate through the list\n    for num in nums[1:]:\n        # If the count is zero, change the majority element\n        if count == 0:\n            majority_element = num\n            count = 1\n        # Increment the count if we see the majority element\n        elif num == majority_element:\n            count += 1\n        # Decrement the count if we see a different element\n        else:\n            count -= 1\n\n    # Check if the majority element occurs more than n/2 times\n    if nums.count(majority_element) > len(nums) / 2:\n        return majority_element\n    else:\n        return None\n\n\n# Example usage\nif __name__ == \"__main__\":\n    nums = [3, 3, 4, 2, 4, 4, 2, 4, 4]\n    majority_element = find_majority_element(nums)\n\n    if majority_element is not None:\n        print(f\"The majority element is {majority_element}\")\n    else:\n        print(\"No majority element found\")\n```\n\n**How it Works**\n---------------\n\n1.  Initialize the majority element and count.\n2.  Iterate through the list, updating the count and majority element as necessary.\n3.  After iterating through the list, check if the majority element occurs more than n/2 times.\n4.  If it does, return the majority element. Otherwise, return None.\n\n**Time Complexity**\n------------------\n\n*   The Boyer-Moore Majority Vote algorithm has a time complexity of O(n), where n is the length of the input list.\n*   The `count` method has a time complexity of O(n), so the overall time complexity is O(n) + O(n) = O(2n), which simplifies to O(n).\n\n**Space Complexity**\n-------------------\n\n*   The algorithm uses a constant amount of space to store the majority element and count, so the space complexity is O(1).",
  "timestamp": "2026-02-12T02:11:44.739822",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}