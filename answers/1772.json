{
  "prompt": "Write a function to find the minimum window substring that contains all characters of a given string.",
  "answer": "**Minimum Window Substring Function**\n=====================================\n\nThe following function finds the minimum window substring that contains all characters of a given string. This function uses the sliding window technique and a dictionary to track the frequency of characters.\n\n```python\nfrom collections import Counter\n\ndef min_window_substring(s, t):\n    \"\"\"\n    Find the minimum window substring that contains all characters of a given string.\n\n    Args:\n    s (str): The string to search in.\n    t (str): The string containing the characters to search for.\n\n    Returns:\n    str: The minimum window substring that contains all characters of t. If no such substring exists, returns an empty string.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    # Create a dictionary to store the frequency of characters in t\n    t_count = Counter(t)\n    required_chars = len(t_count)\n\n    # Initialize variables to track the minimum window substring\n    left = 0\n    min_length = float('inf')\n    min_window = \"\"\n\n    # Initialize variables to track the current window substring\n    formed_chars = 0\n    window_counts = {}\n\n    # Iterate over the string s\n    for right in range(len(s)):\n        # Add the current character to the window counts\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        # If the added character is in t and its frequency in the window is equal to its frequency in t,\n        # increment the formed_chars count\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed_chars += 1\n\n        # While the window contains all characters of t and the left pointer is not at the beginning of the window,\n        # try to shrink the window from the left\n        while left <= right and formed_chars == required_chars:\n            # Update the minimum window substring if the current window is smaller\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n                min_window = s[left:right + 1]\n\n            # Remove the character at the left pointer from the window counts\n            character = s[left]\n            window_counts[character] -= 1\n\n            # If the removed character is in t and its frequency in the window is less than its frequency in t,\n            # decrement the formed_chars count\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed_chars -= 1\n\n            # Move the left pointer to the right\n            left += 1\n\n    # Return the minimum window substring\n    return min_window\n\n# Example usage:\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(min_window_substring(s, t))  # Output: \"BANC\"\n```\n\nThis function has a time complexity of O(n), where n is the length of the string s, and a space complexity of O(n), where n is the number of unique characters in the string t. The function returns the minimum window substring that contains all characters of t. If no such substring exists, it returns an empty string.",
  "timestamp": "2026-02-10T20:05:56.919154",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}