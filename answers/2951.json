{
  "prompt": "Write a program to check if a graph contains a cycle using depth-first search.",
  "answer": "**Graph Cycle Detection using Depth-First Search**\n\nBelow is a Python implementation of a program that checks if a graph contains a cycle using depth-first search (DFS). This implementation uses an adjacency list representation of the graph.\n\n```python\nfrom typing import Dict, List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        \"\"\"\n        Initialize a graph with a specified number of vertices.\n\n        Args:\n        num_vertices (int): The number of vertices in the graph.\n        \"\"\"\n        self.num_vertices = num_vertices\n        self.adjacency_list = {i: [] for i in range(num_vertices)}\n\n    def add_edge(self, vertex1: int, vertex2: int):\n        \"\"\"\n        Add an edge between two vertices in the graph.\n\n        Args:\n        vertex1 (int): The first vertex.\n        vertex2 (int): The second vertex.\n        \"\"\"\n        self.adjacency_list[vertex1].append(vertex2)\n\n    def has_cycle(self) -> bool:\n        \"\"\"\n        Check if the graph contains a cycle using DFS.\n\n        Returns:\n        bool: True if the graph contains a cycle, False otherwise.\n        \"\"\"\n        visited = [False] * self.num_vertices\n        recursion_stack = [False] * self.num_vertices\n\n        for vertex in range(self.num_vertices):\n            if not visited[vertex]:\n                if self._has_cycle_dfs(vertex, visited, recursion_stack):\n                    return True\n\n        return False\n\n    def _has_cycle_dfs(self, vertex: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        \"\"\"\n        Recursive DFS function to check for cycles.\n\n        Args:\n        vertex (int): The current vertex.\n        visited (List[bool]): A list of visited vertices.\n        recursion_stack (List[bool]): A list of vertices in the current recursion stack.\n\n        Returns:\n        bool: True if a cycle is detected, False otherwise.\n        \"\"\"\n        visited[vertex] = True\n        recursion_stack[vertex] = True\n\n        for neighbor in self.adjacency_list[vertex]:\n            if not visited[neighbor]:\n                if self._has_cycle_dfs(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[vertex] = False\n        return False\n\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 3)\n    graph.add_edge(3, 0)  # This edge creates a cycle\n\n    if graph.has_cycle():\n        print(\"The graph contains a cycle.\")\n    else:\n        print(\"The graph does not contain a cycle.\")\n\n    graph2 = Graph(4)\n    graph2.add_edge(0, 1)\n    graph2.add_edge(1, 2)\n    graph2.add_edge(2, 3)\n\n    if graph2.has_cycle():\n        print(\"The graph contains a cycle.\")\n    else:\n        print(\"The graph does not contain a cycle.\")\n```\n\n**Explanation**\n\n1.  We define a `Graph` class with methods to add edges and check for cycles using DFS.\n2.  The `has_cycle` method initializes visited and recursion stack lists and iterates over all vertices. For each unvisited vertex, it calls the `_has_cycle_dfs` function to perform DFS.\n3.  The `_has_cycle_dfs` function marks the current vertex as visited and adds it to the recursion stack. It then iterates over all neighbors of the vertex. If a neighbor is not visited, it recursively calls `_has_cycle_dfs` on the neighbor. If the neighbor is in the recursion stack, it means a cycle is detected, and the function returns True.\n4.  After visiting all neighbors, the vertex is removed from the recursion stack.\n5.  In the example usage, we create two graphs: one with a cycle and one without a cycle. We then use the `has_cycle` method to check for cycles in both graphs and print the results.\n\nThis implementation has a time complexity of O(V + E), where V is the number of vertices and E is the number of edges, since it visits each vertex and edge once during the DFS traversal.",
  "timestamp": "2026-02-11T01:04:57.411958",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}