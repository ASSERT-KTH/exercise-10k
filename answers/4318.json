{
  "prompt": "Write a function that handles errors using try-except blocks",
  "answer": "**Error Handling Function**\n==========================\n\nThe following is an example of a Python function that handles errors using try-except blocks. This function attempts to divide two numbers and catches any potential errors that may occur during the division process.\n\n```python\ndef divide_numbers(num1, num2):\n    \"\"\"\n    Divide two numbers and handle potential errors.\n\n    Args:\n        num1 (float): The dividend.\n        num2 (float): The divisor.\n\n    Returns:\n        float: The result of the division.\n\n    Raises:\n        TypeError: If either num1 or num2 is not a number.\n        ZeroDivisionError: If num2 is zero.\n    \"\"\"\n    try:\n        # Attempt to divide num1 by num2\n        result = num1 / num2\n        return result\n    except TypeError:\n        # Handle the case where either num1 or num2 is not a number\n        print(\"Error: Both inputs must be numbers.\")\n        return None\n    except ZeroDivisionError:\n        # Handle the case where num2 is zero\n        print(\"Error: Cannot divide by zero.\")\n        return None\n    except Exception as e:\n        # Catch any other unexpected errors\n        print(f\"An unexpected error occurred: {e}\")\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    print(divide_numbers(10, 2))  # Expected output: 5.0\n    print(divide_numbers(10, 0))  # Expected output: Error: Cannot divide by zero.\n    print(divide_numbers(10, \"a\"))  # Expected output: Error: Both inputs must be numbers.\n```\n\n**Best Practices for Error Handling**\n------------------------------------\n\nWhen using try-except blocks, keep the following best practices in mind:\n\n1.  **Specific Exceptions**: Catch specific exceptions instead of the general `Exception` class. This allows you to handle different types of errors in a more targeted way.\n2.  **Minimal Code in Try Block**: Keep the code within the try block to a minimum. This reduces the likelihood of catching unexpected errors and makes your code easier to debug.\n3.  **Informative Error Messages**: Provide informative error messages to help users understand what went wrong and how to correct the issue.\n4.  **Logging**: Consider logging errors for auditing and debugging purposes.\n\nBy following these guidelines and using try-except blocks effectively, you can write more robust and reliable code that handles errors in a predictable and user-friendly manner.",
  "timestamp": "2026-02-11T10:39:58.759679",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}