{
  "prompt": "Write a function that finds the longest increasing subsequence in a given list.",
  "answer": "**Longest Increasing Subsequence Function**\n=============================================\n\n### Description\n\nThe following function finds the longest increasing subsequence in a given list.\n\n### Code\n\n```python\ndef longest_increasing_subsequence(sequence):\n    \"\"\"\n    Finds the longest increasing subsequence in a given list.\n\n    Args:\n        sequence (list): A list of integers.\n\n    Returns:\n        list: The longest increasing subsequence.\n    \"\"\"\n    if not sequence:\n        return []\n\n    # Initialize a list to store the lengths of the longest increasing subsequences\n    lengths = [1] * len(sequence)\n\n    # Initialize a list to store the predecessors in the longest increasing subsequences\n    predecessors = [None] * len(sequence)\n\n    # Compute the lengths of the longest increasing subsequences\n    for i in range(1, len(sequence)):\n        for j in range(i):\n            if sequence[i] > sequence[j] and lengths[i] < lengths[j] + 1:\n                lengths[i] = lengths[j] + 1\n                predecessors[i] = j\n\n    # Find the index of the last element in the longest increasing subsequence\n    max_length_idx = max(range(len(lengths)), key=lambda i: lengths[i])\n\n    # Reconstruct the longest increasing subsequence\n    subsequence = []\n    while max_length_idx is not None:\n        subsequence.append(sequence[max_length_idx])\n        max_length_idx = predecessors[max_length_idx]\n\n    # Return the longest increasing subsequence in the correct order\n    return subsequence[::-1]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    sequence = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n    print(\"Longest Increasing Subsequence:\", longest_increasing_subsequence(sequence))\n```\n\n### Explanation\n\n1.  The function takes a list of integers as input and returns the longest increasing subsequence.\n2.  It initializes two lists, `lengths` and `predecessors`, to store the lengths of the longest increasing subsequences and their predecessors, respectively.\n3.  It computes the lengths of the longest increasing subsequences using dynamic programming.\n4.  It finds the index of the last element in the longest increasing subsequence and reconstructs the subsequence using the `predecessors` list.\n5.  Finally, it returns the longest increasing subsequence in the correct order.\n\n### Time Complexity\n\nThe time complexity of this function is O(n^2), where n is the length of the input sequence. This is because it uses two nested loops to compute the lengths of the longest increasing subsequences. The space complexity is O(n), as it needs to store the lengths and predecessors of the subsequences.",
  "timestamp": "2026-02-11T18:15:22.766670",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}