{
  "prompt": "Write a program to find the minimum window substring that contains all characters of a given string.",
  "answer": "**Minimum Window Substring Program**\n=====================================\n\nThis program finds the minimum window substring that contains all characters of a given string.\n\n**Code**\n------\n\n```python\nfrom collections import Counter\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring that contains all characters of string t.\n\n    Args:\n    s (str): The string to search in.\n    t (str): The string containing the characters to search for.\n\n    Returns:\n    str: The minimum window substring that contains all characters of string t. If no such substring exists, returns an empty string.\n    \"\"\"\n    if not s or not t:\n        return \"\"\n\n    # Create a counter for the characters in string t\n    t_count = Counter(t)\n\n    # Initialize the required character count\n    required_chars = len(t_count)\n\n    # Initialize the left and right pointers of the sliding window\n    left = 0\n\n    # Initialize the minimum window substring and its length\n    min_window_substring = \"\"\n    min_window_length = float('inf')\n\n    # Initialize the formed character count\n    formed_chars = 0\n\n    # Create a counter for the characters in the current window\n    window_counts = {}\n\n    # Iterate over the string s\n    for right in range(len(s)):\n        # Add the character at the right pointer to the window counter\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        # If the character is in t and its count in the window is equal to its count in t, increment the formed character count\n        if character in t_count and window_counts[character] == t_count[character]:\n            formed_chars += 1\n\n        # While the window contains all characters of string t and the left pointer is less than the right pointer\n        while left <= right and formed_chars == required_chars:\n            # Update the minimum window substring if the current window is smaller\n            if right - left + 1 < min_window_length:\n                min_window_length = right - left + 1\n                min_window_substring = s[left:right + 1]\n\n            # Remove the character at the left pointer from the window counter\n            character = s[left]\n            window_counts[character] -= 1\n\n            # If the character is in t and its count in the window is less than its count in t, decrement the formed character count\n            if character in t_count and window_counts[character] < t_count[character]:\n                formed_chars -= 1\n\n            # Move the left pointer to the right\n            left += 1\n\n    # Return the minimum window substring\n    return min_window_substring\n\n\n# Example usage\nif __name__ == \"__main__\":\n    s = \"ADOBECODEBANC\"\n    t = \"ABC\"\n    print(min_window(s, t))\n```\n\n**Explanation**\n--------------\n\nThis program uses a sliding window approach to find the minimum window substring that contains all characters of string t.\n\n1.  It first creates a counter for the characters in string t.\n2.  It then initializes the required character count, the left and right pointers of the sliding window, the minimum window substring, and its length.\n3.  It iterates over the string s, adding characters to the window counter and updating the formed character count as necessary.\n4.  When the window contains all characters of string t, it updates the minimum window substring if the current window is smaller.\n5.  It then removes characters from the window counter and updates the formed character count as necessary, moving the left pointer to the right.\n6.  Finally, it returns the minimum window substring.\n\n**Time Complexity**\n------------------\n\nThe time complexity of this program is O(n), where n is the length of string s.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of this program is O(n), where n is the length of string s.",
  "timestamp": "2026-02-10T23:38:02.548204",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}