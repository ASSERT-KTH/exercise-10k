{
  "prompt": "Write a program to find the minimum spanning tree of a weighted graph.",
  "answer": "**Minimum Spanning Tree Program**\n=====================================\n\nThis program uses Kruskal's algorithm to find the minimum spanning tree of a weighted graph. The graph is represented as an adjacency list, where each edge is a tuple of (node1, node2, weight).\n\n**Code**\n--------\n\n```python\nclass DisjointSet:\n    \"\"\"Disjoint set data structure for union-find operations.\"\"\"\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        \"\"\"Find the root of the set containing the given vertex.\"\"\"\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        \"\"\"Union the sets containing the given vertices.\"\"\"\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\n\ndef kruskal(graph):\n    \"\"\"\n    Find the minimum spanning tree of a weighted graph using Kruskal's algorithm.\n\n    Args:\n        graph: A list of edges, where each edge is a tuple of (node1, node2, weight).\n\n    Returns:\n        A list of edges in the minimum spanning tree.\n    \"\"\"\n    # Create a disjoint set data structure\n    vertices = set()\n    for edge in graph:\n        vertices.add(edge[0])\n        vertices.add(edge[1])\n    disjoint_set = DisjointSet(vertices)\n\n    # Sort the edges by weight\n    graph.sort(key=lambda x: x[2])\n\n    # Initialize the minimum spanning tree\n    mst = []\n\n    # Iterate over the sorted edges\n    for edge in graph:\n        node1, node2, weight = edge\n        # Check if the edge connects two different sets\n        if disjoint_set.find(node1) != disjoint_set.find(node2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Union the sets containing the nodes\n            disjoint_set.union(node1, node2)\n\n    return mst\n\n\ndef main():\n    # Example usage:\n    graph = [\n        ('A', 'B', 2),\n        ('A', 'C', 3),\n        ('B', 'C', 1),\n        ('B', 'D', 4),\n        ('C', 'D', 5)\n    ]\n\n    mst = kruskal(graph)\n    print(\"Minimum Spanning Tree:\")\n    for edge in mst:\n        print(edge)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Explanation**\n--------------\n\n1.  The program starts by defining a `DisjointSet` class, which represents a disjoint set data structure. This data structure is used to keep track of the connected components in the graph.\n2.  The `kruskal` function takes a list of edges as input and returns a list of edges in the minimum spanning tree. It first creates a disjoint set data structure and sorts the edges by weight.\n3.  The function then iterates over the sorted edges, checking if each edge connects two different sets. If it does, the edge is added to the minimum spanning tree, and the sets containing the nodes are unioned.\n4.  In the `main` function, an example graph is created, and the `kruskal` function is called to find the minimum spanning tree. The resulting minimum spanning tree is then printed to the console.\n\n**Time Complexity**\n------------------\n\nThe time complexity of the `kruskal` function is O(E log E) in the worst case, where E is the number of edges in the graph. This is because the edges are sorted by weight, which takes O(E log E) time. The disjoint set operations (find and union) take amortized O(\u03b1(n)) time, where \u03b1(n) is the inverse Ackermann function, which grows very slowly.\n\n**Space Complexity**\n-------------------\n\nThe space complexity of the `kruskal` function is O(V + E), where V is the number of vertices in the graph. This is because the disjoint set data structure and the minimum spanning tree are stored in memory.",
  "timestamp": "2026-02-11T15:20:22.771229",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}