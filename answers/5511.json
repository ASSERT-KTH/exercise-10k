{
  "prompt": "Write a program to find the minimum spanning tree of a graph using Kruskal's algorithm.",
  "answer": "Here's an implementation of Kruskal's algorithm to find the minimum spanning tree of a graph:\n\n```python\nclass DisjointSet:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n\n    def find(self, vertex):\n        if self.parent[vertex] != vertex:\n            self.parent[vertex] = self.find(self.parent[vertex])\n        return self.parent[vertex]\n\n    def union(self, vertex1, vertex2):\n        root1 = self.find(vertex1)\n        root2 = self.find(vertex2)\n\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            else:\n                self.parent[root1] = root2\n                if self.rank[root1] == self.rank[root2]:\n                    self.rank[root2] += 1\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.edges = []\n\n    def add_edge(self, vertex1, vertex2, weight):\n        self.edges.append((vertex1, vertex2, weight))\n\n    def kruskal_mst(self):\n        mst = []\n        self.edges.sort(key=lambda x: x[2])\n\n        disjoint_set = DisjointSet(self.vertices)\n\n        for edge in self.edges:\n            vertex1, vertex2, weight = edge\n            if disjoint_set.find(vertex1) != disjoint_set.find(vertex2):\n                mst.append(edge)\n                disjoint_set.union(vertex1, vertex2)\n\n        return mst\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    graph = Graph(['A', 'B', 'C', 'D', 'E'])\n    graph.add_edge('A', 'B', 1)\n    graph.add_edge('B', 'C', 2)\n    graph.add_edge('C', 'D', 3)\n    graph.add_edge('D', 'E', 4)\n    graph.add_edge('A', 'C', 5)\n    graph.add_edge('A', 'D', 6)\n    graph.add_edge('B', 'D', 7)\n    graph.add_edge('C', 'E', 8)\n\n    mst = graph.kruskal_mst()\n\n    print(\"Minimum Spanning Tree Edges:\")\n    for edge in mst:\n        print(f\"{edge[0]} - {edge[1]} : {edge[2]}\")\n\n```\n\n### Overview of the Code\n\n*   We define two classes, `DisjointSet` and `Graph`, to implement Kruskal's algorithm.\n*   The `DisjointSet` class represents a disjoint-set data structure, which is used to keep track of the connected components in the graph. It includes methods for finding the root of a vertex and unionizing two vertices.\n*   The `Graph` class represents the graph itself. It includes methods for adding edges to the graph and finding the minimum spanning tree using Kruskal's algorithm.\n*   In the `kruskal_mst` method, we first sort the edges in non-decreasing order of their weights.\n*   Then, we iterate over the sorted edges and add each edge to the minimum spanning tree if it does not form a cycle.\n*   We use the disjoint-set data structure to check for cycles.\n*   Finally, we return the minimum spanning tree as a list of edges.\n\n### Time Complexity\n\n*   The time complexity of Kruskal's algorithm is O(E log E) or O(E log V), where E is the number of edges and V is the number of vertices.\n*   The sorting step takes O(E log E) time, and the disjoint-set operations take O(E \u03b1(V)) time, where \u03b1(V) is the inverse Ackermann function, which grows very slowly.\n\n### Space Complexity\n\n*   The space complexity of Kruskal's algorithm is O(V + E), where V is the number of vertices and E is the number of edges.\n*   We need to store the vertices, edges, and the disjoint-set data structure, which requires O(V + E) space.",
  "timestamp": "2026-02-11T15:23:41.553674",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}