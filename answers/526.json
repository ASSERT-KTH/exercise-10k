{
  "prompt": "Implement a function to perform a topological sort on a directed acyclic graph (DAG).",
  "answer": "**Topological Sort Implementation**\n=====================================\n\n### Overview\n\nA topological sort is an ordering of the vertices in a directed acyclic graph (DAG) such that for every directed edge `u -> v`, vertex `u` comes before `v` in the ordering.\n\n### Code Implementation\n\n```python\nfrom collections import defaultdict, deque\n\ndef topological_sort(graph):\n    \"\"\"\n    Performs a topological sort on a directed acyclic graph (DAG).\n\n    Args:\n    graph: A dictionary representing the adjacency list of the graph.\n           Each key is a node, and its corresponding value is a list of its neighbors.\n\n    Returns:\n    A list of nodes in topological order.\n    \"\"\"\n\n    # Initialize the in-degree dictionary\n    in_degree = defaultdict(int)\n    \n    # Calculate the in-degree of each node\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n    \n    # Initialize the queue with nodes having an in-degree of 0\n    queue = deque([node for node in graph if in_degree[node] == 0])\n    \n    # Initialize the result list\n    result = []\n    \n    # Perform the topological sort\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        \n        # Decrease the in-degree of each neighbor\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check for cycles in the graph\n    if len(result) != len(graph):\n        raise ValueError(\"The graph contains a cycle and cannot be topologically sorted\")\n    \n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D'],\n        'D': []\n    }\n\n    try:\n        sorted_nodes = topological_sort(graph)\n        print(\"Topologically sorted nodes:\", sorted_nodes)\n    except ValueError as e:\n        print(e)\n```\n\n### Explanation\n\n1.  **In-degree calculation**: We calculate the in-degree of each node by iterating through the adjacency list and incrementing the in-degree of each neighbor.\n2.  **Queue initialization**: We initialize a queue with nodes having an in-degree of 0, as these nodes have no incoming edges and can be safely added to the result list first.\n3.  **Topological sort**: We perform the topological sort by repeatedly removing nodes from the queue, adding them to the result list, and decreasing the in-degree of their neighbors. If a neighbor's in-degree becomes 0, we add it to the queue.\n4.  **Cycle detection**: We check for cycles in the graph by verifying that the length of the result list is equal to the number of nodes in the graph. If not, we raise a `ValueError` indicating that the graph contains a cycle and cannot be topologically sorted.\n\n### Time Complexity\n\nThe time complexity of this implementation is O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph, since we perform a constant amount of work for each node and edge.\n\n### Space Complexity\n\nThe space complexity is O(V), as we need to store the in-degree of each node and the result list.",
  "timestamp": "2026-02-10T15:02:44.894816",
  "model": "RedHatAI/Llama-3.3-70B-Instruct-FP8-dynamic"
}